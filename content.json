{"meta":{"title":"Providence's blog","subtitle":null,"description":null,"author":"Ty","url":""},"pages":[],"posts":[{"title":"","date":"2020-08-11T13:33:03.364Z","path":"2020/08/11/Cpp/","text":"基础知识RAII全称是 Resource Acquisition Is Initialization ， 即“资源获取即初始化”，其核心是把资源和对象的生命周期绑定：对象创建获取资源，对象销毁释放资源。这就是的资源也有了生命周期，有了自动回收的功能。lock_guard 都利用了 RAII机制来实现。 防止内存泄露的方式有 RAII、智能指针。 大端和小端 大端就是高字节在高地址，低字节在低地址。 小端就是低字节在高地址，高字节在低地址。 123456789101112131415// 大端小端区分 bool isBigEndian() &#123; union NUM &#123; int a; char b; // 如果是大端 b 就是最高位 ，小端就是最低位 &#125;num; num.a = 0x1234; if(num.b == 0x12) &#123; return true; &#125; return false; &#125; 大端小端转换 12345678910//无符号整型16位 uint16_t bswap_16(uint16_t x) &#123; return ((x &amp; 0x00ff) &lt;&lt; 8) | (x &amp; 0xff00) &gt;&gt; 8) ; &#125; //无符号整型32位uint32_t bswap_32(uint32_t x) &#123; return ((x &amp; 0xff000000) &gt;&gt; 24)| ((x &amp; 0x00ff0000) &gt;&gt; 8) | \\ ((x &amp; 0x0000ff00) &lt;&lt; 8) | ((x &amp; 0x000000ff) &lt;&lt; 24) ; &#125; 生成可执行文件过程及各个过程完成的事情： 预编译处理(.c) : 将源文件main.cc 翻译成一个ASCII码的中间件文件 main.i 编译、优化程序（.s、.asm）： 将 main.i文件 翻译成一个 ASCII 汇编文件 main.s 汇编程序(.obj、.o、.a、.ko) ：运行汇编器，将 main.s 翻译成一个可重定位目标文件main.o 链接程序（.exe、.elf、.axf等） ： 运行链接器，将main.o 中使用到的目标文件组合起来，创建一个可执行的文件 为了构造可执行文件，这链接器必须完成两个主要任务： 符号解析 ：目的是将每个符号引用正好和一个符号定义关联起来。每个符号对应于一个函数、全局变量、static变量等 重定位：对于由编译器和汇编器生成的从地址0开始的代码和数据节，链接器将每个符号定义与一个内存位置关联起来，从而重定位这些数据节，然后修改所有对这些符号的引用，使得他们指向内存位置。静态库与动态库 根本区别：是在编译期还是在是执行期完成链接、装入动作。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接 静态库：之所以叫做静态库，是因为在链接阶段，当使用链接器将由汇编生成的目标文件构造成一个可执行的输出文件时，它只是复制静态库中里这个即将生成的可执行文件所引用到的目标模块。静态库特点总结： 静态库对函数库的链接是放在编译时期完成的。 程序在运行时与函数库再无瓜葛，移植方便。 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。 动态库：动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新 + 动态库把对一些库函数的**链接载入**推迟到程序运行的时期。 可以实现进程之间的资源共享。（因此动态库也称为共享库） 将一些程序升级变得简单。 甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。 编译型语言和解释型语言的区别 编译型语言在运行前就生成可执行文件，运行时就没有编译了 解释型语言在运行的时候才翻译static、extern、全局变量 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； 程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 extern全局变量(用extern修饰的变量只是说明该变量在其他地方定义，所以在其他地方一定要用明确的定义如int a，并且不能用static修饰）、static全局变量和static局部变量的生存期都是“永久”，区别只是可见域不同。extern全局变量可见区域是工程，static全局变量可见区域是文件，而static局部变量的可见区域是块。 volatile 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。 阻止编译器调整操作volatile变量的指令顺序。 注意：即使 volatile 能够阻止编译器调整顺序， 也无法阻止CPU动态调度换序（reorder） assert 断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。 assert 是个宏而非函数，如果条件返回错误，则会抛出异常，最后会调用 abort 终止程序，发送的是 SIGABRT，可以通过宏 NODEBUG 来关闭 assert，但是需要设置在源代码的开头。 12345678910111213#define assert(expr) \\ (static_cast &lt;bool&gt; (expr) \\ ? void (0) \\ : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))extern void __assert_fail (const char *__assertion, const char *__file, unsigned int __line, const char *__function)&#123; __THROW __attribute__ ((__noreturn__));&#125; 在判断失败时会调用 __assert_fail 来抛出异常，在C++中异常的底层是用 abort 实现的。 指针和引用的区别 目的不同：指针是为了兼容 C 而存在，引用是为了操作符重载而存在 在声明引用的的同时就要对它初始化，并且一经声明就不可以再和其它对象绑定在一起了。 引用更像是常量指针，只能改变绑定对象的值，不能改变绑定的对象。 引用它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，更加安全也增加了效率new、malloc new：不仅仅是分配内存，还包括了对象类型转换以及初始化 是先调用operator new分配内存空间，返回是void *类型； 再将返回类型转换为指定类型，再调用类的构造函数。 如果内存空间不足，会抛出std::bad_alloc异常 malloc 返回 void*类型，并且在内存不足时，返回NULL指针 当开辟的空间小于 128K时，调用brk() 函数，malloc的底层实现是系统调用函数 brk() 当开辟的空间大于 128K时，mmap() 系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟 operator new 底层也是由malloc实现。 malloc底层是由slab实现。 对于POD类型对象，使用new 创建的对象，也是可以使用free来释放销毁对象，原因就是在于这个对象是POD 类型。没有其他资源需要释放，或者文件描述符需要关闭，因此可以不调用析构函数而使用free来替代delete。尽管可以，但是不推荐，这样的代码并不健壮。 new 在C++里是可以用 malloc + placement 替代的，或者说等效于这两个。 1234567891011121314151617181920212223// 更好的展示 malloc 与 new 的区别与联系class Foo &#123; public: Foo(int a=0, int b=0): a(a),b(b) &#123; &#125; ~Foo() &#123; std::cout&lt;&lt;\"dtor\"&lt;&lt;std::endl; &#125;private: int a; int b;&#125;;int main(int argc, char const *argv[])&#123; // new = placement new + malloc Foo* foo = static_cast&lt;Foo*&gt;(::malloc(sizeof(Foo))); new(foo)Foo(1,1); // delete foo-&gt;~Foo(); ::free(foo); return 0;&#125;// 运行结束，无内存泄露 除了new和malloc，还有什么方式可以在堆中分配内存么，以及怎么释放？ mmap，munmap 多态多态的三个条件：继承，重写（override），基类引用指向派生类对象。 静态多态 重载，在编译时期就可以确定 模板技术：比如 CRTP，它是使用子类来作为基类的模板参数，在基类中调用子类的方法。 12345678template&lt;typename Derived&gt;class Base&#123; // 其他忽略 Derived&amp; convert() &#123; return static_cast&lt;Derived&amp;&gt;(*this); &#125;&#125;; 这个也从侧面说明static_cast 可以让子类转换为父类，要使得保证安全，前提是转换后调用子类的方法中没有使用子类独有的数据成员 动态多态运行时才确定调用的是哪个函数。核心关键在于虚函数：子类重写基类的虚方法，定义指向子类对象的基类指针。这个基类指针的行为直到运行时才能确定调用的是子类还是基类的方法，这就是多态。 实现原理是：虚函数表和虚函数指针vptr。详情 重载(overload)和重写(override) 重载：允许多个同名函数，而这些函数的参数列表不同，函数模板这么实现的，在编译期间就能确定。 C++函数重载底层实现原理是C++利用 name mangling 技术，来改变函数名，区分参数不同的同名函数。编译器通过函数名和其参数类型识别重载函数。不能仅仅基于不同的返回类型而实现函数重载，是因为经过 name mangling 后得到的函数名与返回值类型是无关的。 12345678void func(int a) &#123; &#125;int func(int a, int b) &#123; return a+b; &#125;int main(int argc, char const *argv[])&#123; return 0;&#125; 比如，如上的代码。在经过编译后，得到的符号表如下： 1234$ objdump -t main.o0000000000000000 g F .text 000000000000000e _Z4funci000000000000000e g F .text 0000000000000018 _Z4funcii0000000000000026 g F .text 0000000000000016 main 其中， 前缀 __z 是规定，4 是函数名的字符个数，i是第一个函数的参数类型int，ii是第二个函数的参数类型int, int。由此可见也是与返回值无关的。 重写override：是指子类重新定义父类的方法，子类的函数名和参数列表以及返回值必须与父类的完全一致。对于虚函数的重写，c++11中新定义了一个关键词override，就是为了让子类在重写父类的虚函数方法时，如何参数列表发生更改可以让编译器报错。 staticstatic变量都是在全局数据区分配内存,声明周期直到程序运行结束. 四类static 全局static变量和static函数：都已经被匿名命名空间取代，作用是不能外部文件使用 局部static变量：在数据区.data分配内存，首次初始化以后，以后调用都不会再初始化，作用域仅局限于函数，生命周期直到程序运行结束 静态数据成员:类对象共享，不能在类声明中定义，是因为在定义时就要分配空间，也是在.data 静态成员函数:静态成员函数，不隐含this指针，不能调用非静态成员函数/变量，可以用作回调函数 为什么要引入static 需要一个数据对象为整个类而非某个对象服务，同时又不能破坏类的封装特性，因此将静态成员隐藏在类的内部,提供静态成员函数接口，因为共享,可以节省内存。 对象 空类有六个成员函数 12345678910class Empty &#123; public: Empty(); Empty(const Empty&amp; ); ~Empty(); Empty&amp; operator=(consy Empty&amp; ); Empty* operator&amp; (); // 取地址运算符 const Empty* operator&amp; () const; // const 类型取地址运算符&#125;; 构造函数可以是虚函数吗？析构函数可以是虚函数吗？ 虚函数对应一个vtbl，这个vtbl实际是存储在对象的内存空间.如果构造函数是虚的,对象的构造就需要vtbl来调用，而虚函数表又是在对象构造后才能建立,因此构造函数不能是虚函数. 而析构函数在使用多态的继承中一般都是虚析构函数.为的是能正确选择析构函数. c++的深拷贝如何理解 在类中有指针时并且内部分配资源.经过浅拷贝后,最终会造成资源一次分配,多次释放.造成系统崩溃. C++中如何在main()函数之前执行操作main函数执行之前，主要就是初始化系统相关资源： 设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数 main函数执行之后： 全局对象的析构函数会在main函数之后执行； 可以用 atexit 注册一个函数，它会在main 之后执行;sizeof 和 strlen 区别12345678int main(int argc, char const *argv[])&#123; const char* str = \"name\"; sizeof(str); // 取的是指针str的长度，是8 strlen(str); // 取的是这个字符串的长度，不包含结尾的 \\0。大小是4 return 0;&#125; strcpy、strncpy和mmemcpy的区别 123char* strcpy(char* dest, const char* src);char* strncpy(char* dest, const char* src, size_t n);void* memcpy (void* dest, const void* src, size_t n); 前面两个函数是以字符为单位，而mmemcpy是以字节为单位。 strcpy和memcpy主要有以下3方面的区别。 复制的内容不同。strcpy 只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 复制的方法不同。strcpy 不需要指定长度，它遇到被复制字符的串结束符&#39;\\0&#39;才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，而且如果字符串数据中包含&#39;\\0&#39;，只能用memcpy。 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy strncpy ：在复制字符串时，memcpy更加类似于strncpy。strncpy和memcpy很相似，只不过它在一个终止的空字符处停止。当 n &gt; strlen(src) 时，dst[strlen(len)] ~ dst[n-1]都是\\0；当 n&lt;=strlen(src)时，复制前src的n个字符。这里隐藏了一个事实，就是dst指向的内存一定会被写n个字符。 memcpy需要注意的是： dest 指针要分配足够的空间，也即大于等于 n 字节的空间。如果没有分配空间，会出现断错误。 dest 和 src 所指的内存空间不能重叠（如果发生了重叠，使用 memmove() 会更加安全）。 动手实现 memcpy： 12345678910111213141516171819202122232425262728void* myMemcpy(void* dst, const void* src, size_t n) &#123; if(dst ==nullptr || src==nullptr) return nullptr; if(src == dst) retrun src; char* pdst = static_cast&lt;char*&gt;(dst); const char* psrc = static_cast&lt;const char*&gt;(src); // 发生重叠时，从后向前复制 if(psrc &lt; pdst &amp;&amp; pdst &lt; psrc + n) &#123; for(int i=n-1; i &gt;=0; --i) pdst[i] = psrc[i]; &#125; else &#123; for(int i=0; i &lt; n; ++i) pdst[i] = psrc[i]; &#125; return pdst;&#125;// 使用int main(int argc, char const *argv[])&#123; char buf[12]=&#123;0&#125;; char str[] = \"hello world cpp\"; myMemcpy(str, str+6, 9); std::cout&lt;&lt;str&lt;&lt;std::endl; return 0;&#125; 野指针和悬空指针 都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。 野指针野指针，指的是没有被初始化过的指针 1234567int main(void) &#123; int* p; // 未初始化 std::cout&lt;&lt; *p &lt;&lt; std::endl; // 未初始化就被使用 return 0;&#125; 因此，为了防止出错，对于指针初始化时都是赋值为 nullptr，这样在使用时编译器就会直接报错，产生非法内存访问。 悬空指针悬空指针，指针最初指向的内存已经被释放了的一种指针。 123456789int main(void) &#123; int * p = nullptr; int* p2 = new int; p = p2; delete p2;&#125; 此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为p=p2=nullptr。此时再使用，编译器会直接保错。 避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。 malloc、calloc、realloc123456#include &lt;stdlib.h&gt;void *malloc(size_t size);void *calloc(size_t nmemb, size_t size);void *realloc(void *ptr, size_t size);void free(void *ptr); malloc最常用的分配内存函数，分配size个字节。分配的内存是未初始化的，如果size==0，要么返回NULL，要么返回一个独一无二的指针，能被free释放。 realloc：用来改变已有内存区的大小，而不改变内容。新的大小为参数size，即newsize。 ptr==NULL：realloc(NULL,size)就相当于malloc(size) size==0：realloc(ptr, 0)就相当于free(ptr) ptr==NULL &amp;&amp; size==0：危险。 如果newsize &gt; oldsize，那么增加的内存是未初始化的，原来的内存内容保持不变，即[ptr, ptr+oldsize)内部不变，[ptr+oldsize, ptr+newsize)是初始化的内容。 如果newsize &lt; oldsize，尾部的内容就被切去，释放，只是剩下前面。 因此 realloc之后不能给这个内存区初始化. calloc分配nmemb个元素，每个元素大小是size个字节的连续内存。 内存大小是nmemb*size的连续内存区 这块内存被初始化为0。 如果size==0，要么返回NULL，要么返回一个独一无二的指针，能被free释放。 编译知识为了减小编译依赖加快编译速度和生成二进制文件的大小，C/C++ 项目中一般在 .h 文件对于*指针类型（包括智能指针） 尽量使用前置声明，而不是直接包含对应类的头文件。例如： 12345678910111213//Test.h//在这里使用A的前置声明，而不是直接包含A.h文件class A;class Test&#123;public: Test(); ~Test();private: A*&#125;; Copy Elisiong++ 编译器是默认开启 copy elison 选项的。如果要关闭这个选项，使用 -fno-elide-constructors。copy elision 主要包括以下两项内容： 1. 返回值优化 即通过将返回对象所占空间的直接构造到他们本来要复制/移动到的对象中去，依次来避免拷贝/移动操作。返回值优化包括具名返回值优化 NRVO 与 匿名返回值优化 URVO，区别在于返回值是具名的局部变量（NRVO）还是无名的临时对象（URVO） URVO 与 彻底 Copy elision 1234567891011121314151617181920class Copyable &#123; public: Copyable() &#123; std::cout&lt;&lt;\"default ctor\"&lt;&lt;std::endl; &#125; Copyable(const Copyable&amp; rhs) = delete; Copyable(Copyable&amp;&amp; rhs) = delete;&#125;;Copyable return_urvo_value() &#123; return Copyable&#123;&#125;; // since c++17 ok&#125;int main(int argc, char const *argv[]) &#123; auto x = return_urvo_value(); return 0;&#125; 上述代码在C++17中是可以编译通过的。在 C++17 之前，并没有明确的提出在什么情况下，可以彻底进行 Copy Elision（这里的彻底的指的是包括不进行检查是否有可用的 copy/move 构造函数）。在C++17中，对于匿名对象（or 临时对象）不论是传递参数，还是以返回值返回时，都不会调用拷贝/移动构造。因此上面的这段代码在C++17是可以正常编过的，而在C++14会编译出错。 123456789101112131415$ g++ main.cc -std=c++14 -o main &amp;&amp; ./mainmain.cc: In function ‘Copyable return_urvo_value()’:main.cc:29:19: error: use of deleted function ‘Copyable::Copyable(Copyable&amp;&amp;)’ 29 | return Copyable&#123;&#125;; | ^main.cc:24:3: note: declared here 24 | Copyable(Copyable&amp;&amp; rhs) = delete; | ^~~~~~~~main.cc: In function ‘int main(int, const char**)’:main.cc:34:31: error: use of deleted function ‘Copyable::Copyable(Copyable&amp;&amp;)’ 34 | auto x = return_urvo_value(); | ^main.cc:24:3: note: declared here 24 | Copyable(Copyable&amp;&amp; rhs) = delete; | ^~~~~~~~ 自然，只要将上面代码中的如下两行注释掉，即可正常编译，并且 Copyable的构造函数都是只被调用一次，即copy elision 起作用了。 注意：Copyable的复制/移动构造函数必须同时可访问。 12Copyable(const Copyable&amp; rhs) = delete; Copyable(Copyable&amp;&amp; rhs) = delete; 因此，在C++17以前，对于 urvo 不在乎是否返回的对象的复制/移动构造函数是否存在或者可访问，copy elision 都能生效。而在 C++14 之前，返回的对象可以没有复制/移动构造函数，但是必须可以访问。 nrvo在 nrvo时，返回对象的复制/移动构造函数必须可访问。否则编译不过。 1234567891011121314151617181920212223242526class Copyable &#123; public: Copyable() &#123; std::cout&lt;&lt;\"default ctor\"&lt;&lt;std::endl; &#125; Copyable(const Copyable&amp; rhs) = delete; Copyable(Copyable&amp;&amp; rhs) = delete;&#125;;Copyable return_urvo_value() &#123; return Copyable&#123;&#125;;&#125;Copyable return_nrvo_value() &#123; Copyable local; return local;&#125;int main(int argc, char const *argv[]) &#123; auto x = return_urvo_value(); auto y = return_nrvo_value(); return 0;&#125; 如上代码，即使是C++17也会编译失败，必须将如下两行代码注释掉，使得 Copyable 对象的复制/移动构造函数可访问。copy elision 才能生效：Copyable 的默认构造函数只调用一次。 12// Copyable(const Copyable&amp; rhs) = delete;// Copyable(Copyable&amp;&amp; rhs) = delete; 2. 右值拷贝优化 右值拷贝优化，当某一个类的临时对象以值传递给该类的另一个对象时，也可以直接利用该临时对象的来避免拷贝/移动操作。在上面的基础上，加上如下的代码：12345678910111213void pass_by_value(Copyable rhs) &#123; &#125;int main(int argc, char const *argv[]) &#123; auto x = return_urvo_value(); auto y = return_nrvo_value(); pass_by_value(Copyable()); return 0;&#125; 最终的输出也是调用默认三次构造函数：1234$ g++ main.cc -std=c++11 -o main &amp;&amp; ./maindefault ctordefault ctordefault ctor 到此，copy elision 基本分析结束。如果想查看没有copy elision 作用下的输出，开启-fno-elide-constructors。 Copy Elision 作用对于一些没有拷贝/移动构造的对象，如 unique_ptr、 atomic 等。现在我们能够定义一个工厂函数，即使没有复制或移动构造函数都可以返回一个对象。例如，以下通用工厂函数:12345678910111213141516template &lt;typename T, typename... Args&gt;T make_instance(Args&amp;&amp; ... args)&#123; return T&#123; std::forward&lt;Args&gt;(args)... &#125;;&#125;int main()&#123; int i = make_instance&lt;int&gt;(42); // std::unique_ptr 实现了 移动构造函数，因此可以编译成功 auto up = make_instance&lt;std::unique_ptr&lt;int&gt;&gt;(new int&#123; 42 &#125;); // 禁止了复制构造函数，但是也没有实现移动构造函数，因此要到 C++17 才能编译过 auto ai = make_instance&lt;std::atomic&lt;int&gt;&gt;(42); return 0;&#125; 参考 STLstd::vector std::vector 在 push_back 以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。 为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好 std::vector/std::list的实现原理及其使用场景std::vector是用连续内存的数组实现的，std::list是通过指针之间的指向实现不连续内存的高效率使用. std::vector 与 std::list 数组，最大的好处是能以 O(1) 用索引访问任意元素，次要好处是内存布局紧凑，省内存之余还有高缓存一致性（cache coherence）。但数组的缺点是不能快速插入元素，而且我们在解析 JSON 数组的时候，还不知道应该分配多大的数组才合适。 链表，它的最大优点是可快速地插入元素（开端、末端或中间），但需要以 O(n) 时间去经索引取得内容。如果我们只需顺序遍历，那么是没有问题的。还有一个小缺点，就是相对数组而言，链表在存储每个元素时有额外内存开销（存储下一节点的指针），而且遍历时元素所在的内存可能不连续，令缓存不命中（cache miss）的机会上升。 std::bind对于如下代码，使用 std::bind 绑定类的成员函数并调用。 1234567891011121314151617class Foo &#123; public: Foo()=default; void add(const int&amp; lhs, const int&amp; rhs) &#123; std::cout&lt;&lt; (lhs + rhs)&lt;&lt;std::endl;; &#125;&#125;;int main(int argc, char const *argv[])&#123; Foo foo1; // 绑定并且执行 std::bind(&amp;Foo::add, &amp;foo1, 1, 2)(); return 0;&#125; 最后内部执行的代码如下： 123456template&lt;typename _Res, typename _MemFun, typename _Tp, typename... _Args&gt;constexpr _Res__invoke_impl(__invoke_memfun_deref, _MemFun&amp;&amp; __f, _Tp&amp;&amp; __t, _Args&amp;&amp;... __args)&#123; return ((*std::forward&lt;_Tp&gt;(__t)).*__f)(std::forward&lt;_Args&gt;(__args)...);&#125; 其中 _t ，类型是 Foo*&amp; 函数对象指针，指向的foo1对象。 _f是函数指针，指向的就是add成员函数 __invoke_memfun_deref：是用来标记是哪种把绑定方式，比如上述代码中的绑定对象成员函数 因此，最终，调用可以简化为如下： 1foo1.add(1,2); 整个std::bind 最终的执行代码如下： 123456789101112131415161718192021222324252627282930// 直接传入函数调用: std::bind(func, arg1, arg2); 或者静态成员函数// 很明显，这里没有类对象template&lt;typename _Res, typename _Fn, typename... _Args&gt;constexpr _Res__invoke_impl(__invoke_other, _Fn&amp;&amp; __f, _Args&amp;&amp;... __args)&#123; return std::forward&lt;_Fn&gt;(__f)(std::forward&lt;_Args&gt;(__args)...); &#125;// 上面介绍过template&lt;typename _Res, typename _MemFun, typename _Tp, typename... _Args&gt;constexpr _Res__invoke_impl(__invoke_memfun_deref, _MemFun&amp;&amp; __f, _Tp&amp;&amp; __t, _Args&amp;&amp;... __args)&#123; return ((*std::forward&lt;_Tp&gt;(__t)).*__f)(std::forward&lt;_Args&gt;(__args)...);&#125;// 下面几种没见过调用template&lt;typename _Res, typename _MemFun, typename _Tp, typename... _Args&gt;constexpr _Res__invoke_impl(__invoke_memfun_ref, _MemFun&amp;&amp; __f, _Tp&amp;&amp; __t, _Args&amp;&amp;... __args)&#123; return (__invfwd&lt;_Tp&gt;(__t).*__f)(std::forward&lt;_Args&gt;(__args)...); &#125;template&lt;typename _Res, typename _MemPtr, typename _Tp&gt;constexpr _Res__invoke_impl(__invoke_memobj_ref, _MemPtr&amp;&amp; __f, _Tp&amp;&amp; __t)&#123; return __invfwd&lt;_Tp&gt;(__t).*__f; &#125;template&lt;typename _Res, typename _MemPtr, typename _Tp&gt;constexpr _Res__invoke_impl(__invoke_memobj_deref, _MemPtr&amp;&amp; __f, _Tp&amp;&amp; __t)&#123; return (*std::forward&lt;_Tp&gt;(__t)).*__f; &#125; Lambda lambda可以理解为是仿函数的语法糖。 1234567int main(int argc, char const *argv[])&#123; auto add = [](int a, int b) &#123; return a+b; &#125;; int c = add(1,2); return 0;&#125; 对于上面的lambda函数，在gdb调试，经过编译的到的函数类型： 123(gdb) s&lt;lambda(int, int)&gt;::operator()(int, int) const (__closure=0x7fffffffe6d3, a=1, b=2) at main.cpp:2424 auto add = [](int a, int b) &#123; return a+b; &#125;; lambda可以看作是匿名的函数对象，并且 lambda表达式默认是 const属性。 1234567891011121314class Foo &#123; public: Foo() &#123; []()&#123;std::cout&lt;&lt;\"123\"&lt;&lt;std::endl; &#125;(); &#125;&#125;;int main(int argc, char const *argv[])&#123; Foo foo; return 0;&#125; 在类中调用lambda表达式，编译出来的类型如下： 1Foo::Foo()::&#123;lambda()#1&#125;::operator()() const 而实际上，lambda与operator本质上也是一样的，如下代码：1234567891011121314151617181920212223242526class Foo &#123; public: Foo() &#123; // 以下两个设计等价 [this](const char* str)&#123;this-&gt;print(str); &#125;(\"lambda\"); Unmaed(this)(\"operator\"); &#125; void print(const char* str) &#123; std::cout&lt;&lt;str&lt;&lt;std::endl; &#125; private: struct Unmaed &#123; Unmaed(Foo* foo): foo_(foo) &#123; &#125; void operator()(const char* str) const &#123; foo_-&gt;print(str); &#125; Foo* foo_; &#125;; &#125;; std::bind 与 lambad区别 lambda 可以重载，但是 std::bind 无法区别重载 123456 void f(int) &#123;&#125;void f(double) &#123;&#125; auto g = [] &#123; f(1); &#125;; // OK auto g = std::bind(f, 1); // 错误 auto g = std::bind(static_cast&lt;void(*)(int)&gt;(f), 1); // OK 为此必须指定对应的函数指针类型。lambda 闭包类的 operator() 采用的是能被编译器内联的常规的函数调用。而std::bind采用的是一般不会被内联的函数指针调用，这意味着 lambda 比 std::bind 运行得更快。 传给 std::bind 的参数，绑定的是 std::bind，而不是std::bind内部管理的函数123456789101112131415161718void f(std::chrono::steady_clock::time_point t, int i)&#123; std::this_thread::sleep_until(t); std::cout &lt;&lt; i;&#125;auto g = [](int i)&#123; f(std::chrono::steady_clock::now() + std::chrono::seconds(3), i);&#125;;g(1); // 3秒后打印1// 用std::bind实现相同效果，但存在问题auto h = std::bind(f, std::chrono::steady_clock::now() + std::chrono::seconds(3), std::placeholders::_1);h(1); // 3秒后打印1，但3秒指的是调用std::bind后的3秒，而非调用f后的3秒 计算时间的表达式作为实参被传递给std::bind，因此计算发生在调用std::bind的时刻，而非调用其绑定的函数的时刻。 在 c++14 中，完全没有理由使用 std::bind，c++11由于特性受限，存在两个使用场景： 模拟c++11缺少的移动捕获 函数对象 operator() 是模板时，如果将此函数作为参数使用，用 std::bind 绑定才能接受任意类型参数1234567891011 struct X &#123; template&lt;typename T&gt; void operator()(const T&amp;) const; &#125;; X x; auto f = std::bind(x, _1); // f可以接受任意参数类型 // c++14 做法 X a; auto f = [a](const auto&amp; x) &#123; a(x); &#125;; Lambda 与 std::bind 区别补充std::bind 传入的参数默认情况下是 “值传递”，想要使用引用传递需要std::ref。详细可以参考下面的代码： 123456789101112131415161718192021222324252627282930313233343536class Foo &#123; public: Foo() &#123; std::cout&lt;&lt;\"default\"&lt;&lt;std::endl; &#125; Foo(const Foo&amp; rhs) &#123; std::cout&lt;&lt;\"ctor\"&lt;&lt;std::endl; &#125;&#125;;void add(const Foo&amp; lhs, const Foo&amp; rhs) &#123; &#125;int main(int argc, char const *argv[])&#123; std::cout&lt;&lt;std::boolalpha; Foo foo1; Foo foo2; std::cout&lt;&lt;\"bind: pass by value\"&lt;&lt;std::endl; auto func = std::bind(add, foo1, foo2); std::cout&lt;&lt;\"bind: pass by ref\"&lt;&lt;std::endl; auto func = std::bind(add, std::ref(foo1), std::ref(foo2)); std::cout&lt;&lt;\"lambda \"&lt;&lt;std::endl; [&amp;foo1, &amp;foo2]&#123; add(foo1, foo2);&#125;(); return 0;&#125; 上面的代码输出：12345678$ g++ -g -O0 main.cc -o main &amp;&amp; ./maindefaultdefaultbind: pass by valuectorctorbind: pass by reflambda 可以看到std::bind在默认情况下，是依靠值传递，使用了std::ref来包裹传入参数才是使用引用传递。用 gdb 调试，可以跟踪到发生构造 Foo 对象的位置：123456789101112131415template&lt;typename _UHead&gt;constexpr _Head_base(_UHead&amp;&amp; __h) : _Head(std::forward&lt;_UHead&gt;(__h)) &#123; &#125;// 整个调用链如下：#0 Foo::Foo (this=0x7fffffffe068, rhs=...) at main.cc:13#1 0x0000555555555a8c in std::_Head_base&lt;1ul, Foo, true&gt;::_Head_base&lt;Foo&amp;&gt; (this=0x7fffffffe068, __h=...) at /usr/include/c++/9/tuple:87#2 0x00005555555559e8 in std::_Tuple_impl&lt;1ul, Foo&gt;::_Tuple_impl&lt;Foo&amp;&gt; (this=0x7fffffffe068, __head=...) at /usr/include/c++/9/tuple:349#3 0x00005555555558f3 in std::_Tuple_impl&lt;0ul, Foo, Foo&gt;::_Tuple_impl&lt;Foo&amp;, Foo&amp;, void&gt; (this=0x7fffffffe068, __head=...) at /usr/include/c++/9/tuple:218#4 0x0000555555555815 in std::tuple&lt;Foo, Foo&gt;::tuple&lt;Foo&amp;, Foo&amp;, true&gt; (this=0x7fffffffe068, __a1=..., __a2=...) at /usr/include/c++/9/tuple:969#5 0x00005555555556fc in std::_Bind&lt;void (*(Foo, Foo))(Foo const&amp;, Foo const&amp;)&gt;::_Bind&lt;Foo&amp;, Foo&amp;&gt;(void (*&amp;&amp;)(Foo const&amp;, Foo const&amp;), Foo&amp;, Foo&amp;) (this=0x7fffffffe060, __f=@0x7fffffffe010: 0x5555555551ea &lt;add(Foo const&amp;, Foo const&amp;)&gt;) at /usr/include/c++/9/functional:467#6 0x0000555555555571 in std::bind&lt;void (&amp;)(Foo const&amp;, Foo const&amp;), Foo&amp;, Foo&amp;&gt; (__f= @0x5555555551ea: &#123;void (const Foo &amp;, const Foo &amp;)&#125; 0x5555555551ea &lt;add(Foo const&amp;, Foo const&amp;)&gt;) at /usr/include/c++/9/functional:812#7 0x00005555555552b7 in main (argc=1, argv=0x7fffffffe198) at main.cc:30 左值引用和右值引用区别 左值引用，也就是“常规引用”，不能绑定到要转换的表达式，字面常量，或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。 右值引用就是必须绑定到右值的引用，通过&amp;&amp;获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。 返回左值的表达式包括返回左值引用的函数及赋值，下标，解引用和前置递增/递减运算符； 返回右值的包括返回非引用类型的函数及算术，关系，位和后置递增/递减运算符。可以看到左值的特点是有持久的状态，而右值则是短暂的 12345678void func(int&amp;&amp; index, int idx) &#123; if(idx &gt; 3) return; func(index++, ++idx); // Ok func(++index, ++idx); // Error std::cout&lt;&lt; std::is_rvalue_reference&lt;decltype(index)&gt;::value &lt;&lt;std::endl;&#125; 在上面的代码中，++index 产生的是左值，而 index++ 产生的是右值。因此上面的可以编译成功，下面的编译不过。 【注意】：已经命名的右值，编译器会认为是左值。 左值与右值变量都是左值，即使变量是右值引用类型12int&amp;&amp; ref1 = 1; // ok int&amp;&amp; ref2 = ref1; // error 因为 ref2 是右值引用类型的变量，不能将其绑定到左值ref1上。ref1 与 ref2 是左值，因为他们都是变量，但是变量类型是右值引用类型，即这两个变量只能绑定到右值上。 四种类型转换总结static_cast 基类和子类之间转换： static_cast 的使用，当且仅当类型之间可隐式转化时，static_cast 的转化才是合法的。有一个例外，那就是类层次间的向下转型，static_cast 可以完成类层次间的向下转型，但是向下转型无法通过隐式转换完成。 向上转换安全：子类指针转换成父类指针是安全的; 向下转换不安全：父类指针转换成子类指针是不安全的。 static_cast不能进行无关类型(如非基类和子类)指针之间的转换。 12345class Base&#123; &#125;;class Derived : public base&#123; /**....*/ &#125;; Base* B = new Base; Derived* D = static_cast&lt;Drived*&gt;(B); // 不安全 为什么不安全？ D指向本质上还是B的对象模型，D指向的内存模型中可能存在B没有的成员变量。如果 D-&gt;foo() 中使用了 D 的成员变量，那么这个函数调用就是不安全的。因此，向下转换是安全的。 static_cast 还可以在左值和右值之间显示地转换。虽然不能隐式地将左值转换为右值，但是可以使用static_cast显示地将左值转换为右值。 基本数据类型转换: enum, int, char, float等。安全性问题由开发者来保证。 把空指针转换成目标类型的空指针 1int* iptr = static_cast&lt;int*&gt;(::malloc(sizoef(int))); 把任何类型的表达式转换成void类型：static_cast&lt;void&gt;(iptr) static_cast 不能去掉类型的const、volitale属性(用const_cast) 隐式转换都建议使用 static_cast 进行标明和替换 dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 nullptr 指针。 使用特点： 基类必须要有虚函数，因为dynamic_cast是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数，才会有虚函数表 对于下行转换，dynamic_cast是安全的（当类型不一致时，转换过来的是空指针），而static_cast是不安全的（当类型不一致时，转换过来的是错误意义的指针，可能造成踩内存，非法访问等各种问题), reinterpreter_cast 下行转换是可以转换，但是不安全。 相同基类不同子类之间的交叉转换，转换结果是是 nullptr 1234567891011121314class Base&#123;public: virtual void fun() &#123; &#125; &#125;;class Drived : public base &#123;public: int i;&#125;;Base *Bptr = new Drived()；//语句0Derived *Dptr1 = static_cast&lt;Derived*&gt;(Bptr); //语句1；Derived *Dptr2 = dynamic_cast&lt;Derived*&gt;(Bptr); //语句2； 此时语句1和语句2都是安全的，因为此时 Bptr 确实是指向的派生类的内存模型，所以两个类型转换都是安全的。Dptr1 和 Dptr2 可以尽情访问 Drived 类中的成员，绝对不会出问题。但是如果此时语句0更改为如下表达： 1Base* Bptr = new Base(); ` 那么 Bptr 指向的是Base对象内存模型。因此语句1是不安全的，因为如果访问子类的数据成员，其行为将是未定义。而语句2返回的是 nullptr，更加直观的告诉用户不安全。 reinterpreter_cast用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时执行的是逐 byte 复制的操作。 reinterpret_cast是从底层对数据仅仅进行重新解释，但没有进行二进制的转换，依赖具体的平台，可移植性差； reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组； reinterpret_cast可以在指针和引用里进行肆无忌惮的转换； const_cast 常量指针转换为非常量指针， 并且仍然指向原来的对象 常量引用被转换为非常量引用，并且仍然指向原来的对象 自己实现一个非侵入式的智能指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// RAII 技术封装 class RefCount &#123;public: RefCount() : reference_&#123;0&#125; &#123; &#125; ~RefCount() &#123; this-&gt;decrementRef(); &#125; void IncrementRef() &#123; ++reference_; &#125; bool decrementRef() &#123; if (--reference_ == 0) &#123; delete this; return true; &#125; return false; &#125; int64_t use_count() &#123; return reference_; &#125; private: std::atomic&lt;int64_t&gt; reference_; &#125;; template &lt;typename T&gt; class SharedPtr &#123; public: SharedPtr() : ptr_(nullptr) &#123;&#125; explicit SharedPtr(T* ptr) : ptr_(ptr), ref_(new RefCount) &#123; if (ref_) ref_-&gt;IncrementRef(); &#125; SharedPtr(const SharedPtr&amp; other) : ptr_(other.ptr_), ref_(other.ref_) &#123; if (ref_) ref_-&gt;IncrementRef(); &#125; SharedPtr(SharedPtr&amp;&amp; other) noexcept &#123; ptr_ = other.ptr_; ref_ = other.ref_; other.ptr_ = nullptr; other.ref_ = nullptr; &#125; SharedPtr&amp; operator=(const SharedPtr&amp; other) &#123; if (this == &amp;other || *this == other) return *this; reset(); ptr_ = other.ptr_; ref_ = other.ref_; ref_-&gt;IncrementRef(); return *this; &#125; SharedPtr&amp; operator=(SharedPtr&amp;&amp; other) noexcept &#123; if (this == &amp;other || *this == other) return *this; reset(); ptr_ = other.ptr_; ref_ = other.ref_; other.ptr_ = nullptr; other.ref_ = nullptr; return *this; &#125; ~SharedPtr() &#123; if (ref_) this-&gt;decrementRef(); &#125; T&amp; operator*() const &#123; return *ptr_; &#125; T* operator-&gt;() const &#123; return ptr_; &#125; explicit operator bool() const &#123; return !!ptr_; &#125; T* get() const &#123; return ptr_; &#125; void reset() &#123; if (ptr_) &#123; this-&gt;decrementRef(); // ptr_ = nullptr; &#125; &#125; void decrementRef() &#123; if(ref_ &amp;&amp; ptr_) &#123; if(ref_-&gt;decrementRef()) &#123; delete ptr_; ptr_ = nullptr; &#125; &#125; &#125; int64_t use_count() &#123; return ref_-&gt;use_count(); &#125; bool unique() &#123; return use_count() == 1; &#125; void swap(SharedPtr &amp; other) &#123; std::swap(ptr_, other.ptr_); std::swap(ref_, other.ref_); &#125; friend inline bool operator==(SharedPtr const&amp; lhs, SharedPtr const&amp; rhs) &#123; return lhs.ptr_ == rhs.ptr_; &#125; friend inline bool operator!=(SharedPtr const&amp; lhs, SharedPtr const&amp; rhs) &#123; return lhs.ptr_ != rhs.ptr_; &#125; friend inline bool operator&lt;(SharedPtr const&amp; lhs, SharedPtr const&amp; rhs) &#123; return lhs.ptr_ &lt; rhs.ptr_; &#125; private: T* ptr_; RefCount* ref_; &#125;; int main(int argc, char const *argv[]) &#123; SharedPtr&lt;int&gt; iptr (new int); SharedPtr&lt;int&gt; iptr2(iptr); SharedPtr&lt;int&gt; iptr3(std::move(iptr)); SharedPtr&lt;int&gt; iptr4 = iptr2; SharedPtr&lt;int&gt; iptr5 = std::move(iptr3); std::cout&lt;&lt;iptr5.use_count()&lt;&lt;std::endl; // 3 return 0; &#125; 迭代器失效的场景 序列式容器 序列式容器会失效的原因是因为其存储都是连续的，因此删除或者插入一个元素都有可能导致其他元素的迭代器失效。 vector 在遍历时，执行erase会导致删除节点之后的全部失效 在push_back时，之前的end()操作得到的迭代器失效 insert/push_back导致capacity()改变，那么之前的first()/end()得到的迭代器会失效 insert一个元素，如果空间没有分配，那么插入节点之前的迭代器位置有效，之后的失效。 简而言之：导致内存分配的全会失效，导致元素移动的会局部失效 deque 在首尾添加元素，会导致迭代器失效，但是指针、引用不会失效 其余位置插入元素，迭代器、指针、引用都是失效 在首尾之外的位置删除元素，那么其他位置的迭代器都失效 在首尾删除元素，只是会导致被指向的删除元素的迭代器失效 关联式容器 基于哈希表实现的std::unordered_map/std::set 导致迭代器失效，一般是插入元素导致 reshash 产生，如果是删除只是会导致被删除元素的迭代器失效。std::unordered_map底层实现及其解决 hash 冲突方法 std::unorder_map 解决冲突方式是 拉链法（数组的每个元素都连着一个链表？）：将所有产生冲突的关键字所对应的数据全部存储在同一个线性链表中（bucket）。这个方法解决数据存储位置发生冲突的哈希表，整个存储结构如图 1 所示。 其中 p_i表示存储的各个键值对。 当使用无序容器存储键值对时，会先申请一整块连续的存储空间，但此空间并不用来直接存储键值对，而是存储各个链表的头指针，各键值对真正的存储位置是各个链表的节点。STL 标准库默认选用vector容器存储各个链表的头指针。STL 标准库中，将图 1 中的各个链表称为桶 bucket，每个桶都有自己的编号（从 0 开始）。当有新键值对存储到无序容器中时，整个存储过程分为如下几步： 将该键值对中 key 的值带入设计好的哈希函数，会得到一个哈希值: H = hash(key)； 将 H 和无序容器拥有桶的数量 n 做整除运算（即H % n），该结果即表示应将此键值对存储到的桶的编号； 建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上 其他解决冲突的方法 开放地址法： H =(hash(key) + d) \\% m 其中`m`是哈希表的表长，`d`是一个增量，当产生冲突时，选择以下三种方法一种获取d的值，然后计算，直到计算出的*hash* 值不存在冲突。 + 线性探测法：d = 1,2,3,... + 二次探测法：d = 12,-12, 22, -22... + 伪随机数探测法: d = 伪随机数 再哈希法rehasp当通过哈希函数求得的哈希地址同其他关键字产生冲突时，使用另一个哈希函数计算，直到冲突不再发生 rehashp上述的拉链法解决了哈希冲突的问题，但是当插入元素很多，产生了严重哈希冲突时，就会导致某个链表长度越来越长，进而导致哈希表的查找就会退化为链表，效率降低为O(n)的时间复杂度。 哈希表存储结构还有一个重要的属性，称为负载因子load factor，用于衡量容器存储键值对的空/满程度：即负载因子越大，意味着容器越满，即各链表中挂载着越多的键值对，这无疑会降低容器查找目标键值对的效率；反之，负载因子越小，容器肯定越空，但并不一定各个链表中挂载的键值对就越少。 负载因子的计算方法为：负载因子 = 容器存储的总键值对 / 桶数 STL 中默认情况下，无序容器的最大负载因子为 1.0。如果操作无序容器过程中，使得最大复杂因子超过了默认值，则容器会自动增加桶数，并重新进行哈希，以此来减小负载因子的值。需要注意的是，此过程会导致容器迭代器失效，但指向单个键值对的引用或者指针仍然有效。 因此当插入元素过多，使得负载因子的大于1.0，就会产生rehash行为，来改善即将下降的效率。 STL中的 unordered_map 的 rehash 策略一下代码节选自g++的STL库： 12345678910111213141516171819202122232425262728293031323334353637383940414243// __n_bkt is current bucket count, __n_elt is current element count,// and __n_ins is number of elements to be inserted. Do we need to// increase bucket count? If so, return make_pair(true, n), where n// is the new bucket count. If not, return make_pair(false, 0).std::pair&lt;bool, size_t&gt; _M_need_rehash(size_t __n_bkt, size_t __n_elt, size_t __n_ins) noexcept &#123; if (__n_elt + __n_ins &gt;= _M_next_resize) &#123; long double __min_bkts = (__n_elt + __n_ins) / (long double)_M_max_load_factor; if (__min_bkts &gt;= __n_bkt) // 这个是需要rehash 时返回的策略 return std::make_pair(true, _M_next_bkt(std::max&lt;size_t&gt;(__builtin_floor(__min_bkts) + 1, __n_bkt * _S_growth_factor))); _M_next_resize = __builtin_floor(__n_bkt * (long double)_M_max_load_factor); return std::make_pair(false, 0); &#125; return std::make_pair(false, 0); &#125;size_t _M_next_bkt(size_t __n) noexcept &#123; const auto __max_width = std::min&lt;size_t&gt;(sizeof(size_t), 8); // 8 个字节 const auto __max_bkt = size_t(1) &lt;&lt; (__max_width * __CHAR_BIT__ - 1); // 2 ^ 63 size_t __res = __clp2(__n); // 计算大于等于 n 的最小的2的幂 if (__res == __n) __res &lt;&lt;= 1; if (__res == 0) __res = __max_bkt; // Set next resize to the max value so that we never try to rehash again // as we already reach the biggest possible bucket number. // Note that it might result in max_load_factor not being respected. if (__res == __max_bkt) _M_next_resize = size_t(-1); else _M_next_resize = __builtin_ceil(__res * (long double)_M_max_load_factor); return __res;&#125; 其中，在这个类的前面有定义： _M_max_load_factor 初始化为 1.0 static const size_t _S_growth_factor = 2; 整个扩容的策略大致是按照2倍的策略增长，但是并不严格按照。在MSVC中按照的是8倍的扩充策略。 多线程下的 std::unordered_mapSTL中的 哈希表 是线程不安全的（其实 STL 库都是线程不安全的）。 比如两个线程同时向 std::unordered_map 中插入数据，当发生rehash时，如果不加锁，可能导致两个线程都会产生rehash。 如何优化 多线程读写操作？这里要借鉴下java的分段锁。 参考链接 hash std::unordered_map底层原理 g++ 中 std::unordered_map 的实现 map 与 红黑树. 红黑树的规则 树根始终为黑色 外部节点均为黑色 其余节点若为红色，则器孩子节点必为黑色 从任一外部外部节点到根节点的沿途，黑色节点的数目相等 条件1和2说明，红色节点均是内部节点，其父节点及左、右孩子节点必然存在；另外条件3说明，红节点之父必为黑色，因此树中任一通路都不含相邻的红节点 红黑树的效率为什么比AVL树高?如果只有查询操作哪种树的效率高? 红黑树的效率高,是因为不需要像AVL树那样,为了维护高度平衡性,而不断地动态调整以维护左右子树高度差不超过1.红黑树降低了对平衡度的要求,以减少每次插入/删除操作时的动态调整次数.但是就查询效率而言,是不如AVL树的. 工具如何进行性能排查？找出性能瓶颈？性能测试？有什么工具： valgrind :可以查找代码问题GDB学习参考链接 GDB学习1 GDB学习2 GDB学习3 GDB学习4 GDB学习5 GDB学习6 GDB学习7","raw":"## 基础知识\n#### RAII  \n全称是 **R**esource **A**cquisition **I**s **I**nitialization ， 即“资源获取即初始化”，其核心是把资源和对象的生命周期绑定：对象创建获取资源，对象销毁释放资源。这就是的资源也有了生命周期，有了自动回收的功能。*lock_guard* 都利用了 *RAII*机制来实现。\n\n防止内存泄露的方式有 **R**AII、智能指针。\n\n#### 大端和小端\n\n+ 大端就是高字节在高地址，低字节在低地址。 \n\n+ 小端就是低字节在高地址，高字节在低地址。\n\n   ```cpp\n      // 大端小端区分  \n      bool isBigEndian() {  \n           union NUM  {  \n               int a;  \n               char b; // 如果是大端 b 就是最高位 ，小端就是最低位  \n           }num;  \n\n           num.a = 0x1234;  \n           if(num.b == 0x12)  \n           {  \n               return true;  \n           }  \n\n           return false;  \n       }\n   ```\n   \n+ 大端小端转换\n   ```cpp\n   //无符号整型16位  \n   uint16_t bswap_16(uint16_t x)  {  \n       return ((x & 0x00ff) << 8) | (x & 0xff00) >> 8) ;  \n   }  \n    \n   //无符号整型32位\n   uint32_t bswap_32(uint32_t x) {  \n       return ((x & 0xff000000) >> 24)| ((x & 0x00ff0000) >> 8) | \\\n              ((x & 0x0000ff00) << 8) | ((x & 0x000000ff) << 24) ;  \n   } \n   ```\n\n#### 生成可执行文件过程及各个过程完成的事情：  \n1. 预编译处理(.c) : 将源文件`main.cc` 翻译成一个ASCII码的中间件文件 `main.i`  \n2. 编译、优化程序（.s、.asm）： 将 `main.i`文件 翻译成一个 ASCII 汇编文件 `main.s`  \n3. 汇编程序(`.obj、.o、.a、.ko`)  ：运行汇编器，将 `main.s` 翻译成一个可重定位目标文件`main.o`   \n4. 链接程序（`.exe、.elf、.axf`等） ： 运行链接器，将`main.o` 中使用到的目标文件组合起来，创建一个可执行的文件     \n    为了构造可执行文件，这链接器必须完成两个主要任务：  \n    + 符号解析  ：目的是将每个符号引用正好和一个符号定义关联起来。每个符号对应于一个函数、全局变量、static变量等\n    + 重定位：对于由编译器和汇编器生成的从地址0开始的代码和数据节，链接器将每个符号定义与一个内存位置关联起来，从而重定位这些数据节，然后修改所有对这些符号的引用，使得他们**指向内存位置**。\n#### 静态库与动态库\n\n**根本区别**：是在编译期还是在是执行期完成链接、装入动作。链接的主要内容就是把各个模块之间相互引用的部分都处理好，\n使得各个模块之间能够正确地衔接\n\n + 静态库：之所以叫做静态库，是因为在**链接阶段**，当使用链接器将由汇编生成的目标文件构造成一个可执行的输出文件时，它只是**复制静态库中里这个即将生成的可执行文件所引用到的目标模块**。静态库特点总结：\n\n   +  静态库对函数库的链接是放在编译时期完成的。\n\n   + 程序在运行时与函数库再无瓜葛，移植方便。\n\n   + 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。\n\n + 动态库：动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。**不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例**，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，**增量更新**\n\n   \t+  动态库把对一些库函数的**链接载入**推迟到程序运行的时期。\n   + 可以实现进程之间的资源共享。（因此动态库也称为共享库）\n\n   + 将一些程序升级变得简单。\n\n   + 甚至可以真正做到链接载入完全由程序员在程序代码中控制（**显示调用**）。\n#### 编译型语言和解释型语言的区别\n  +  编译型语言在运行前就生成可执行文件，运行时就没有编译了\n  + 解释型语言在运行的时候才翻译\n####  static、extern、全局变量\n+ static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;\n\n+ static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；\n\n+ 程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。\n\n  extern全局变量(用extern修饰的变量只是说明该变量在其他地方定义，所以在其他地方一定要用明确的定义如int a，并且不能用static修饰）、static全局变量和static局部变量的生存期都是“永久”，区别只是可见域不同。extern全局变量可见区域是工程，static全局变量可见区域是文件，而static局部变量的可见区域是块。\n  \n#### volatile\n+ 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。\n\n+ 阻止编译器调整操作`volatile`变量的指令顺序。\n\n  注意：即使 `volatile` 能够阻止编译器调整顺序， 也无法阻止CPU动态调度换序（`reorder`）\n#### *assert*\n\n断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。**与正常的错误处理不同，断言通常在运行时被禁用**。\n\n*assert* 是个宏而非函数，如果条件返回错误，则会抛出异常，最后会调用 *abort* 终止程序，发送的是 *SIGABRT*，可以通过宏 ***NODEBUG*** 来关闭 *assert*，但是需要设置在源代码的开头。\n\n```cpp\n#define assert(expr)\t\t\t\t\t\t\t\t\\\n     (static_cast <bool> (expr)\t\t\t\t\t\t \\\n      ? void (0)\t\t\t\t\t\t\t\t\t\\\n      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))\n\nextern \nvoid __assert_fail (const char *__assertion, \n                    const char *__file,\n                    unsigned int __line, \n                    const char *__function)\n{\n     __THROW __attribute__ ((__noreturn__));\n}\n\n```\n\n在判断失败时会调用 *__assert_fail* 来抛出异常，在C++中异常的底层是用 *abort* 实现的。\n\n####  指针和引用的区别\n+ 目的不同：指针是为了兼容 C 而存在，引用是为了操作符重载而存在\n+ 在声明引用的的同时就要对它初始化，并且一经声明就不可以再和其它对象绑定在一起了。\n+ 引用更像是常量指针，只能改变绑定对象的值，不能改变绑定的对象。\n+ 引用它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，更加安全也增加了效率\n####  new、malloc\n+ new：不仅仅是分配内存，还包括了对象类型转换以及初始化\n  + 是先调用*operator new*分配内存空间，返回是*void* *类型；\n  + 再将返回类型转换为指定类型，再调用类的构造函数。\n  +  如果内存空间不足，会抛出*std::bad_alloc*异常\n  \n+ malloc\n  + 返回 `void*`类型，并且在内存不足时，返回`NULL`指针\n  + 当开辟的空间小于 `128K`时，调用`brk()` 函数，`malloc`的底层实现是系统调用函数 `brk()`\n  + 当开辟的空间大于 `128K `时，`mmap()` 系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟\n\n    `operator new` 底层也是由`malloc`实现。 `malloc`底层是由`slab`实现。\n\n    对于`POD`类型对象，使用`new` 创建的对象，也是可以使用`free`来释放销毁对象，原因就是在于这个对象是`POD` 类型。没有其他资源需要释放，或者文件描述符需要关闭，因此可以不调用析构函数而使用`free`来替代`delete`。尽管可以，但是不推荐，这样的代码并不健壮。\n\n    `new` 在C++里是可以用 `malloc + placement` 替代的，或者说等效于这两个。\n\n    ```cpp\n    // 更好的展示 malloc 与 new 的区别与联系\n    class Foo { \n    public:\n        Foo(int a=0, int b=0): a(a),b(b) { }\n\n        ~Foo() { std::cout<<\"dtor\"<<std::endl; }\n    private:\n        int a;\n        int b;\n    };\n\n    int main(int argc, char const *argv[])\n    {\n        // new = placement new + malloc\n        Foo* foo = static_cast<Foo*>(::malloc(sizeof(Foo)));\n        new(foo)Foo(1,1);\n        \n        // delete\n        foo->~Foo();\n        ::free(foo);\n        return 0;\n    }\n    // 运行结束，无内存泄露\n    ```\n\n+  除了`new`和`malloc`，还有什么方式可以在堆中分配内存么，以及怎么释放？  \n    **`mmap`，`munmap`**\n#### 多态  \n多态的三个条件：继承，重写（`override`），基类引用指向派生类对象。\n+ 静态多态   \n  \n    + 重载，在编译时期就可以确定\n    \n    + 模板技术：比如 `CRTP`，它是使用子类来作为基类的模板参数，在基类中调用子类的方法。\n    \n      ```cpp\n      template<typename Derived>\n      class Base{ \n            // 其他忽略\n          Derived& convert() \n          { \n          \treturn static_cast<Derived&>(*this);\n          }\n      };\n      ```\n      这个也从侧面说明`static_cast` 可以让子类转换为父类，要使得保证安全，前提是转换后调用子类的方法中没有使用子类独有的数据成员\n    \n+ 动态多态    \n  运行时才确定调用的是哪个函数。核心关键在于虚函数：子类重写基类的虚方法，定义指向子类对象的基类指针。这个基类指针的行为直到运行时才能确定调用的是子类还是基类的方法，这就是多态。\n\n  实现原理是：虚函数表和虚函数指针`vptr`。[详情](./3.虚拟成员函数.md)\n#### 重载(`overload`)和重写(`override`)\n\n+ 重载：允许多个同名函数，而这些函数的参数列表不同，函数模板这么实现的，在编译期间就能确定。\n\n  C++函数重载底层实现原理是C++利用 **`name mangling`** 技术，来改变函数名，区分参数不同的同名函数。编译器通过函数名和其参数类型识别重载函数。不能仅仅基于不同的返回类型而实现函数重载，是因为经过 `name mangling` 后得到的函数名与返回值类型是无关的。\n    ```cpp\n      void func(int a) { }\n\n      int func(int a, int b) { return a+b; }\n\n      int main(int argc, char const *argv[])\n      {\n        return 0;\n      }\n    ```\n    比如，如上的代码。在经过编译后，得到的符号表如下：\n    ```cpp\n      $ objdump -t main.o\n      0000000000000000 g     F .text  000000000000000e _Z4funci\n      000000000000000e g     F .text  0000000000000018 _Z4funcii\n      0000000000000026 g     F .text  0000000000000016 main\n    ```\n    其中， 前缀 `__z` 是规定，`4` 是函数名的字符个数，`i`是第一个函数的参数类型`int`，`ii`是第二个函数的参数类型`int, int`。由此可见也是与返回值无关的。\n\n+ 重写`override`：是指子类重新定义父类的方法，子类的函数名和参数列表以及返回值必须与父类的完全一致。对于虚函数的重写，c++11中新定义了一个关键词`override`，就是为了让子类在重写父类的虚函数方法时，如何参数列表发生更改可以让编译器报错。\n#### `static`\n`static`变量都是在全局数据区分配内存,声明周期直到程序运行结束.\n\n+ 四类`static`\n  + 全局`static`变量和`static`函数：都已经被匿名命名空间取代，作用是不能外部文件使用\n  + 局部`static`变量：在数据区`.data`分配内存，首次初始化以后，以后调用都不会再初始化，**作用域仅局限于函数**，生命周期直到程序运行结束\n  + 静态数据成员:类对象共享，不能在类声明中定义，是因为在定义时就要分配空间，也是在`.data` \n  + 静态成员函数:静态成员函数，**不隐含this指针**，不能调用非静态成员函数/变量，可以用作回调函数\n  \n+ 为什么要引入`static`  \n\n  需要一个数据对象为整个类而非某个对象服务，同时又不能破坏类的封装特性，因此将静态成员隐藏在类的内部,提供静态成员函数接口，因为共享,可以节省内存。\n####  对象\n+ 空类有六个成员函数\n  ```cpp\n    class Empty { \n    public:\n      Empty(); \n      Empty(const Empty& );\n      ~Empty();\n\n      Empty& operator=(consy Empty& );\n      Empty* operator& ();               // 取地址运算符\n      const Empty* operator& () const;   // const 类型取地址运算符\n    };\n  ```\n+ 构造函数可以是虚函数吗？析构函数可以是虚函数吗？\n  \n  虚函数对应一个`vtbl`，这个`vtbl`实际是存储在对象的内存空间.如果构造函数是虚的,对象的构造就需要`vtbl`来调用，而虚函数表又是在对象构造后才能建立,因此构造函数不能是虚函数.\n\n  而析构函数在使用多态的继承中一般都是虚析构函数.为的是能正确选择析构函数.\n\n+ `c++`的深拷贝如何理解 \n  \n  在类中有指针时并且内部分配资源.经过浅拷贝后,最终会造成资源一次分配,多次释放.造成系统崩溃.\n#### C++中如何在main()函数之前执行操作\nmain函数执行之前，主要就是初始化系统相关资源：\n+ 设置栈指针\n+ 初始化静态`static`变量和`global`全局变量，即`.data`段的内容\n+ 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容     \n+ 全局对象初始化，在`main`之前调用构造函数\n+ 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数\n\n**main函数执行之后**：  \n\n+ 全局对象的析构函数会在main函数之后执行； \n+ 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;\n#### sizeof  和 strlen 区别\n```cpp\n  int main(int argc, char const *argv[]){\n      \n      const char* str = \"name\";\n\n      sizeof(str); // 取的是指针str的长度，是8\n      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \\0。大小是4\n      return 0;\n  }\n```\n####  strcpy、strncpy和mmemcpy的区别\n  ```cpp\n  char* strcpy(char*  dest, const char* src);\n  char* strncpy(char* dest, const char* src, size_t n);\n  void* memcpy (void* dest, const void* src, size_t n);\n  ```\n  前面两个函数是以字符为单位，而`mmemcpy`是以字节为单位。\n\n  `strcpy`和`memcpy`主要有以下3方面的区别。  \n  + 复制的内容不同。`strcpy` 只能复制字符串，而`memcpy`可以复制任意内容，例如字符数组、整型、结构体、类等。\n  + 复制的方法不同。`strcpy` 不需要指定长度，它遇到被复制字符的串结束符`'\\0'`才结束，所以容易溢出。`memcpy` 则是根据其第3个参数决定复制的长度，而且如果字符串数据中包含`'\\0'`，只能用`memcpy`。\n  + 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy\n\n  `strncpy` ：在复制字符串时，`memcpy`更加类似于`strncpy`。  \n  `strncpy`和`memcpy`很相似，只不过它在一个终止的空字符处停止。当 `n > strlen(src)` 时，`dst[strlen(len)] ~ dst[n-1]`都是`\\0`；当 `n<=strlen(src)`时，复制前`src`的n个字符。这里隐藏了一个事实，就是`dst`指向的内存一定会被写n个字符。\n\n  `memcpy`需要注意的是：   \n  + `dest` 指针要分配足够的空间，也即大于等于 `n` 字节的空间。如果没有分配空间，会出现断错误。\n  + `dest` 和 `src` 所指的内存空间不能重叠（如果发生了重叠，使用 `memmove()` 会更加安全）。\n\n  动手实现 `memcpy`： \n  ```cpp\n  void* myMemcpy(void* dst, const void* src, size_t n) { \n    if(dst ==nullptr || src==nullptr) return nullptr;\n    if(src == dst) retrun src;\n      \n      char* pdst       = static_cast<char*>(dst); \n      const char* psrc = static_cast<const char*>(src);\n      // 发生重叠时，从后向前复制\n      if(psrc <  pdst && pdst < psrc + n) \n      { \n          for(int i=n-1; i >=0; --i)  pdst[i] = psrc[i];\n      }\n      else \n      { \n          for(int i=0; i < n; ++i) pdst[i] = psrc[i];\n      }\n      return pdst;\n  }\n\n  // 使用\n  int main(int argc, char const *argv[])\n  {\n      char buf[12]={0};\n      char str[]  = \"hello world cpp\";\n\n      myMemcpy(str, str+6, 9);\n      std::cout<<str<<std::endl;\n      return 0;\n  }\n  ```\n####  野指针和悬空指针   \n  都是是指向无效内存区域(这里的无效指的是\"不安全不可控\")的指针，访问行为将会导致未定义行为。\n  + 野指针   \n    野指针，指的是没有被初始化过的指针\n    \n    ```cpp\n    int main(void) { \n        \n        int* p;     // 未初始化\n        std::cout<< *p << std::endl; // 未初始化就被使用\n        \n        return 0;\n    }\n    ```\n    因此，为了防止出错，对于指针初始化时都是赋值为 `nullptr`，这样在使用时编译器就会直接报错，产生非法内存访问。\n    \n  + 悬空指针    \n    悬空指针，指针最初指向的内存已经被释放了的一种指针。\n    \n    ```cpp\n    int main(void) { \n      int * p = nullptr;\n    \n      int* p2 = new int;\n      \n      p = p2;\n    \n      delete p2;\n    }\n    ```\n此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为`p=p2=nullptr`。此时再使用，编译器会直接保错。\n    \n    避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。\n#### malloc、calloc、realloc\n```c\n    #include <stdlib.h>\n\n    void *malloc(size_t size);\n    void *calloc(size_t nmemb, size_t size);\n    void *realloc(void *ptr, size_t size);\n    void free(void *ptr);\n```\n+ `malloc`\n  最常用的分配内存函数，分配`size`个字节。**分配的内存是未初始化的**，如果`size==0`，要么返回`NULL`，要么返回一个独一无二的指针，能被`free`释放。\n+ `realloc`：用来改变已有内存区的大小，而不改变内容。新的大小为参数`size`，即newsize。\n  \n  + `ptr==NULL`：`realloc(NULL,size)`就相当于`malloc(size)`\n  + `size==0`：`realloc(ptr, 0)`就相当于`free(ptr)`\n  + `ptr==NULL && size==0`：危险。\n  + 如果`newsize > oldsize`，那么增加的内存是未初始化的，原来的内存内容保持不变，即`[ptr, ptr+oldsize)`内部不变，`[ptr+oldsize, ptr+newsize)`是初始化的内容。\n+ 如果`newsize < oldsize`，尾部的内容就被切去，释放，只是剩下前面。\n  \n  **因此 `realloc`之后不能给这个内存区初始化**.\n+ `calloc`\n  分配`nmemb`个元素，每个元素大小是`size`个字节的连续内存。\n  + 内存大小是`nmemb*size`的连续内存区\n  + **这块内存被初始化为`0`**。\n\n  如果`size==0`，要么返回`NULL`，要么返回一个独一无二的指针，能被`free`释放。\n#### 编译知识\n为了减小编译依赖加快编译速度和生成二进制文件的大小，C/C++ 项目中一般在 *.h 文件对于**指针类型（包括智能指针）** 尽量使用前置声明，而不是直接包含对应类的头文件。例如：\n```cpp\n  //Test.h\n  //在这里使用A的前置声明，而不是直接包含A.h文件\n  class A;\n\n  class Test\n  {\n  public:\n    Test();\n    ~Test();\n\n  private:\n    A*\n  };\n```\n#### Copy Elision\n\ng++ 编译器是默认开启 `copy elison` 选项的。如果要关闭这个选项，使用 `-fno-elide-constructors`。`copy elision` 主要包括以下两项内容：\n\n<font color=yellow>1. 返回值优化</font>  \n\n即通过将返回对象所占空间的直接构造到他们本来要复制/移动到的对象中去，依次来避免拷贝/移动操作。返回值优化包括具名返回值优化 `NRVO` 与 匿名返回值优化 `URVO`，区别在于返回值是具名的局部变量（`NRVO`）还是无名的临时对象（`URVO`）\n+ `URVO` 与 彻底 `Copy elision`\n  ```cpp\n    class Copyable { \n\n    public:\n      Copyable() { std::cout<<\"default ctor\"<<std::endl; }\n\n      Copyable(const Copyable& rhs) = delete; \n      Copyable(Copyable&& rhs) = delete;\n    };\n\n    Copyable return_urvo_value() { \n\n      return Copyable{}; // since c++17 ok\n    }\n\n    int main(int argc, char const *argv[]) {\n\n      auto x  = return_urvo_value();\n      \n      return 0;\n    }\n  ```\n  上述代码在C++17中是可以编译通过的。在 C++17 之前，并没有明确的提出在什么情况下，可以彻底进行 `Copy Elision`（这里的彻底的指的是包括不进行检查是否有可用的 *copy/move* 构造函数）。在C++17中，对于匿名对象（or 临时对象）不论是传递参数，还是以返回值返回时，都不会调用拷贝/移动构造。因此上面的这段代码在C++17是可以正常编过的，而在C++14会编译出错。\n  ```cpp  \n    $ g++ main.cc -std=c++14 -o main && ./main\n    main.cc: In function ‘Copyable return_urvo_value()’:\n    main.cc:29:19: error: use of deleted function ‘Copyable::Copyable(Copyable&&)’\n      29 |   return Copyable{};\n         |                   ^\n    main.cc:24:3: note: declared here\n      24 |   Copyable(Copyable&& rhs) = delete;\n         |   ^~~~~~~~\n    main.cc: In function ‘int main(int, const char**)’:\n    main.cc:34:31: error: use of deleted function ‘Copyable::Copyable(Copyable&&)’\n      34 |   auto x  = return_urvo_value();\n         |                               ^\n    main.cc:24:3: note: declared here\n      24 |   Copyable(Copyable&& rhs) = delete;\n         |   ^~~~~~~~\n  ```\n    自然，只要将上面代码中的如下两行注释掉，即可正常编译，并且 `Copyable`的构造函数都是只被调用一次，即`copy elision` 起作用了。 注意：`Copyable`的复制/移动构造函数必须同时可访问。\n    ```cpp\n      Copyable(const Copyable& rhs) = delete; \n      Copyable(Copyable&& rhs) = delete;\n    ```\n    因此，在C++17以前，对于 `urvo` 不在乎是否返回的对象的复制/移动构造函数是否存在或者可访问，`copy elision` 都能生效。而在 `C++14` 之前，返回的对象可以没有复制/移动构造函数，但是必须可以访问。\n\n+ `nrvo`    \n  在 `nrvo`时，返回对象的复制/移动构造函数必须可访问。否则编译不过。\n  ```cpp\n    class Copyable { \n    public:\n      Copyable() { std::cout<<\"default ctor\"<<std::endl; }\n\n      Copyable(const Copyable& rhs) = delete;\n      Copyable(Copyable&& rhs) = delete;\n    };\n\n    Copyable return_urvo_value() { \n\n      return Copyable{};\n    }\n\n    Copyable return_nrvo_value() { \n      Copyable local;\n\n      return local;\n    }\n\n    int main(int argc, char const *argv[]) {\n\n      auto x  = return_urvo_value();\n      auto y  = return_nrvo_value();\n      \n      return 0;\n    }\n  ```\n  如上代码，即使是C++17也会编译失败，必须将如下两行代码注释掉，使得 `Copyable` 对象的复制/移动构造函数可访问。`copy elision` 才能生效：`Copyable` 的默认构造函数只调用一次。\n  ```cpp\n    // Copyable(const Copyable& rhs) = delete;\n    // Copyable(Copyable&& rhs) = delete;\n  ```\n\n<font color=yellow> 2. 右值拷贝优化 </font>  \n\n右值拷贝优化，当某一个类的临时对象以值传递给该类的另一个对象时，也可以直接利用该临时对象的来避免拷贝/移动操作。在上面的基础上，加上如下的代码：\n```cpp  \n  void pass_by_value(Copyable rhs) { \n\n  }\n\n  int main(int argc, char const *argv[]) {\n\n    auto x  = return_urvo_value();\n    auto y  = return_nrvo_value();\n\n    pass_by_value(Copyable());\n    \n    return 0;\n  }\n```\n最终的输出也是调用默认三次构造函数：\n```bash\n  $ g++ main.cc -std=c++11 -o main && ./main\n  default ctor\n  default ctor\n  default ctor\n```\n\n到此，`copy elision` 基本分析结束。如果想查看没有`copy elision` 作用下的输出，开启`-fno-elide-constructors`。\n#### Copy Elision 作用  \n对于一些没有拷贝/移动构造的对象，如 `unique_ptr`、 `atomic` 等。现在我们能够定义一个工厂函数，即使没有复制或移动构造函数都可以返回一个对象。例如，以下通用工厂函数:\n```cpp\n  template <typename T, typename... Args>\n  T make_instance(Args&& ... args)\n  {\n    return T{ std::forward<Args>(args)... };\n  }\n  \n  int main()\n  {\n    int i   = make_instance<int>(42);\n    // std::unique_ptr 实现了 移动构造函数，因此可以编译成功 \n    auto up = make_instance<std::unique_ptr<int>>(new int{ 42 }); \n    // 禁止了复制构造函数，但是也没有实现移动构造函数，因此要到 C++17 才能编译过\n    auto ai = make_instance<std::atomic<int>>(42);                  \n  \n    return 0;\n  }\n```\n[参考](https://blog.csdn.net/davidhopper/article/details/90696200)\n\n## STL \n### *std::vector*\n  + *std::vector* 在 *push_back* 以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。\n  + 为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好\n  + *std::vector/std::list*的实现原理及其使用场景   \n    *std::vector*是用连续内存的数组实现的，*std::list*是通过指针之间的指向实现不连续内存的高效率使用.\n\n*std::vector* 与 *std::list*\n\n  + 数组，最大的好处是能以 *O(1)* 用索引访问任意元素，次要好处是内存布局紧凑，省内存之余还有高缓存一致性（*cache coherence*）。但数组的缺点是不能快速插入元素，而且我们在解析 *JSON* 数组的时候，还不知道应该分配多大的数组才合适。\n  + 链表，它的最大优点是可快速地插入元素（开端、末端或中间），但需要以 *O(n)* 时间去经索引取得内容。如果我们只需顺序遍历，那么是没有问题的。还有一个小缺点，就是相对数组而言，链表在存储每个元素时有额外内存开销（存储下一节点的指针），而且遍历时元素所在的内存可能不连续，令缓存不命中（*cache miss*）的机会上升。\n\n### *std::bind* \n\n对于如下代码，使用 *std::bind* 绑定类的成员函数并调用。\n\n```cpp\nclass Foo { \npublic:\n  Foo()=default;\n\n  void add(const int& lhs, const int& rhs) \n  { \n    std::cout<< (lhs + rhs)<<std::endl;;\n  }\n};\n\nint main(int argc, char const *argv[])\n{\n  Foo foo1;\n   // 绑定并且执行\n  std::bind(&Foo::add, &foo1, 1, 2)();\n  return 0;\n}\n```\n\n最后内部执行的代码如下：\n\n```cpp\ntemplate<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\nconstexpr _Res\n__invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t, _Args&&... __args)\n{\n  return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);\n}\n```\n\n其中 \n\n+ `_t` ，类型是 `Foo*&` 函数对象指针，指向的`foo1`对象。\n+ `_f`是函数指针，指向的就是`add`成员函数\n+ `__invoke_memfun_deref`：是用来标记是哪种把绑定方式，比如上述代码中的绑定对象成员函数\n\n因此，最终，调用可以简化为如下：\n\n```cpp\nfoo1.add(1,2);\n```\n\n整个`std::bind` 最终的执行代码如下：\n\n```cpp\n// 直接传入函数调用: std::bind(func, arg1, arg2); 或者静态成员函数\n// 很明显，这里没有类对象\ntemplate<typename _Res, typename _Fn, typename... _Args>\nconstexpr _Res\n__invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)\n{ return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }\n\n// 上面介绍过\ntemplate<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\nconstexpr _Res\n__invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t, _Args&&... __args)\n{\n  return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);\n}\n\n// 下面几种没见过调用\ntemplate<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\nconstexpr _Res\n__invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t, _Args&&... __args)\n{ return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }\n\ntemplate<typename _Res, typename _MemPtr, typename _Tp>\nconstexpr _Res\n__invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)\n{ return __invfwd<_Tp>(__t).*__f; }\n\ntemplate<typename _Res, typename _MemPtr, typename _Tp>\nconstexpr _Res\n__invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)\n{ return (*std::forward<_Tp>(__t)).*__f; }\n```\n\n*Lambda*\n\n*lambda*可以理解为是仿函数的语法糖。\n\n```cpp\nint main(int argc, char const *argv[])\n{\n  auto add  = [](int a, int b) { return a+b; };\n  int c = add(1,2);\n\n  return 0;\n}\n```\n\n对于上面的`lambda`函数，在gdb调试，经过编译的到的函数类型：\n\n```cpp\n(gdb) s\n<lambda(int, int)>::operator()(int, int) const (__closure=0x7fffffffe6d3, a=1, b=2) at main.cpp:24\n24        auto add  = [](int a, int b) { return a+b; };\n```\n\n`lambda`可以看作是匿名的函数对象，并且 `lambda`表达式默认是 `const`属性。\n\n```cpp\nclass Foo { \npublic:\n  Foo() \n  { \n    [](){std::cout<<\"123\"<<std::endl; }();\n  }\n};\n\nint main(int argc, char const *argv[])\n{ \n  Foo foo;\n\n  return 0;\n}\n```\n\n在类中调用`lambda`表达式，编译出来的类型如下：\n\n```cpp\nFoo::Foo()::{lambda()#1}::operator()() const\n```\n\n而实际上，lambda与operator本质上也是一样的，如下代码：\n```cpp\n\tclass Foo { \n    public:\n      Foo() \n      { \n        // 以下两个设计等价\n        [this](const char* str){this->print(str); }(\"lambda\");\n        Unmaed(this)(\"operator\");\n      }\n\n      void print(const char* str) { \n        std::cout<<str<<std::endl;\n      }\n\n    private:\n      struct Unmaed\n      {\n        Unmaed(Foo* foo): foo_(foo) { }\n\n        void operator()(const char* str) const\n        {\n          foo_->print(str);\n        }\n\n        Foo* foo_;\n      };\n    };\n```\n#### std::bind 与 lambad区别\n\n+ `lambda` 可以重载，但是 `std::bind` 无法区别重载\n  \n  ```cpp\n    void f(int) {}\n  void f(double) {}\n  \n    auto g = [] { f(1); }; // OK\n    auto g = std::bind(f, 1); // 错误\n    auto g = std::bind(static_cast<void(*)(int)>(f), 1); // OK\n  ```\n\n为此必须指定对应的函数指针类型。`lambda` 闭包类的 `operator()` 采用的是能被编译器内联的常规的函数调用。而`std::bind`采用的是一般不会被内联的函数指针调用，这意味着 **`lambda` 比 `std::bind` 运行得更快**。\n\n+ 传给 `std::bind` 的参数，绑定的是 `std::bind`，而不是`std::bind`内部管理的函数\n  ```cpp\n  void f(std::chrono::steady_clock::time_point t, int i)\n  {\n      std::this_thread::sleep_until(t);\n      std::cout << i;\n  }\n\n  auto g = [](int i)\n  {\n      f(std::chrono::steady_clock::now() + std::chrono::seconds(3), i);\n  };\n\n  g(1); // 3秒后打印1\n  // 用std::bind实现相同效果，但存在问题\n  auto h = std::bind(f,\n                      std::chrono::steady_clock::now() + \t std::chrono::seconds(3),\n                      std::placeholders::_1);\n\n  h(1); // 3秒后打印1，但3秒指的是调用std::bind后的3秒，而非调用f后的3秒\n  ```\n\n计算时间的表达式作为实参被传递给`std::bind`，因此计算发生在调用`std::bind`的时刻，而非调用其绑定的函数的时刻。\n\n在 `c++14` 中，完全没有理由使用 `std::bind`，`c++11`由于特性受限，存在两个使用场景：\n  + 模拟`c++11`缺少的移动捕获\n  + 函数对象 `operator()` 是模板时，如果将此函数作为参数使用，用 `std::bind` 绑定才能接受任意类型参数\n  ```cpp\n  struct X {\n      template<typename T>\n      void operator()(const T&) const;\n  };\n  \nX x;\n  auto f = std::bind(x, _1); // f可以接受任意参数类型\n  \n// c++14 做法\n  X a;\n  auto f = [a](const auto& x) { a(x); };\n  ```\n#### *Lambda* 与 *std::bind* 区别补充\n`std::bind` 传入的参数默认情况下是 “值传递”，想要使用引用传递需要`std::ref`。详细可以参考下面的代码：\n\n```cpp\n  class Foo { \n  public:\n    Foo() \n    { \n      std::cout<<\"default\"<<std::endl; \n    }\n\n    Foo(const Foo& rhs)     \n    { \n      std::cout<<\"ctor\"<<std::endl;\n    }\n  };\n\n  void add(const Foo& lhs, const Foo& rhs) { \n\n  }\n\n\n  int main(int argc, char const *argv[])\n  {\n    std::cout<<std::boolalpha;\n\n    Foo foo1;\n    Foo foo2;\n  \n    std::cout<<\"bind: pass by value\"<<std::endl;\n    auto func = std::bind(add,  foo1, foo2);\n    \n    std::cout<<\"bind: pass by ref\"<<std::endl;\n    auto func = std::bind(add,  std::ref(foo1), std::ref(foo2));\n\n    std::cout<<\"lambda \"<<std::endl;\n    [&foo1, &foo2]{ add(foo1, foo2);}();\n\n    return 0;\n  }\n```\n上面的代码输出：\n```bash\n  $ g++ -g  -O0 main.cc -o main && ./main\n  default\n  default\n  bind: pass by value\n  ctor\n  ctor\n  bind: pass by ref\n  lambda \n```\n可以看到`std::bind`在默认情况下，是依靠值传递，使用了`std::ref`来包裹传入参数才是使用引用传递。用 `gdb` 调试，可以跟踪到发生构造 `Foo` 对象的位置：\n```cpp\ntemplate<typename _UHead>\nconstexpr _Head_base(_UHead&& __h) : _Head(std::forward<_UHead>(__h)) { }\n\n// 整个调用链如下：\n#0  Foo::Foo (this=0x7fffffffe068, rhs=...) at main.cc:13\n#1  0x0000555555555a8c in std::_Head_base<1ul, Foo, true>::_Head_base<Foo&> (this=0x7fffffffe068, __h=...) at /usr/include/c++/9/tuple:87\n#2  0x00005555555559e8 in std::_Tuple_impl<1ul, Foo>::_Tuple_impl<Foo&> (this=0x7fffffffe068, __head=...) at /usr/include/c++/9/tuple:349\n#3  0x00005555555558f3 in std::_Tuple_impl<0ul, Foo, Foo>::_Tuple_impl<Foo&, Foo&, void> (this=0x7fffffffe068, __head=...)\n    at /usr/include/c++/9/tuple:218\n#4  0x0000555555555815 in std::tuple<Foo, Foo>::tuple<Foo&, Foo&, true> (this=0x7fffffffe068, __a1=..., __a2=...) at /usr/include/c++/9/tuple:969\n#5  0x00005555555556fc in std::_Bind<void (*(Foo, Foo))(Foo const&, Foo const&)>::_Bind<Foo&, Foo&>(void (*&&)(Foo const&, Foo const&), Foo&, Foo&)\n    (this=0x7fffffffe060, __f=@0x7fffffffe010: 0x5555555551ea <add(Foo const&, Foo const&)>) at /usr/include/c++/9/functional:467\n#6  0x0000555555555571 in std::bind<void (&)(Foo const&, Foo const&), Foo&, Foo&> (__f=\n    @0x5555555551ea: {void (const Foo &, const Foo &)} 0x5555555551ea <add(Foo const&, Foo const&)>) at /usr/include/c++/9/functional:812\n#7  0x00005555555552b7 in main (argc=1, argv=0x7fffffffe198) at main.cc:30\n```\n\n### 左值引用和右值引用区别  \n 左值引用，也就是“常规引用”，不能绑定到要转换的表达式，字面常量，或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。\n\n 右值引用就是必须绑定到右值的引用，通过&&获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。\n\n 返回左值的表达式包括返回左值引用的函数及赋值，下标，解引用和**前置递增/递减运算符**；\n 返回右值的包括返回非引用类型的函数及算术，关系，位和后置递增/递减运算符。可以看到左值的特点是有持久的状态，而右值则是短暂的\n ```cpp\n  void func(int&& index, int idx) { \n    if(idx > 3) return;\n\n    func(index++, ++idx);  // Ok \n    func(++index, ++idx);  // Error\n\n    std::cout<< std::is_rvalue_reference<decltype(index)>::value <<std::endl;\n  }\n ```\n 在上面的代码中，`++index` 产生的是左值，而 `index++` 产生的是右值。因此上面的可以编译成功，下面的编译不过。\n\n【注意】：已经命名的右值，编译器会认为是左值。\n### 左值与右值\n变量都是左值，即使变量是右值引用类型\n```cpp\n  int&& ref1 = 1;     //  ok \n  int&& ref2 = ref1; // error \n```\n因为 `ref2` 是右值引用类型的变量，不能将其绑定到左值`ref1`上。**`ref1` 与 `ref2` 是左值，因为他们都是变量，但是变量类型是右值引用类型，即这两个变量只能绑定到右值上**。\n### 四种类型转换总结\n#### *static_cast*\n\n+ 基类和子类之间转换：  \n    `static_cast` 的使用，当且仅当类型之间可隐式转化时，`static_cast` 的转化才是合法的。有一个例外，那就是类层次间的向下转型，`static_cast` 可以完成类层次间的向下转型，但是向下转型无法通过隐式转换完成。\n    \n    + 向上转换安全：子类指针转换成父类指针是安全的;\n    \n    + 向下转换不安全：父类指针转换成子类指针是不安全的。\n    \n    + `static_cast`不能进行无关类型(如非基类和子类)指针之间的转换。\n      \n      ```cpp\n    class Base{ };\n    class Derived : public base{ /**....*/ };\n      \n        Base*    B = new Base;\n        Derived* D = static_cast<Drived*>(B); // 不安全\n      ```\n      为什么不安全？   \n      \n      D指向本质上还是B的对象模型，D指向的内存模型中可能存在B没有的成员变量。如果 `D->foo()` 中使用了 `D` 的成员变量，那么这个函数调用就是不安全的。因此，向下转换是安全的。\n    \n+ `static_cast` 还可以在左值和右值之间显示地转换。虽然不能隐式地将左值转换为右值，但是可以使用`static_cast`显示地将左值转换为右值。\n+ 基本数据类型转换: `enum`, `int`, `char`, `float`等。安全性问题由开发者来保证。\n+ 把空指针转换成目标类型的空指针  \n    ```cpp\n        int* iptr = static_cast<int*>(::malloc(sizoef(int)));\n    ```\n+ 把任何类型的表达式转换成void类型：`static_cast<void>(iptr)`\n+ `static_cast` 不能去掉类型的`const、volitale`属性(用`const_cast`)\n+ 隐式转换都建议使用 `static_cast` 进行标明和替换\n\n#### *dynamic_cast*\n\n专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 nullptr 指针。  \n\n使用特点：　　\n+ 基类必须要有虚函数，因为`dynamic_cast`是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数，才会有虚函数表　　\n\n+ 对于下行转换，`dynamic_cast`是安全的（当类型不一致时，转换过来的是空指针），而`static_cast`是不安全的（当类型不一致时，转换过来的是错误意义的指针，可能造成踩内存，非法访问等各种问题), `reinterpreter_cast` 下行转换是可以转换，但是不安全。　\n\n+ 相同基类不同子类之间的交叉转换，转换结果是是 nullptr\n  ```cpp\n    class Base\n    {\n    public: \n      virtual void fun() { } \n    };\n\n    class Drived : public base {\n    public:\n      int i;\n    };\n\n    Base     *Bptr = new Drived()；//语句0\n    Derived *Dptr1 = static_cast<Derived*>(Bptr);  //语句1；\n    Derived *Dptr2 = dynamic_cast<Derived*>(Bptr); //语句2；\n  ```\n此时语句1和语句2都是安全的，因为此时 `Bptr` 确实是指向的派生类的内存模型，所以两个类型转换都是安全的。`Dptr1` 和 `Dptr2` 可以尽情访问 `Drived` 类中的成员，绝对不会出问题。但是如果此时语句0更改为如下表达：\n  ```cpp\n    Base* Bptr = new Base(); `\n  ```\n  那么 `Bptr` 指向的是`Base`对象内存模型。因此语句1是不安全的，因为如果访问子类的数据成员，其行为将是未定义。而语句2返回的是 `nullptr`，更加直观的告诉用户不安全。\n\n#### *reinterpreter_cast*\n\n用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时执行的是**逐 `byte` 复制**的操作。\n\n+ `reinterpret_cast`是从底层对数据仅仅进行重新解释，但没有进行二进制的转换，依赖具体的平台，可移植性差；　　\n+ `reinterpret_cast`可以将整型转换为指针，也可以把指针转换为数组；　　\n+ `reinterpret_cast`可以在指针和引用里进行肆无忌惮的转换；\n\n#### *const_cast*  \n\n+ 常量指针转换为非常量指针， 并且仍然指向原来的对象　　\n+ 常量引用被转换为非常量引用，并且仍然指向原来的对象\n\n### 自己实现一个非侵入式的智能指针\n```cpp\n// RAII 技术封装  \nclass RefCount {\npublic:\n      RefCount() : reference_{0} \n      { }\n\n      ~RefCount() { \n          this->decrementRef();\n      }\n\n      void IncrementRef()\n      {\n          ++reference_;\n      }\n\n      bool decrementRef()\n      {\n          if (--reference_ == 0) {\n            delete this;\n            return true;\n          }\n          return false;\n      }\n      \n      int64_t use_count() {\n          return reference_;\n      }\n\n  private:\n      std::atomic<int64_t> reference_;\n  };\n\n\n  template <typename T>\n  class SharedPtr\n  {\n  public:\n      SharedPtr() : ptr_(nullptr) {}\n\n      explicit SharedPtr(T* ptr) \n      : ptr_(ptr),\n        ref_(new RefCount)\n      {\n          if (ref_) ref_->IncrementRef();\n      }\n\n      SharedPtr(const SharedPtr& other) \n      : ptr_(other.ptr_),\n        ref_(other.ref_)\n      {\n          if (ref_) ref_->IncrementRef();\n      }\n\n      SharedPtr(SharedPtr&& other) noexcept {\n          ptr_ = other.ptr_;\n          ref_ = other.ref_;\n          other.ptr_ = nullptr;\n          other.ref_ = nullptr;\n      }\n\n      SharedPtr& operator=(const SharedPtr& other) {\n          if (this == &other || *this == other) \n              return *this;\n\n          reset();\n          ptr_ = other.ptr_;\n          ref_ = other.ref_;\n          ref_->IncrementRef();\n          return *this;\n      }\n\n      SharedPtr& operator=(SharedPtr&& other) noexcept {\n          if (this == &other || *this == other) return *this;\n\n          reset();\n          ptr_ = other.ptr_;\n          ref_ = other.ref_;\n          \n          other.ptr_ = nullptr;\n          other.ref_ = nullptr;\n\n          return *this;\n      }\n\n      ~SharedPtr() \n      {\n          if (ref_) this->decrementRef(); \n      }\n\n      T& operator*()  const { return *ptr_; }\n      T* operator->() const { return ptr_; }\n\n      explicit operator bool() const { return !!ptr_; }\n\n      T* get() const { return ptr_; }\n\n      void reset() {\n          if (ptr_) {\n              this->decrementRef();\n              // ptr_ = nullptr;\n          }\n      }\n\n      void decrementRef() { \n          if(ref_ && ptr_) { \n              if(ref_->decrementRef()) { \n                  delete ptr_;\n                  ptr_ = nullptr;\n              }\n          }\n      }\n\n      int64_t use_count() {\n          return  ref_->use_count();\n      }\n\n      bool unique() {\n          return use_count() == 1;\n      }\n\n      void swap(SharedPtr & other) {\n          std::swap(ptr_, other.ptr_);\n          std::swap(ref_, other.ref_);\n      }\n\n      friend inline bool operator==(SharedPtr const& lhs, SharedPtr const& rhs) {\n          return lhs.ptr_ == rhs.ptr_;\n      }\n\n      friend inline bool operator!=(SharedPtr const& lhs, SharedPtr const& rhs) {\n          return lhs.ptr_ != rhs.ptr_;\n      }\n\n      friend inline bool operator<(SharedPtr const& lhs, SharedPtr const& rhs) {\n          return lhs.ptr_ < rhs.ptr_;\n      }\n\n  private:\n      T*        ptr_; \n      RefCount* ref_;\n  };\n\n  int main(int argc, char const *argv[]) {\n    \n      SharedPtr<int> iptr (new int);\n      SharedPtr<int> iptr2(iptr);\n      SharedPtr<int> iptr3(std::move(iptr));\n      SharedPtr<int> iptr4 = iptr2;\n      SharedPtr<int> iptr5 = std::move(iptr3);\n\n      std::cout<<iptr5.use_count()<<std::endl; // 3\n      return 0;\n  }\n```\n### 迭代器失效的场景\n+ 序列式容器\n    序列式容器会失效的原因是因为其存储都是连续的，因此删除或者插入一个元素都有可能导致其他元素的迭代器失效。\n  \n  + `vector`\n    \n      + 在遍历时，执行`erase`会导致删除节点之后的全部失效\n      + 在`push_back`时，之前的`end()`操作得到的迭代器失效\n    + `insert/push_back`导致`capacity()`改变，那么之前的`first()/end()`得到的迭代器会失效\n  + `insert`一个元素，如果空间没有分配，那么插入节点之前的迭代器位置有效，之后的失效。\n    \n      简而言之：导致内存分配的全会失效，导致元素移动的会局部失效\n  + `deque`\n    + 在首尾添加元素，会导致迭代器失效，但是指针、引用不会失效\n    + 其余位置插入元素，迭代器、指针、引用都是失效\n    + 在首尾之外的位置删除元素，那么其他位置的迭代器都失效\n    + 在首尾删除元素，只是会导致被指向的删除元素的迭代器失效\n+ 关联式容器\n  + 基于哈希表实现的*std::unordered_map/std::set* 导致迭代器失效，一般是插入元素导致 *reshash* 产生，如果是删除只是会导致被删除元素的迭代器失效。\n    ![case](image/unorder_map非法化.jpg)\n###  *std::unordered_map*\n#### 底层实现及其解决 *hash* 冲突方法 \n\n*std::unorder_map*  解决冲突方式是 **拉链法**（数组的每个元素都连着一个链表？）：将所有产生冲突的关键字所对应的数据全部存储在同一个线性链表中（*bucket*）。这个方法解决数据存储位置发生冲突的哈希表，整个存储结构如图 1 所示。\n\n<div align=center><img src=./image/hashtable.gif> </div>\n\n  其中 p_i表示存储的各个键值对。\n\n当使用无序容器存储键值对时，会先申请一整块连续的存储空间，但此空间并不用来直接存储键值对，而是存储各个链表的头指针，各键值对真正的存储位置是各个链表的节点。`STL` 标准库默认选用`vector`容器存储各个链表的头指针。`STL` 标准库中，将图 1 中的各个链表称为桶 *bucket*，每个桶都有自己的编号（从 0 开始）。当有新键值对存储到无序容器中时，整个存储过程分为如下几步：\n  + 将该键值对中 `key` 的值带入设计好的哈希函数，会得到一个哈希值: *H = hash(key)*；\n  + 将 H 和无序容器拥有桶的数量 n 做整除运算（即` H % n`），该结果即表示应将此键值对存储到的桶的编号；\n  + 建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上\n\n **其他解决冲突的方法**\n  + 开放地址法：\n    $$\n    H =(hash(key) + d)  \\%  m\n    $$\n    \n    \n     其中`m`是哈希表的表长，`d`是一个增量，当产生冲突时，选择以下三种方法一种获取d的值，然后计算，直到计算出的*hash* 值不存在冲突。\n    \n    +  线性探测法：d = 1,2,3,...\n    +  二次探测法：d = 12,-12, 22, -22...\n    +  伪随机数探测法: d = 伪随机数\n    \n  + 再哈希法`rehasp`  \n    当通过哈希函数求得的哈希地址同其他关键字产生冲突时，使用另一个哈希函数计算，直到冲突不再发生\n\n#### rehashp\n\n上述的拉链法解决了哈希冲突的问题，但是当插入元素很多，产生了严重哈希冲突时，就会导致某个链表长度越来越长，进而导致哈希表的查找就会退化为链表，效率降低为O(n)的时间复杂度。\n\n 哈希表存储结构还有一个重要的属性，称为负载因子`load factor`，用于衡量容器存储键值对的空/满程度：即负载因子越大，意味着容器越满，即各链表中挂载着越多的键值对，这无疑会降低容器查找目标键值对的效率；反之，负载因子越小，容器肯定越空，但并不一定各个链表中挂载的键值对就越少。\n\n>  负载因子的计算方法为：负载因子 = 容器存储的总键值对 / 桶数\n\n` STL` 中默认情况下，无序容器的最大负载因子为 1.0。如果操作无序容器过程中，使得最大复杂因子超过了默认值，则容器会自动增加桶数，并重新进行哈希，以此来减小负载因子的值。需要注意的是，此过程会导致容器迭代器失效，但指向单个键值对的引用或者指针仍然有效。\n\n因此当插入元素过多，使得负载因子的大于1.0，就会产生*rehash*行为，来改善即将下降的效率。\n\n **STL中的 *unordered_map* 的 *rehash* 策略**\n一下代码节选自g++的*STL*库：\n\n```cpp\n// __n_bkt is current bucket count, __n_elt is current element count,\n// and __n_ins is number of elements to be inserted.  Do we need to\n// increase bucket count?  If so, return make_pair(true, n), where n\n// is the new bucket count.  If not, return make_pair(false, 0).\nstd::pair<bool, size_t>\n _M_need_rehash(size_t __n_bkt, size_t __n_elt, size_t __n_ins) noexcept {\n  if (__n_elt + __n_ins >= _M_next_resize) {\n      \n    long double __min_bkts = (__n_elt + __n_ins) / (long double)_M_max_load_factor;\n      \n    if (__min_bkts >= __n_bkt)\n      //  这个是需要rehash 时返回的策略\n      return std::make_pair(true, \n                            _M_next_bkt(std::max<size_t>(__builtin_floor(__min_bkts) + 1,\n                                                         __n_bkt * _S_growth_factor)));\n\n        _M_next_resize  = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);\n\n        return std::make_pair(false, 0);\n      }\n     \n      return std::make_pair(false, 0);\n    }\n\nsize_t _M_next_bkt(size_t __n) noexcept {\n    \n  const auto __max_width = std::min<size_t>(sizeof(size_t), 8);           // 8 个字节\n  const auto __max_bkt   = size_t(1) << (__max_width * __CHAR_BIT__ - 1); // 2 ^ 63\n  size_t __res           = __clp2(__n);        // 计算大于等于 n 的最小的2的幂\n\n  if (__res == __n) __res <<= 1;\n  if (__res == 0) __res = __max_bkt;\n\n  // Set next resize to the max value so that we never try to rehash again\n  // as we already reach the biggest possible bucket number.\n  // Note that it might result in max_load_factor not being respected.\n  if (__res == __max_bkt)\n    _M_next_resize = size_t(-1);\n  else\n    _M_next_resize = __builtin_ceil(__res * (long double)_M_max_load_factor);\n\n  return __res;\n}\n```\n其中，在这个类的前面有定义：\n>  + ***_M_max_load_factor*** 初始化为 1.0\n>  + ***static const size_t _S_growth_factor = 2;***\n\n整个扩容的策略大致是按照2倍的策略增长，但是并不严格按照。在MSVC中按照的是8倍的扩充策略。\n\n#### 多线程下的 *std::unordered_map* \n`STL`中的 哈希表 是线程不安全的（其实 `STL` 库都是线程不安全的）。 比如两个线程同时向 *std::unordered_map* 中插入数据，当发生*rehash*时，如果不加锁，可能导致两个线程都会产生*rehash*。\n\n**如何优化 多线程读写操作？这里要借鉴下java的分段锁。**\n\n#### 参考链接\n\n  + [hash](http://c.biancheng.net/view/3437.html)\n  + [std::unordered_map底层原理](http://c.biancheng.net/view/7235.html)\n  + g++ 中 *std::unordered_map* 的实现\n\n###  *map* 与 红黑树.\n\n+ 红黑树的规则\n\n  1. 树根始终为黑色\n  2. 外部节点均为黑色\n  3. 其余节点若为红色，则器孩子节点必为黑色\n  4. 从任一外部外部节点到根节点的沿途，黑色节点的数目相等\n\n  条件1和2说明，红色节点均是内部节点，其父节点及左、右孩子节点必然存在；另外条件3说明，红节点之父必为黑色，因此树中任一通路都不含相邻的红节点\n\n+ 红黑树的效率为什么比AVL树高?如果只有查询操作哪种树的效率高?\n  \n  红黑树的效率高,是因为不需要像`AVL`树那样,为了维护高度平衡性,而不断地动态调整以维护左右子树高度差不超过1.红黑树降低了对平衡度的要求,以减少每次插入/删除操作时的动态调整次数.但是就查询效率而言,是不如`AVL`树的.\n\n## 工具\n####  如何进行性能排查？找出性能瓶颈？性能测试？有什么工具：\n+ *valgrind* :可以查找代码问题\n####  GDB学习参考链接\n+ [GDB学习1](https://blog.csdn.net/haoel/article/details/2879)\n+ [GDB学习2](https://blog.csdn.net/haoel/article/details/2880)\n+ [GDB学习3](https://blog.csdn.net/haoel/article/details/2881)\n+ [GDB学习4](https://blog.csdn.net/haoel/article/details/2882)\n+ [GDB学习5](https://blog.csdn.net/haoel/article/details/2883)\n+ [GDB学习6](https://blog.csdn.net/haoel/article/details/2884)\n+ [GDB学习7](https://blog.csdn.net/haoel/article/details/2885)\n","content":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h4 id=\"RAII\"><a href=\"#RAII\" class=\"headerlink\" title=\"RAII\"></a>RAII</h4><p>全称是 <strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization ， 即“资源获取即初始化”，其核心是把资源和对象的生命周期绑定：对象创建获取资源，对象销毁释放资源。这就是的资源也有了生命周期，有了自动回收的功能。<em>lock_guard</em> 都利用了 <em>RAII</em>机制来实现。</p>\n<p>防止内存泄露的方式有 <strong>R</strong>AII、智能指针。</p>\n<h4 id=\"大端和小端\"><a href=\"#大端和小端\" class=\"headerlink\" title=\"大端和小端\"></a>大端和小端</h4><ul>\n<li><p>大端就是高字节在高地址，低字节在低地址。 </p>\n</li>\n<li><p>小端就是低字节在高地址，高字节在低地址。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 大端小端区分  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBigEndian</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">     <span class=\"keyword\">union</span> NUM  &#123;  </span><br><span class=\"line\">         <span class=\"keyword\">int</span> a;  </span><br><span class=\"line\">         <span class=\"keyword\">char</span> b; <span class=\"comment\">// 如果是大端 b 就是最高位 ，小端就是最低位  </span></span><br><span class=\"line\">     &#125;num;  </span><br><span class=\"line\"></span><br><span class=\"line\">     num.a = <span class=\"number\">0x1234</span>;  </span><br><span class=\"line\">     <span class=\"keyword\">if</span>(num.b == <span class=\"number\">0x12</span>)  </span><br><span class=\"line\">     &#123;  </span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">     &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>大端小端转换 <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//无符号整型16位  </span></span><br><span class=\"line\"><span class=\"keyword\">uint16_t</span> bswap_16(<span class=\"keyword\">uint16_t</span> x)  &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((x &amp; <span class=\"number\">0x00ff</span>) &lt;&lt; <span class=\"number\">8</span>) | (x &amp; <span class=\"number\">0xff00</span>) &gt;&gt; <span class=\"number\">8</span>) ;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//无符号整型32位</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> bswap_32(<span class=\"keyword\">uint32_t</span> x) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((x &amp; <span class=\"number\">0xff000000</span>) &gt;&gt; <span class=\"number\">24</span>)| ((x &amp; <span class=\"number\">0x00ff0000</span>) &gt;&gt; <span class=\"number\">8</span>) | \\</span><br><span class=\"line\">           ((x &amp; <span class=\"number\">0x0000ff00</span>) &lt;&lt; <span class=\"number\">8</span>) | ((x &amp; <span class=\"number\">0x000000ff</span>) &lt;&lt; <span class=\"number\">24</span>) ;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"生成可执行文件过程及各个过程完成的事情：\"><a href=\"#生成可执行文件过程及各个过程完成的事情：\" class=\"headerlink\" title=\"生成可执行文件过程及各个过程完成的事情：\"></a>生成可执行文件过程及各个过程完成的事情：</h4><ol>\n<li>预编译处理(.c) : 将源文件<code>main.cc</code> 翻译成一个ASCII码的中间件文件 <code>main.i</code>  </li>\n<li>编译、优化程序（.s、.asm）： 将 <code>main.i</code>文件 翻译成一个 ASCII 汇编文件 <code>main.s</code>  </li>\n<li>汇编程序(<code>.obj、.o、.a、.ko</code>)  ：运行汇编器，将 <code>main.s</code> 翻译成一个可重定位目标文件<code>main.o</code>   </li>\n<li>链接程序（<code>.exe、.elf、.axf</code>等） ： 运行链接器，将<code>main.o</code> 中使用到的目标文件组合起来，创建一个可执行的文件<br> 为了构造可执行文件，这链接器必须完成两个主要任务：  <ul>\n<li>符号解析  ：目的是将每个符号引用正好和一个符号定义关联起来。每个符号对应于一个函数、全局变量、static变量等</li>\n<li>重定位：对于由编译器和汇编器生成的从地址0开始的代码和数据节，链接器将每个符号定义与一个内存位置关联起来，从而重定位这些数据节，然后修改所有对这些符号的引用，使得他们<strong>指向内存位置</strong>。<h4 id=\"静态库与动态库\"><a href=\"#静态库与动态库\" class=\"headerlink\" title=\"静态库与动态库\"></a>静态库与动态库</h4></li>\n</ul>\n</li>\n</ol>\n<p><strong>根本区别</strong>：是在编译期还是在是执行期完成链接、装入动作。链接的主要内容就是把各个模块之间相互引用的部分都处理好，<br>使得各个模块之间能够正确地衔接</p>\n<ul>\n<li><p>静态库：之所以叫做静态库，是因为在<strong>链接阶段</strong>，当使用链接器将由汇编生成的目标文件构造成一个可执行的输出文件时，它只是<strong>复制静态库中里这个即将生成的可执行文件所引用到的目标模块</strong>。静态库特点总结：</p>\n<ul>\n<li><p>静态库对函数库的链接是放在编译时期完成的。</p>\n</li>\n<li><p>程序在运行时与函数库再无瓜葛，移植方便。</p>\n</li>\n<li><p>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</p>\n</li>\n</ul>\n</li>\n<li><p>动态库：动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。<strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，<strong>增量更新</strong></p>\n<pre><code>+  动态库把对一些库函数的**链接载入**推迟到程序运行的时期。\n</code></pre><ul>\n<li><p>可以实现进程之间的资源共享。（因此动态库也称为共享库）</p>\n</li>\n<li><p>将一些程序升级变得简单。</p>\n</li>\n<li><p>甚至可以真正做到链接载入完全由程序员在程序代码中控制（<strong>显示调用</strong>）。</p>\n<h4 id=\"编译型语言和解释型语言的区别\"><a href=\"#编译型语言和解释型语言的区别\" class=\"headerlink\" title=\"编译型语言和解释型语言的区别\"></a>编译型语言和解释型语言的区别</h4></li>\n<li>编译型语言在运行前就生成可执行文件，运行时就没有编译了</li>\n<li>解释型语言在运行的时候才翻译<h4 id=\"static、extern、全局变量\"><a href=\"#static、extern、全局变量\" class=\"headerlink\" title=\"static、extern、全局变量\"></a>static、extern、全局变量</h4></li>\n<li>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；</p>\n</li>\n<li><p>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。</p>\n<p>extern全局变量(用extern修饰的变量只是说明该变量在其他地方定义，所以在其他地方一定要用明确的定义如int a，并且不能用static修饰）、static全局变量和static局部变量的生存期都是“永久”，区别只是可见域不同。extern全局变量可见区域是工程，static全局变量可见区域是文件，而static局部变量的可见区域是块。</p>\n</li>\n</ul>\n<h4 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h4><ul>\n<li><p>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。</p>\n</li>\n<li><p>阻止编译器调整操作<code>volatile</code>变量的指令顺序。</p>\n<p>注意：即使 <code>volatile</code> 能够阻止编译器调整顺序， 也无法阻止CPU动态调度换序（<code>reorder</code>）</p>\n<h4 id=\"assert\"><a href=\"#assert\" class=\"headerlink\" title=\"assert\"></a><em>assert</em></h4></li>\n</ul>\n<p>断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。<strong>与正常的错误处理不同，断言通常在运行时被禁用</strong>。</p>\n<p><em>assert</em> 是个宏而非函数，如果条件返回错误，则会抛出异常，最后会调用 <em>abort</em> 终止程序，发送的是 <em>SIGABRT</em>，可以通过宏 <strong><em>NODEBUG</em></strong> 来关闭 <em>assert</em>，但是需要设置在源代码的开头。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> assert(expr)\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\">     (<span class=\"keyword\">static_cast</span> &lt;<span class=\"keyword\">bool</span>&gt; (expr)\t\t\t\t\t\t \\</span><br><span class=\"line\">      ? <span class=\"keyword\">void</span> (<span class=\"number\">0</span>)\t\t\t\t\t\t\t\t\t\\</span><br><span class=\"line\">      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> </span><br><span class=\"line\"><span class=\"keyword\">void</span> __assert_fail (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *__assertion, </span><br><span class=\"line\">                    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *__file,</span><br><span class=\"line\">                    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> __line, </span><br><span class=\"line\">                    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *__function)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     __THROW __attribute__ ((__noreturn__));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在判断失败时会调用 <em>__assert_fail</em> 来抛出异常，在C++中异常的底层是用 <em>abort</em> 实现的。</p>\n<h4 id=\"指针和引用的区别\"><a href=\"#指针和引用的区别\" class=\"headerlink\" title=\"指针和引用的区别\"></a>指针和引用的区别</h4><ul>\n<li>目的不同：指针是为了兼容 C 而存在，引用是为了操作符重载而存在</li>\n<li>在声明引用的的同时就要对它初始化，并且一经声明就不可以再和其它对象绑定在一起了。</li>\n<li>引用更像是常量指针，只能改变绑定对象的值，不能改变绑定的对象。</li>\n<li>引用它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，更加安全也增加了效率<h4 id=\"new、malloc\"><a href=\"#new、malloc\" class=\"headerlink\" title=\"new、malloc\"></a>new、malloc</h4></li>\n<li><p>new：不仅仅是分配内存，还包括了对象类型转换以及初始化</p>\n<ul>\n<li>是先调用<em>operator new</em>分配内存空间，返回是<em>void</em> *类型；</li>\n<li>再将返回类型转换为指定类型，再调用类的构造函数。</li>\n<li>如果内存空间不足，会抛出<em>std::bad_alloc</em>异常</li>\n</ul>\n</li>\n<li><p>malloc</p>\n<ul>\n<li>返回 <code>void*</code>类型，并且在内存不足时，返回<code>NULL</code>指针</li>\n<li>当开辟的空间小于 <code>128K</code>时，调用<code>brk()</code> 函数，<code>malloc</code>的底层实现是系统调用函数 <code>brk()</code></li>\n<li><p>当开辟的空间大于 <code>128K</code>时，<code>mmap()</code> 系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟</p>\n<p><code>operator new</code> 底层也是由<code>malloc</code>实现。 <code>malloc</code>底层是由<code>slab</code>实现。</p>\n<p>对于<code>POD</code>类型对象，使用<code>new</code> 创建的对象，也是可以使用<code>free</code>来释放销毁对象，原因就是在于这个对象是<code>POD</code> 类型。没有其他资源需要释放，或者文件描述符需要关闭，因此可以不调用析构函数而使用<code>free</code>来替代<code>delete</code>。尽管可以，但是不推荐，这样的代码并不健壮。</p>\n<p><code>new</code> 在C++里是可以用 <code>malloc + placement</code> 替代的，或者说等效于这两个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更好的展示 malloc 与 new 的区别与联系</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo(<span class=\"keyword\">int</span> a=<span class=\"number\">0</span>, <span class=\"keyword\">int</span> b=<span class=\"number\">0</span>): a(a),b(b) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Foo() &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"dtor\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// new = placement new + malloc</span></span><br><span class=\"line\">    Foo* foo = <span class=\"keyword\">static_cast</span>&lt;Foo*&gt;(::<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Foo)));</span><br><span class=\"line\">    <span class=\"keyword\">new</span>(foo)Foo(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// delete</span></span><br><span class=\"line\">    foo-&gt;~Foo();</span><br><span class=\"line\">    ::<span class=\"built_in\">free</span>(foo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 运行结束，无内存泄露</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>除了<code>new</code>和<code>malloc</code>，还有什么方式可以在堆中分配内存么，以及怎么释放？<br> <strong><code>mmap</code>，<code>munmap</code></strong></p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>多态的三个条件：继承，重写（<code>override</code>），基类引用指向派生类对象。</p>\n</li>\n<li><p>静态多态   </p>\n<ul>\n<li><p>重载，在编译时期就可以确定</p>\n</li>\n<li><p>模板技术：比如 <code>CRTP</code>，它是使用子类来作为基类的模板参数，在基类中调用子类的方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Derived&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span> </span><br><span class=\"line\">      <span class=\"comment\">// 其他忽略</span></span><br><span class=\"line\">    <span class=\"function\">Derived&amp; <span class=\"title\">convert</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; </span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;Derived&amp;&gt;(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个也从侧面说明<code>static_cast</code> 可以让子类转换为父类，要使得保证安全，前提是转换后调用子类的方法中没有使用子类独有的数据成员</p>\n</li>\n</ul>\n</li>\n<li><p>动态多态<br>运行时才确定调用的是哪个函数。核心关键在于虚函数：子类重写基类的虚方法，定义指向子类对象的基类指针。这个基类指针的行为直到运行时才能确定调用的是子类还是基类的方法，这就是多态。</p>\n<p>实现原理是：虚函数表和虚函数指针<code>vptr</code>。<a href=\"./3.虚拟成员函数.md\">详情</a></p>\n<h4 id=\"重载-overload-和重写-override\"><a href=\"#重载-overload-和重写-override\" class=\"headerlink\" title=\"重载(overload)和重写(override)\"></a>重载(<code>overload</code>)和重写(<code>override</code>)</h4></li>\n<li><p>重载：允许多个同名函数，而这些函数的参数列表不同，函数模板这么实现的，在编译期间就能确定。</p>\n<p>C++函数重载底层实现原理是C++利用 <strong><code>name mangling</code></strong> 技术，来改变函数名，区分参数不同的同名函数。编译器通过函数名和其参数类型识别重载函数。不能仅仅基于不同的返回类型而实现函数重载，是因为经过 <code>name mangling</code> 后得到的函数名与返回值类型是无关的。</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a+b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  比如，如上的代码。在经过编译后，得到的符号表如下：</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ objdump -t main.o</span><br><span class=\"line\"><span class=\"number\">0000000000000000</span> g     F .text  <span class=\"number\">000000000000000</span>e _Z4funci</span><br><span class=\"line\"><span class=\"number\">000000000000000</span>e g     F .text  <span class=\"number\">0000000000000018</span> _Z4funcii</span><br><span class=\"line\"><span class=\"number\">0000000000000026</span> g     F .text  <span class=\"number\">0000000000000016</span> main</span><br></pre></td></tr></table></figure>\n<p>  其中， 前缀 <code>__z</code> 是规定，<code>4</code> 是函数名的字符个数，<code>i</code>是第一个函数的参数类型<code>int</code>，<code>ii</code>是第二个函数的参数类型<code>int, int</code>。由此可见也是与返回值无关的。</p>\n</li>\n<li><p>重写<code>override</code>：是指子类重新定义父类的方法，子类的函数名和参数列表以及返回值必须与父类的完全一致。对于虚函数的重写，c++11中新定义了一个关键词<code>override</code>，就是为了让子类在重写父类的虚函数方法时，如何参数列表发生更改可以让编译器报错。</p>\n<h4 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a><code>static</code></h4><p><code>static</code>变量都是在全局数据区分配内存,声明周期直到程序运行结束.</p>\n</li>\n<li><p>四类<code>static</code></p>\n<ul>\n<li>全局<code>static</code>变量和<code>static</code>函数：都已经被匿名命名空间取代，作用是不能外部文件使用</li>\n<li>局部<code>static</code>变量：在数据区<code>.data</code>分配内存，首次初始化以后，以后调用都不会再初始化，<strong>作用域仅局限于函数</strong>，生命周期直到程序运行结束</li>\n<li>静态数据成员:类对象共享，不能在类声明中定义，是因为在定义时就要分配空间，也是在<code>.data</code> </li>\n<li>静态成员函数:静态成员函数，<strong>不隐含this指针</strong>，不能调用非静态成员函数/变量，可以用作回调函数</li>\n</ul>\n</li>\n<li><p>为什么要引入<code>static</code>  </p>\n<p>需要一个数据对象为整个类而非某个对象服务，同时又不能破坏类的封装特性，因此将静态成员隐藏在类的内部,提供静态成员函数接口，因为共享,可以节省内存。</p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4></li>\n<li><p>空类有六个成员函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Empty</span> &#123;</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Empty(); </span><br><span class=\"line\">  Empty(<span class=\"keyword\">const</span> Empty&amp; );</span><br><span class=\"line\">  ~Empty();</span><br><span class=\"line\"></span><br><span class=\"line\">  Empty&amp; <span class=\"keyword\">operator</span>=(consy Empty&amp; );</span><br><span class=\"line\">  Empty* <span class=\"keyword\">operator</span>&amp; ();               <span class=\"comment\">// 取地址运算符</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Empty* <span class=\"keyword\">operator</span>&amp; () <span class=\"keyword\">const</span>;   <span class=\"comment\">// const 类型取地址运算符</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构造函数可以是虚函数吗？析构函数可以是虚函数吗？</p>\n<p>虚函数对应一个<code>vtbl</code>，这个<code>vtbl</code>实际是存储在对象的内存空间.如果构造函数是虚的,对象的构造就需要<code>vtbl</code>来调用，而虚函数表又是在对象构造后才能建立,因此构造函数不能是虚函数.</p>\n<p>而析构函数在使用多态的继承中一般都是虚析构函数.为的是能正确选择析构函数.</p>\n</li>\n<li><p><code>c++</code>的深拷贝如何理解 </p>\n<p>在类中有指针时并且内部分配资源.经过浅拷贝后,最终会造成资源一次分配,多次释放.造成系统崩溃.</p>\n<h4 id=\"C-中如何在main-函数之前执行操作\"><a href=\"#C-中如何在main-函数之前执行操作\" class=\"headerlink\" title=\"C++中如何在main()函数之前执行操作\"></a>C++中如何在main()函数之前执行操作</h4><p>main函数执行之前，主要就是初始化系统相关资源：</p>\n</li>\n<li>设置栈指针</li>\n<li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li>\n<li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容     </li>\n<li>全局对象初始化，在<code>main</code>之前调用构造函数</li>\n<li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li>\n</ul>\n<p><strong>main函数执行之后</strong>：  </p>\n<ul>\n<li>全局对象的析构函数会在main函数之后执行； </li>\n<li>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main 之后执行;<h4 id=\"sizeof-和-strlen-区别\"><a href=\"#sizeof-和-strlen-区别\" class=\"headerlink\" title=\"sizeof  和 strlen 区别\"></a>sizeof  和 strlen 区别</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str = <span class=\"string\">\"name\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">sizeof</span>(str); <span class=\"comment\">// 取的是指针str的长度，是8</span></span><br><span class=\"line\">    <span class=\"built_in\">strlen</span>(str); <span class=\"comment\">// 取的是这个字符串的长度，不包含结尾的 \\0。大小是4</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"strcpy、strncpy和mmemcpy的区别\"><a href=\"#strcpy、strncpy和mmemcpy的区别\" class=\"headerlink\" title=\"strcpy、strncpy和mmemcpy的区别\"></a>strcpy、strncpy和mmemcpy的区别</h4>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>*  dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* src)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strncpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* src, <span class=\"keyword\">size_t</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">memcpy</span> <span class=\"params\">(<span class=\"keyword\">void</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* src, <span class=\"keyword\">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>  前面两个函数是以字符为单位，而<code>mmemcpy</code>是以字节为单位。</p>\n<p>  <code>strcpy</code>和<code>memcpy</code>主要有以下3方面的区别。  </p>\n<ul>\n<li>复制的内容不同。<code>strcpy</code> 只能复制字符串，而<code>memcpy</code>可以复制任意内容，例如字符数组、整型、结构体、类等。</li>\n<li>复制的方法不同。<code>strcpy</code> 不需要指定长度，它遇到被复制字符的串结束符<code>&#39;\\0&#39;</code>才结束，所以容易溢出。<code>memcpy</code> 则是根据其第3个参数决定复制的长度，而且如果字符串数据中包含<code>&#39;\\0&#39;</code>，只能用<code>memcpy</code>。</li>\n<li><p>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p>\n<p><code>strncpy</code> ：在复制字符串时，<code>memcpy</code>更加类似于<code>strncpy</code>。<br><code>strncpy</code>和<code>memcpy</code>很相似，只不过它在一个终止的空字符处停止。当 <code>n &gt; strlen(src)</code> 时，<code>dst[strlen(len)] ~ dst[n-1]</code>都是<code>\\0</code>；当 <code>n&lt;=strlen(src)</code>时，复制前<code>src</code>的n个字符。这里隐藏了一个事实，就是<code>dst</code>指向的内存一定会被写n个字符。</p>\n<p><code>memcpy</code>需要注意的是：   </p>\n</li>\n<li><code>dest</code> 指针要分配足够的空间，也即大于等于 <code>n</code> 字节的空间。如果没有分配空间，会出现断错误。</li>\n<li><p><code>dest</code> 和 <code>src</code> 所指的内存空间不能重叠（如果发生了重叠，使用 <code>memmove()</code> 会更加安全）。</p>\n<p>动手实现 <code>memcpy</code>： </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">myMemcpy</span><span class=\"params\">(<span class=\"keyword\">void</span>* dst, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* src, <span class=\"keyword\">size_t</span> n)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(dst ==<span class=\"literal\">nullptr</span> || src==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(src == dst) retrun src;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span>* pdst       = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">char</span>*&gt;(dst); </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* psrc = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*&gt;(src);</span><br><span class=\"line\">    <span class=\"comment\">// 发生重叠时，从后向前复制</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(psrc &lt;  pdst &amp;&amp; pdst &lt; psrc + n) </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=n<span class=\"number\">-1</span>; i &gt;=<span class=\"number\">0</span>; --i)  pdst[i] = psrc[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; n; ++i) pdst[i] = psrc[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pdst;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">12</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[]  = <span class=\"string\">\"hello world cpp\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    myMemcpy(str, str+<span class=\"number\">6</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;str&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"野指针和悬空指针\"><a href=\"#野指针和悬空指针\" class=\"headerlink\" title=\"野指针和悬空指针\"></a>野指针和悬空指针</h4><p>  都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p>\n<ul>\n<li><p>野指针<br>野指针，指的是没有被初始化过的指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>* p;     <span class=\"comment\">// 未初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt; *p &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">// 未初始化就被使用</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此，为了防止出错，对于指针初始化时都是赋值为 <code>nullptr</code>，这样在使用时编译器就会直接报错，产生非法内存访问。</p>\n</li>\n<li><p>悬空指针<br>悬空指针，指针最初指向的内存已经被释放了的一种指针。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">int</span> * p = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span>* p2 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  p = p2;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> p2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为<code>p=p2=nullptr</code>。此时再使用，编译器会直接保错。</p>\n<pre><code>避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。\n</code></pre><h4 id=\"malloc、calloc、realloc\"><a href=\"#malloc、calloc、realloc\" class=\"headerlink\" title=\"malloc、calloc、realloc\"></a>malloc、calloc、realloc</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">malloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">calloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> nmemb, <span class=\"keyword\">size_t</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">realloc</span><span class=\"params\">(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free</span><span class=\"params\">(<span class=\"keyword\">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>malloc</code><br>最常用的分配内存函数，分配<code>size</code>个字节。<strong>分配的内存是未初始化的</strong>，如果<code>size==0</code>，要么返回<code>NULL</code>，要么返回一个独一无二的指针，能被<code>free</code>释放。</li>\n<li><p><code>realloc</code>：用来改变已有内存区的大小，而不改变内容。新的大小为参数<code>size</code>，即newsize。</p>\n<ul>\n<li><code>ptr==NULL</code>：<code>realloc(NULL,size)</code>就相当于<code>malloc(size)</code></li>\n<li><code>size==0</code>：<code>realloc(ptr, 0)</code>就相当于<code>free(ptr)</code></li>\n<li><code>ptr==NULL &amp;&amp; size==0</code>：危险。</li>\n<li>如果<code>newsize &gt; oldsize</code>，那么增加的内存是未初始化的，原来的内存内容保持不变，即<code>[ptr, ptr+oldsize)</code>内部不变，<code>[ptr+oldsize, ptr+newsize)</code>是初始化的内容。</li>\n</ul>\n</li>\n<li><p>如果<code>newsize &lt; oldsize</code>，尾部的内容就被切去，释放，只是剩下前面。</p>\n<p><strong>因此 <code>realloc</code>之后不能给这个内存区初始化</strong>.</p>\n</li>\n<li><p><code>calloc</code><br>分配<code>nmemb</code>个元素，每个元素大小是<code>size</code>个字节的连续内存。</p>\n<ul>\n<li>内存大小是<code>nmemb*size</code>的连续内存区</li>\n<li><strong>这块内存被初始化为<code>0</code></strong>。</li>\n</ul>\n<p>如果<code>size==0</code>，要么返回<code>NULL</code>，要么返回一个独一无二的指针，能被<code>free</code>释放。</p>\n<h4 id=\"编译知识\"><a href=\"#编译知识\" class=\"headerlink\" title=\"编译知识\"></a>编译知识</h4><p>为了减小编译依赖加快编译速度和生成二进制文件的大小，C/C++ 项目中一般在 <em>.h 文件对于<em>*指针类型（包括智能指针）</em></em> 尽量使用前置声明，而不是直接包含对应类的头文件。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Test.h</span></span><br><span class=\"line\"><span class=\"comment\">//在这里使用A的前置声明，而不是直接包含A.h文件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Test();</span><br><span class=\"line\">  ~Test();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  A*</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Copy-Elision\"><a href=\"#Copy-Elision\" class=\"headerlink\" title=\"Copy Elision\"></a>Copy Elision</h4><p>g++ 编译器是默认开启 <code>copy elison</code> 选项的。如果要关闭这个选项，使用 <code>-fno-elide-constructors</code>。<code>copy elision</code> 主要包括以下两项内容：</p>\n<font color=\"yellow\">1. 返回值优化</font>  \n\n<p>即通过将返回对象所占空间的直接构造到他们本来要复制/移动到的对象中去，依次来避免拷贝/移动操作。返回值优化包括具名返回值优化 <code>NRVO</code> 与 匿名返回值优化 <code>URVO</code>，区别在于返回值是具名的局部变量（<code>NRVO</code>）还是无名的临时对象（<code>URVO</code>）</p>\n<ul>\n<li><p><code>URVO</code> 与 彻底 <code>Copy elision</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Copyable</span> &#123;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Copyable() &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"default ctor\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Copyable(<span class=\"keyword\">const</span> Copyable&amp; rhs) = <span class=\"keyword\">delete</span>; </span><br><span class=\"line\">  Copyable(Copyable&amp;&amp; rhs) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Copyable <span class=\"title\">return_urvo_value</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> Copyable&#123;&#125;; <span class=\"comment\">// since c++17 ok</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> x  = return_urvo_value();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码在C++17中是可以编译通过的。在 C++17 之前，并没有明确的提出在什么情况下，可以彻底进行 <code>Copy Elision</code>（这里的彻底的指的是包括不进行检查是否有可用的 <em>copy/move</em> 构造函数）。在C++17中，对于匿名对象（or 临时对象）不论是传递参数，还是以返回值返回时，都不会调用拷贝/移动构造。因此上面的这段代码在C++17是可以正常编过的，而在C++14会编译出错。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ main.cc -<span class=\"built_in\">std</span>=c++<span class=\"number\">14</span> -o main &amp;&amp; ./main</span><br><span class=\"line\">main.cc: In function ‘Copyable return_urvo_value()’:</span><br><span class=\"line\">main.cc:<span class=\"number\">29</span>:<span class=\"number\">19</span>: error: use of deleted function ‘Copyable::Copyable(Copyable&amp;&amp;)’</span><br><span class=\"line\">  <span class=\"number\">29</span> |   <span class=\"keyword\">return</span> Copyable&#123;&#125;;</span><br><span class=\"line\">     |                   ^</span><br><span class=\"line\">main.cc:<span class=\"number\">24</span>:<span class=\"number\">3</span>: note: declared here</span><br><span class=\"line\">  <span class=\"number\">24</span> |   Copyable(Copyable&amp;&amp; rhs) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">     |   ^~~~~~~~</span><br><span class=\"line\">main.cc: In function ‘int main(int, const char**)’:</span><br><span class=\"line\">main.cc:<span class=\"number\">34</span>:<span class=\"number\">31</span>: error: use of deleted function ‘Copyable::Copyable(Copyable&amp;&amp;)’</span><br><span class=\"line\">  <span class=\"number\">34</span> |   <span class=\"keyword\">auto</span> x  = return_urvo_value();</span><br><span class=\"line\">     |                               ^</span><br><span class=\"line\">main.cc:<span class=\"number\">24</span>:<span class=\"number\">3</span>: note: declared here</span><br><span class=\"line\">  <span class=\"number\">24</span> |   Copyable(Copyable&amp;&amp; rhs) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">     |   ^~~~~~~~</span><br></pre></td></tr></table></figure>\n<p>  自然，只要将上面代码中的如下两行注释掉，即可正常编译，并且 <code>Copyable</code>的构造函数都是只被调用一次，即<code>copy elision</code> 起作用了。 注意：<code>Copyable</code>的复制/移动构造函数必须同时可访问。</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copyable(<span class=\"keyword\">const</span> Copyable&amp; rhs) = <span class=\"keyword\">delete</span>; </span><br><span class=\"line\">Copyable(Copyable&amp;&amp; rhs) = <span class=\"keyword\">delete</span>;</span><br></pre></td></tr></table></figure>\n<p>  因此，在C++17以前，对于 <code>urvo</code> 不在乎是否返回的对象的复制/移动构造函数是否存在或者可访问，<code>copy elision</code> 都能生效。而在 <code>C++14</code> 之前，返回的对象可以没有复制/移动构造函数，但是必须可以访问。</p>\n</li>\n<li><p><code>nrvo</code><br>在 <code>nrvo</code>时，返回对象的复制/移动构造函数必须可访问。否则编译不过。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Copyable</span> &#123;</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Copyable() &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"default ctor\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Copyable(<span class=\"keyword\">const</span> Copyable&amp; rhs) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  Copyable(Copyable&amp;&amp; rhs) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Copyable <span class=\"title\">return_urvo_value</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> Copyable&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Copyable <span class=\"title\">return_nrvo_value</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">  Copyable local;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> x  = return_urvo_value();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> y  = return_nrvo_value();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码，即使是C++17也会编译失败，必须将如下两行代码注释掉，使得 <code>Copyable</code> 对象的复制/移动构造函数可访问。<code>copy elision</code> 才能生效：<code>Copyable</code> 的默认构造函数只调用一次。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyable(const Copyable&amp; rhs) = delete;</span></span><br><span class=\"line\"><span class=\"comment\">// Copyable(Copyable&amp;&amp; rhs) = delete;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<font color=\"yellow\"> 2. 右值拷贝优化 </font>  \n\n<p>右值拷贝优化，当某一个类的临时对象以值传递给该类的另一个对象时，也可以直接利用该临时对象的来避免拷贝/移动操作。在上面的基础上，加上如下的代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pass_by_value</span><span class=\"params\">(Copyable rhs)</span> </span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> x  = return_urvo_value();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> y  = return_nrvo_value();</span><br><span class=\"line\"></span><br><span class=\"line\">  pass_by_value(Copyable());</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最终的输出也是调用默认三次构造函数：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ main.cc -std=c++11 -o main &amp;&amp; ./main</span><br><span class=\"line\">default ctor</span><br><span class=\"line\">default ctor</span><br><span class=\"line\">default ctor</span><br></pre></td></tr></table></figure></p>\n<p>到此，<code>copy elision</code> 基本分析结束。如果想查看没有<code>copy elision</code> 作用下的输出，开启<code>-fno-elide-constructors</code>。</p>\n<h4 id=\"Copy-Elision-作用\"><a href=\"#Copy-Elision-作用\" class=\"headerlink\" title=\"Copy Elision 作用\"></a>Copy Elision 作用</h4><p>对于一些没有拷贝/移动构造的对象，如 <code>unique_ptr</code>、 <code>atomic</code> 等。现在我们能够定义一个工厂函数，即使没有复制或移动构造函数都可以返回一个对象。例如，以下通用工厂函数:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">make_instance</span><span class=\"params\">(Args&amp;&amp; ... args)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> T&#123; <span class=\"built_in\">std</span>::forward&lt;Args&gt;(args)... &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i   = make_instance&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\">  <span class=\"comment\">// std::unique_ptr 实现了 移动构造函数，因此可以编译成功 </span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> up = make_instance&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>&#123; <span class=\"number\">42</span> &#125;); </span><br><span class=\"line\">  <span class=\"comment\">// 禁止了复制构造函数，但是也没有实现移动构造函数，因此要到 C++17 才能编译过</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ai = make_instance&lt;<span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt;&gt;(<span class=\"number\">42</span>);                  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://blog.csdn.net/davidhopper/article/details/90696200\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h2><h3 id=\"std-vector\"><a href=\"#std-vector\" class=\"headerlink\" title=\"std::vector\"></a><em>std::vector</em></h3><ul>\n<li><em>std::vector</em> 在 <em>push_back</em> 以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。</li>\n<li>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好</li>\n<li><em>std::vector/std::list</em>的实现原理及其使用场景<br><em>std::vector</em>是用连续内存的数组实现的，<em>std::list</em>是通过指针之间的指向实现不连续内存的高效率使用.</li>\n</ul>\n<p><em>std::vector</em> 与 <em>std::list</em></p>\n<ul>\n<li>数组，最大的好处是能以 <em>O(1)</em> 用索引访问任意元素，次要好处是内存布局紧凑，省内存之余还有高缓存一致性（<em>cache coherence</em>）。但数组的缺点是不能快速插入元素，而且我们在解析 <em>JSON</em> 数组的时候，还不知道应该分配多大的数组才合适。</li>\n<li>链表，它的最大优点是可快速地插入元素（开端、末端或中间），但需要以 <em>O(n)</em> 时间去经索引取得内容。如果我们只需顺序遍历，那么是没有问题的。还有一个小缺点，就是相对数组而言，链表在存储每个元素时有额外内存开销（存储下一节点的指针），而且遍历时元素所在的内存可能不连续，令缓存不命中（<em>cache miss</em>）的机会上升。</li>\n</ul>\n<h3 id=\"std-bind\"><a href=\"#std-bind\" class=\"headerlink\" title=\"std::bind\"></a><em>std::bind</em></h3><p>对于如下代码，使用 <em>std::bind</em> 绑定类的成员函数并调用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Foo()=<span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; lhs, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; rhs)</span> </span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt; (lhs + rhs)&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  Foo foo1;</span><br><span class=\"line\">   <span class=\"comment\">// 绑定并且执行</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::bind(&amp;Foo::add, &amp;foo1, <span class=\"number\">1</span>, <span class=\"number\">2</span>)();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后内部执行的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Res, <span class=\"keyword\">typename</span> _MemFun, <span class=\"keyword\">typename</span> _Tp, <span class=\"keyword\">typename</span>... _Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> _Res</span><br><span class=\"line\">__invoke_impl(__invoke_memfun_deref, _MemFun&amp;&amp; __f, _Tp&amp;&amp; <span class=\"keyword\">__t</span>, _Args&amp;&amp;... __args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((*<span class=\"built_in\">std</span>::forward&lt;_Tp&gt;(<span class=\"keyword\">__t</span>)).*__f)(<span class=\"built_in\">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 </p>\n<ul>\n<li><code>_t</code> ，类型是 <code>Foo*&amp;</code> 函数对象指针，指向的<code>foo1</code>对象。</li>\n<li><code>_f</code>是函数指针，指向的就是<code>add</code>成员函数</li>\n<li><code>__invoke_memfun_deref</code>：是用来标记是哪种把绑定方式，比如上述代码中的绑定对象成员函数</li>\n</ul>\n<p>因此，最终，调用可以简化为如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo1.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>整个<code>std::bind</code> 最终的执行代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接传入函数调用: std::bind(func, arg1, arg2); 或者静态成员函数</span></span><br><span class=\"line\"><span class=\"comment\">// 很明显，这里没有类对象</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Res, <span class=\"keyword\">typename</span> _Fn, <span class=\"keyword\">typename</span>... _Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> _Res</span><br><span class=\"line\">__invoke_impl(__invoke_other, _Fn&amp;&amp; __f, _Args&amp;&amp;... __args)</span><br><span class=\"line\">&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::forward&lt;_Fn&gt;(__f)(<span class=\"built_in\">std</span>::forward&lt;_Args&gt;(__args)...); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面介绍过</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Res, <span class=\"keyword\">typename</span> _MemFun, <span class=\"keyword\">typename</span> _Tp, <span class=\"keyword\">typename</span>... _Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> _Res</span><br><span class=\"line\">__invoke_impl(__invoke_memfun_deref, _MemFun&amp;&amp; __f, _Tp&amp;&amp; <span class=\"keyword\">__t</span>, _Args&amp;&amp;... __args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((*<span class=\"built_in\">std</span>::forward&lt;_Tp&gt;(<span class=\"keyword\">__t</span>)).*__f)(<span class=\"built_in\">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面几种没见过调用</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Res, <span class=\"keyword\">typename</span> _MemFun, <span class=\"keyword\">typename</span> _Tp, <span class=\"keyword\">typename</span>... _Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> _Res</span><br><span class=\"line\">__invoke_impl(__invoke_memfun_ref, _MemFun&amp;&amp; __f, _Tp&amp;&amp; <span class=\"keyword\">__t</span>, _Args&amp;&amp;... __args)</span><br><span class=\"line\">&#123; <span class=\"keyword\">return</span> (__invfwd&lt;_Tp&gt;(<span class=\"keyword\">__t</span>).*__f)(<span class=\"built_in\">std</span>::forward&lt;_Args&gt;(__args)...); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Res, <span class=\"keyword\">typename</span> _MemPtr, <span class=\"keyword\">typename</span> _Tp&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> _Res</span><br><span class=\"line\">__invoke_impl(__invoke_memobj_ref, _MemPtr&amp;&amp; __f, _Tp&amp;&amp; <span class=\"keyword\">__t</span>)</span><br><span class=\"line\">&#123; <span class=\"keyword\">return</span> __invfwd&lt;_Tp&gt;(<span class=\"keyword\">__t</span>).*__f; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Res, <span class=\"keyword\">typename</span> _MemPtr, <span class=\"keyword\">typename</span> _Tp&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> _Res</span><br><span class=\"line\">__invoke_impl(__invoke_memobj_deref, _MemPtr&amp;&amp; __f, _Tp&amp;&amp; <span class=\"keyword\">__t</span>)</span><br><span class=\"line\">&#123; <span class=\"keyword\">return</span> (*<span class=\"built_in\">std</span>::forward&lt;_Tp&gt;(<span class=\"keyword\">__t</span>)).*__f; &#125;</span><br></pre></td></tr></table></figure>\n<p><em>Lambda</em></p>\n<p><em>lambda</em>可以理解为是仿函数的语法糖。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> add  = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123; <span class=\"keyword\">return</span> a+b; &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于上面的<code>lambda</code>函数，在gdb调试，经过编译的到的函数类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) s</span><br><span class=\"line\">&lt;lambda(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)&gt;::<span class=\"keyword\">operator</span>()(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) <span class=\"keyword\">const</span> (__closure=<span class=\"number\">0x7fffffffe6d3</span>, a=<span class=\"number\">1</span>, b=<span class=\"number\">2</span>) at main.cpp:<span class=\"number\">24</span></span><br><span class=\"line\"><span class=\"number\">24</span>        <span class=\"keyword\">auto</span> add  = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123; <span class=\"keyword\">return</span> a+b; &#125;;</span><br></pre></td></tr></table></figure>\n<p><code>lambda</code>可以看作是匿名的函数对象，并且 <code>lambda</code>表达式默认是 <code>const</code>属性。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Foo() </span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"123\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; &#125;();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">  Foo foo;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在类中调用<code>lambda</code>表达式，编译出来的类型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo::Foo()::&#123;lambda()#<span class=\"number\">1</span>&#125;::<span class=\"keyword\">operator</span>()() <span class=\"keyword\">const</span></span><br></pre></td></tr></table></figure>\n<p>而实际上，lambda与operator本质上也是一样的，如下代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span> </span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">     Foo() </span><br><span class=\"line\">     &#123; </span><br><span class=\"line\">       <span class=\"comment\">// 以下两个设计等价</span></span><br><span class=\"line\">       [<span class=\"keyword\">this</span>](<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str)&#123;<span class=\"keyword\">this</span>-&gt;print(str); &#125;(<span class=\"string\">\"lambda\"</span>);</span><br><span class=\"line\">       Unmaed(<span class=\"keyword\">this</span>)(<span class=\"string\">\"operator\"</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;str&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Unmaed</span></span></span><br><span class=\"line\"><span class=\"class\">     &#123;</span></span><br><span class=\"line\">       Unmaed(Foo* foo): foo_(foo) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">       </span>&#123;</span><br><span class=\"line\">         foo_-&gt;print(str);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Foo* foo_;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">   &#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"std-bind-与-lambad区别\"><a href=\"#std-bind-与-lambad区别\" class=\"headerlink\" title=\"std::bind 与 lambad区别\"></a>std::bind 与 lambad区别</h4><ul>\n<li><p><code>lambda</code> 可以重载，但是 <code>std::bind</code> 无法区别重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> g = [] &#123; f(<span class=\"number\">1</span>); &#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> g = <span class=\"built_in\">std</span>::bind(f, <span class=\"number\">1</span>); <span class=\"comment\">// 错误</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> g = <span class=\"built_in\">std</span>::bind(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span>(*)(<span class=\"keyword\">int</span>)&gt;(f), <span class=\"number\">1</span>); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>为此必须指定对应的函数指针类型。<code>lambda</code> 闭包类的 <code>operator()</code> 采用的是能被编译器内联的常规的函数调用。而<code>std::bind</code>采用的是一般不会被内联的函数指针调用，这意味着 <strong><code>lambda</code> 比 <code>std::bind</code> 运行得更快</strong>。</p>\n<ul>\n<li>传给 <code>std::bind</code> 的参数，绑定的是 <code>std::bind</code>，而不是<code>std::bind</code>内部管理的函数<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"built_in\">std</span>::chrono::steady_clock::time_point t, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::this_thread::sleep_until(t);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> g = [](<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    f(<span class=\"built_in\">std</span>::chrono::steady_clock::now() + <span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">3</span>), i);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">g(<span class=\"number\">1</span>); <span class=\"comment\">// 3秒后打印1</span></span><br><span class=\"line\"><span class=\"comment\">// 用std::bind实现相同效果，但存在问题</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> h = <span class=\"built_in\">std</span>::bind(f,</span><br><span class=\"line\">                    <span class=\"built_in\">std</span>::chrono::steady_clock::now() + \t <span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">3</span>),</span><br><span class=\"line\">                    <span class=\"built_in\">std</span>::placeholders::_1);</span><br><span class=\"line\"></span><br><span class=\"line\">h(<span class=\"number\">1</span>); <span class=\"comment\">// 3秒后打印1，但3秒指的是调用std::bind后的3秒，而非调用f后的3秒</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>计算时间的表达式作为实参被传递给<code>std::bind</code>，因此计算发生在调用<code>std::bind</code>的时刻，而非调用其绑定的函数的时刻。</p>\n<p>在 <code>c++14</code> 中，完全没有理由使用 <code>std::bind</code>，<code>c++11</code>由于特性受限，存在两个使用场景：</p>\n<ul>\n<li>模拟<code>c++11</code>缺少的移动捕获</li>\n<li>函数对象 <code>operator()</code> 是模板时，如果将此函数作为参数使用，用 <code>std::bind</code> 绑定才能接受任意类型参数<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">      <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">X x;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f = <span class=\"built_in\">std</span>::bind(x, _1); <span class=\"comment\">// f可以接受任意参数类型</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// c++14 做法</span></span><br><span class=\"line\">  X a;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f = [a](<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; x) &#123; a(x); &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Lambda-与-std-bind-区别补充\"><a href=\"#Lambda-与-std-bind-区别补充\" class=\"headerlink\" title=\"Lambda 与 std::bind 区别补充\"></a><em>Lambda</em> 与 <em>std::bind</em> 区别补充</h4><p><code>std::bind</code> 传入的参数默认情况下是 “值传递”，想要使用引用传递需要<code>std::ref</code>。详细可以参考下面的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Foo() </span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"default\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Foo(<span class=\"keyword\">const</span> Foo&amp; rhs)     </span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"ctor\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">const</span> Foo&amp; lhs, <span class=\"keyword\">const</span> Foo&amp; rhs)</span> </span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">std</span>::boolalpha;</span><br><span class=\"line\"></span><br><span class=\"line\">  Foo foo1;</span><br><span class=\"line\">  Foo foo2;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"bind: pass by value\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> func = <span class=\"built_in\">std</span>::bind(add,  foo1, foo2);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"bind: pass by ref\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> func = <span class=\"built_in\">std</span>::bind(add,  <span class=\"built_in\">std</span>::ref(foo1), <span class=\"built_in\">std</span>::ref(foo2));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"lambda \"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  [&amp;foo1, &amp;foo2]&#123; add(foo1, foo2);&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码输出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ -g  -O0 main.cc -o main &amp;&amp; ./main</span><br><span class=\"line\">default</span><br><span class=\"line\">default</span><br><span class=\"line\"><span class=\"built_in\">bind</span>: pass by value</span><br><span class=\"line\">ctor</span><br><span class=\"line\">ctor</span><br><span class=\"line\"><span class=\"built_in\">bind</span>: pass by ref</span><br><span class=\"line\">lambda</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>std::bind</code>在默认情况下，是依靠值传递，使用了<code>std::ref</code>来包裹传入参数才是使用引用传递。用 <code>gdb</code> 调试，可以跟踪到发生构造 <code>Foo</code> 对象的位置：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _UHead&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> _Head_base(_UHead&amp;&amp; __h) : _Head(<span class=\"built_in\">std</span>::forward&lt;_UHead&gt;(__h)) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 整个调用链如下：</span></span><br><span class=\"line\">#<span class=\"number\">0</span>  Foo::Foo (<span class=\"keyword\">this</span>=<span class=\"number\">0x7fffffffe068</span>, rhs=...) at main.cc:<span class=\"number\">13</span></span><br><span class=\"line\">#<span class=\"number\">1</span>  <span class=\"number\">0x0000555555555a8c</span> in <span class=\"built_in\">std</span>::_Head_base&lt;<span class=\"number\">1u</span>l, Foo, <span class=\"literal\">true</span>&gt;::_Head_base&lt;Foo&amp;&gt; (<span class=\"keyword\">this</span>=<span class=\"number\">0x7fffffffe068</span>, __h=...) at /usr/include/c++/<span class=\"number\">9</span>/tuple:<span class=\"number\">87</span></span><br><span class=\"line\">#<span class=\"number\">2</span>  <span class=\"number\">0x00005555555559e8</span> in <span class=\"built_in\">std</span>::_Tuple_impl&lt;<span class=\"number\">1u</span>l, Foo&gt;::_Tuple_impl&lt;Foo&amp;&gt; (<span class=\"keyword\">this</span>=<span class=\"number\">0x7fffffffe068</span>, __head=...) at /usr/include/c++/<span class=\"number\">9</span>/tuple:<span class=\"number\">349</span></span><br><span class=\"line\">#<span class=\"number\">3</span>  <span class=\"number\">0x00005555555558f3</span> in <span class=\"built_in\">std</span>::_Tuple_impl&lt;<span class=\"number\">0u</span>l, Foo, Foo&gt;::_Tuple_impl&lt;Foo&amp;, Foo&amp;, <span class=\"keyword\">void</span>&gt; (<span class=\"keyword\">this</span>=<span class=\"number\">0x7fffffffe068</span>, __head=...)</span><br><span class=\"line\">    at /usr/include/c++/<span class=\"number\">9</span>/tuple:<span class=\"number\">218</span></span><br><span class=\"line\">#<span class=\"number\">4</span>  <span class=\"number\">0x0000555555555815</span> in <span class=\"built_in\">std</span>::tuple&lt;Foo, Foo&gt;::tuple&lt;Foo&amp;, Foo&amp;, <span class=\"literal\">true</span>&gt; (<span class=\"keyword\">this</span>=<span class=\"number\">0x7fffffffe068</span>, __a1=..., __a2=...) at /usr/include/c++/<span class=\"number\">9</span>/tuple:<span class=\"number\">969</span></span><br><span class=\"line\">#<span class=\"number\">5</span>  <span class=\"number\">0x00005555555556fc</span> in <span class=\"built_in\">std</span>::_Bind&lt;<span class=\"keyword\">void</span> (*(Foo, Foo))(Foo <span class=\"keyword\">const</span>&amp;, Foo <span class=\"keyword\">const</span>&amp;)&gt;::_Bind&lt;Foo&amp;, Foo&amp;&gt;(<span class=\"keyword\">void</span> (*&amp;&amp;)(Foo <span class=\"keyword\">const</span>&amp;, Foo <span class=\"keyword\">const</span>&amp;), Foo&amp;, Foo&amp;)</span><br><span class=\"line\">    (<span class=\"keyword\">this</span>=<span class=\"number\">0x7fffffffe060</span>, __f=@<span class=\"number\">0x7fffffffe010</span>: <span class=\"number\">0x5555555551ea</span> &lt;add(Foo <span class=\"keyword\">const</span>&amp;, Foo <span class=\"keyword\">const</span>&amp;)&gt;) at /usr/include/c++/<span class=\"number\">9</span>/functional:<span class=\"number\">467</span></span><br><span class=\"line\">#<span class=\"number\">6</span>  <span class=\"number\">0x0000555555555571</span> in <span class=\"built_in\">std</span>::bind&lt;<span class=\"keyword\">void</span> (&amp;)(Foo <span class=\"keyword\">const</span>&amp;, Foo <span class=\"keyword\">const</span>&amp;), Foo&amp;, Foo&amp;&gt; (__f=</span><br><span class=\"line\">    @<span class=\"number\">0x5555555551ea</span>: &#123;<span class=\"keyword\">void</span> (<span class=\"keyword\">const</span> Foo &amp;, <span class=\"keyword\">const</span> Foo &amp;)&#125; <span class=\"number\">0x5555555551ea</span> &lt;add(Foo <span class=\"keyword\">const</span>&amp;, Foo <span class=\"keyword\">const</span>&amp;)&gt;) at /usr/include/c++/<span class=\"number\">9</span>/functional:<span class=\"number\">812</span></span><br><span class=\"line\">#7  0x00005555555552b7 in main (argc=1, argv=0x7fffffffe198) at main.cc:30</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"左值引用和右值引用区别\"><a href=\"#左值引用和右值引用区别\" class=\"headerlink\" title=\"左值引用和右值引用区别\"></a>左值引用和右值引用区别</h3><p> 左值引用，也就是“常规引用”，不能绑定到要转换的表达式，字面常量，或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。</p>\n<p> 右值引用就是必须绑定到右值的引用，通过&amp;&amp;获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。</p>\n<p> 返回左值的表达式包括返回左值引用的函数及赋值，下标，解引用和<strong>前置递增/递减运算符</strong>；<br> 返回右值的包括返回非引用类型的函数及算术，关系，位和后置递增/递减运算符。可以看到左值的特点是有持久的状态，而右值则是短暂的<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp;&amp; index, <span class=\"keyword\">int</span> idx)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(idx &gt; <span class=\"number\">3</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  func(index++, ++idx);  <span class=\"comment\">// Ok </span></span><br><span class=\"line\">  func(++index, ++idx);  <span class=\"comment\">// Error</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt; <span class=\"built_in\">std</span>::is_rvalue_reference&lt;<span class=\"keyword\">decltype</span>(index)&gt;::value &lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 在上面的代码中，<code>++index</code> 产生的是左值，而 <code>index++</code> 产生的是右值。因此上面的可以编译成功，下面的编译不过。</p>\n<p>【注意】：已经命名的右值，编译器会认为是左值。</p>\n<h3 id=\"左值与右值\"><a href=\"#左值与右值\" class=\"headerlink\" title=\"左值与右值\"></a>左值与右值</h3><p>变量都是左值，即使变量是右值引用类型<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; ref1 = <span class=\"number\">1</span>;     <span class=\"comment\">//  ok </span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; ref2 = ref1; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure></p>\n<p>因为 <code>ref2</code> 是右值引用类型的变量，不能将其绑定到左值<code>ref1</code>上。<strong><code>ref1</code> 与 <code>ref2</code> 是左值，因为他们都是变量，但是变量类型是右值引用类型，即这两个变量只能绑定到右值上</strong>。</p>\n<h3 id=\"四种类型转换总结\"><a href=\"#四种类型转换总结\" class=\"headerlink\" title=\"四种类型转换总结\"></a>四种类型转换总结</h3><h4 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a><em>static_cast</em></h4><ul>\n<li><p>基类和子类之间转换：<br>  <code>static_cast</code> 的使用，当且仅当类型之间可隐式转化时，<code>static_cast</code> 的转化才是合法的。有一个例外，那就是类层次间的向下转型，<code>static_cast</code> 可以完成类层次间的向下转型，但是向下转型无法通过隐式转换完成。</p>\n<ul>\n<li><p>向上转换安全：子类指针转换成父类指针是安全的;</p>\n</li>\n<li><p>向下转换不安全：父类指针转换成子类指针是不安全的。</p>\n</li>\n<li><p><code>static_cast</code>不能进行无关类型(如非基类和子类)指针之间的转换。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span> &#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> base&#123; <span class=\"comment\">/**....*/</span> &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    Base*    B = <span class=\"keyword\">new</span> Base;</span><br><span class=\"line\">    Derived* D = <span class=\"keyword\">static_cast</span>&lt;Drived*&gt;(B); <span class=\"comment\">// 不安全</span></span><br></pre></td></tr></table></figure>\n<p>为什么不安全？   </p>\n<p>D指向本质上还是B的对象模型，D指向的内存模型中可能存在B没有的成员变量。如果 <code>D-&gt;foo()</code> 中使用了 <code>D</code> 的成员变量，那么这个函数调用就是不安全的。因此，向下转换是安全的。</p>\n</li>\n</ul>\n</li>\n<li><p><code>static_cast</code> 还可以在左值和右值之间显示地转换。虽然不能隐式地将左值转换为右值，但是可以使用<code>static_cast</code>显示地将左值转换为右值。</p>\n</li>\n<li>基本数据类型转换: <code>enum</code>, <code>int</code>, <code>char</code>, <code>float</code>等。安全性问题由开发者来保证。</li>\n<li><p>把空指针转换成目标类型的空指针  </p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* iptr = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>*&gt;(::<span class=\"built_in\">malloc</span>(sizoef(<span class=\"keyword\">int</span>)));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把任何类型的表达式转换成void类型：<code>static_cast&lt;void&gt;(iptr)</code></p>\n</li>\n<li><code>static_cast</code> 不能去掉类型的<code>const、volitale</code>属性(用<code>const_cast</code>)</li>\n<li>隐式转换都建议使用 <code>static_cast</code> 进行标明和替换</li>\n</ul>\n<h4 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a><em>dynamic_cast</em></h4><p>专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 nullptr 指针。  </p>\n<p>使用特点：　　</p>\n<ul>\n<li><p>基类必须要有虚函数，因为<code>dynamic_cast</code>是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数，才会有虚函数表　　</p>\n</li>\n<li><p>对于下行转换，<code>dynamic_cast</code>是安全的（当类型不一致时，转换过来的是空指针），而<code>static_cast</code>是不安全的（当类型不一致时，转换过来的是错误意义的指针，可能造成踩内存，非法访问等各种问题), <code>reinterpreter_cast</code> 下行转换是可以转换，但是不安全。　</p>\n</li>\n<li><p>相同基类不同子类之间的交叉转换，转换结果是是 nullptr</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span> </span>&#123; &#125; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Drived</span> :</span> <span class=\"keyword\">public</span> base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Base     *Bptr = <span class=\"keyword\">new</span> Drived()；<span class=\"comment\">//语句0</span></span><br><span class=\"line\">Derived *Dptr1 = <span class=\"keyword\">static_cast</span>&lt;Derived*&gt;(Bptr);  <span class=\"comment\">//语句1；</span></span><br><span class=\"line\">Derived *Dptr2 = <span class=\"keyword\">dynamic_cast</span>&lt;Derived*&gt;(Bptr); <span class=\"comment\">//语句2；</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此时语句1和语句2都是安全的，因为此时 <code>Bptr</code> 确实是指向的派生类的内存模型，所以两个类型转换都是安全的。<code>Dptr1</code> 和 <code>Dptr2</code> 可以尽情访问 <code>Drived</code> 类中的成员，绝对不会出问题。但是如果此时语句0更改为如下表达：<br>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base* Bptr = <span class=\"keyword\">new</span> Base(); `</span><br></pre></td></tr></table></figure></p>\n<p>  那么 <code>Bptr</code> 指向的是<code>Base</code>对象内存模型。因此语句1是不安全的，因为如果访问子类的数据成员，其行为将是未定义。而语句2返回的是 <code>nullptr</code>，更加直观的告诉用户不安全。</p>\n<h4 id=\"reinterpreter-cast\"><a href=\"#reinterpreter-cast\" class=\"headerlink\" title=\"reinterpreter_cast\"></a><em>reinterpreter_cast</em></h4><p>用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时执行的是<strong>逐 <code>byte</code> 复制</strong>的操作。</p>\n<ul>\n<li><code>reinterpret_cast</code>是从底层对数据仅仅进行重新解释，但没有进行二进制的转换，依赖具体的平台，可移植性差；　　</li>\n<li><code>reinterpret_cast</code>可以将整型转换为指针，也可以把指针转换为数组；　　</li>\n<li><code>reinterpret_cast</code>可以在指针和引用里进行肆无忌惮的转换；</li>\n</ul>\n<h4 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a><em>const_cast</em></h4><ul>\n<li>常量指针转换为非常量指针， 并且仍然指向原来的对象　　</li>\n<li>常量引用被转换为非常量引用，并且仍然指向原来的对象</li>\n</ul>\n<h3 id=\"自己实现一个非侵入式的智能指针\"><a href=\"#自己实现一个非侵入式的智能指针\" class=\"headerlink\" title=\"自己实现一个非侵入式的智能指针\"></a>自己实现一个非侵入式的智能指针</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RAII 技术封装  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefCount</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">      RefCount() : reference_&#123;<span class=\"number\">0</span>&#125; </span><br><span class=\"line\">      &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      ~RefCount() &#123; </span><br><span class=\"line\">          <span class=\"keyword\">this</span>-&gt;decrementRef();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">IncrementRef</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          ++reference_;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">decrementRef</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (--reference_ == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">int64_t</span> use_count() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> reference_;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int64_t</span>&gt; reference_;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedPtr</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      SharedPtr() : ptr_(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">SharedPtr</span><span class=\"params\">(T* ptr)</span> </span></span><br><span class=\"line\">      : ptr_(ptr),</span><br><span class=\"line\">        ref_(<span class=\"keyword\">new</span> RefCount)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ref_) ref_-&gt;IncrementRef();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      SharedPtr(<span class=\"keyword\">const</span> SharedPtr&amp; other) </span><br><span class=\"line\">      : ptr_(other.ptr_),</span><br><span class=\"line\">        ref_(other.ref_)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ref_) ref_-&gt;IncrementRef();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      SharedPtr(SharedPtr&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">          ptr_ = other.ptr_;</span><br><span class=\"line\">          ref_ = other.ref_;</span><br><span class=\"line\">          other.ptr_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">          other.ref_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      SharedPtr&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> SharedPtr&amp; other) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other || *<span class=\"keyword\">this</span> == other) </span><br><span class=\"line\">              <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">          reset();</span><br><span class=\"line\">          ptr_ = other.ptr_;</span><br><span class=\"line\">          ref_ = other.ref_;</span><br><span class=\"line\">          ref_-&gt;IncrementRef();</span><br><span class=\"line\">          <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      SharedPtr&amp; <span class=\"keyword\">operator</span>=(SharedPtr&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other || *<span class=\"keyword\">this</span> == other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">          reset();</span><br><span class=\"line\">          ptr_ = other.ptr_;</span><br><span class=\"line\">          ref_ = other.ref_;</span><br><span class=\"line\">          </span><br><span class=\"line\">          other.ptr_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">          other.ref_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      ~SharedPtr() </span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ref_) <span class=\"keyword\">this</span>-&gt;decrementRef(); </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      T&amp; <span class=\"keyword\">operator</span>*()  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr_; &#125;</span><br><span class=\"line\">      T* <span class=\"keyword\">operator</span>-&gt;() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> ptr_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"keyword\">operator</span> <span class=\"title\">bool</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> !!ptr_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\">T* <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> ptr_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ptr_) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">this</span>-&gt;decrementRef();</span><br><span class=\"line\">              <span class=\"comment\">// ptr_ = nullptr;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decrementRef</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">          <span class=\"keyword\">if</span>(ref_ &amp;&amp; ptr_) &#123; </span><br><span class=\"line\">              <span class=\"keyword\">if</span>(ref_-&gt;decrementRef()) &#123; </span><br><span class=\"line\">                  <span class=\"keyword\">delete</span> ptr_;</span><br><span class=\"line\">                  ptr_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">int64_t</span> use_count() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>  ref_-&gt;use_count();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">unique</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> use_count() == <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(SharedPtr &amp; other)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::swap(ptr_, other.ptr_);</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::swap(ref_, other.ref_);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">friend</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(SharedPtr <span class=\"keyword\">const</span>&amp; lhs, SharedPtr <span class=\"keyword\">const</span>&amp; rhs) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> lhs.ptr_ == rhs.ptr_;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">friend</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(SharedPtr <span class=\"keyword\">const</span>&amp; lhs, SharedPtr <span class=\"keyword\">const</span>&amp; rhs) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> lhs.ptr_ != rhs.ptr_;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">friend</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(SharedPtr <span class=\"keyword\">const</span>&amp; lhs, SharedPtr <span class=\"keyword\">const</span>&amp; rhs) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> lhs.ptr_ &lt; rhs.ptr_;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      T*        ptr_; </span><br><span class=\"line\">      RefCount* ref_;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">      SharedPtr&lt;<span class=\"keyword\">int</span>&gt; iptr (<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>);</span><br><span class=\"line\">      SharedPtr&lt;<span class=\"keyword\">int</span>&gt; iptr2(iptr);</span><br><span class=\"line\">      SharedPtr&lt;<span class=\"keyword\">int</span>&gt; iptr3(<span class=\"built_in\">std</span>::move(iptr));</span><br><span class=\"line\">      SharedPtr&lt;<span class=\"keyword\">int</span>&gt; iptr4 = iptr2;</span><br><span class=\"line\">      SharedPtr&lt;<span class=\"keyword\">int</span>&gt; iptr5 = <span class=\"built_in\">std</span>::move(iptr3);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;iptr5.use_count()&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">// 3</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"迭代器失效的场景\"><a href=\"#迭代器失效的场景\" class=\"headerlink\" title=\"迭代器失效的场景\"></a>迭代器失效的场景</h3><ul>\n<li><p>序列式容器<br>  序列式容器会失效的原因是因为其存储都是连续的，因此删除或者插入一个元素都有可能导致其他元素的迭代器失效。</p>\n<ul>\n<li><p><code>vector</code></p>\n<ul>\n<li>在遍历时，执行<code>erase</code>会导致删除节点之后的全部失效</li>\n<li>在<code>push_back</code>时，之前的<code>end()</code>操作得到的迭代器失效<ul>\n<li><code>insert/push_back</code>导致<code>capacity()</code>改变，那么之前的<code>first()/end()</code>得到的迭代器会失效</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>insert</code>一个元素，如果空间没有分配，那么插入节点之前的迭代器位置有效，之后的失效。</p>\n<p>  简而言之：导致内存分配的全会失效，导致元素移动的会局部失效</p>\n</li>\n<li><code>deque</code><ul>\n<li>在首尾添加元素，会导致迭代器失效，但是指针、引用不会失效</li>\n<li>其余位置插入元素，迭代器、指针、引用都是失效</li>\n<li>在首尾之外的位置删除元素，那么其他位置的迭代器都失效</li>\n<li>在首尾删除元素，只是会导致被指向的删除元素的迭代器失效</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>关联式容器<ul>\n<li>基于哈希表实现的<em>std::unordered_map/std::set</em> 导致迭代器失效，一般是插入元素导致 <em>reshash</em> 产生，如果是删除只是会导致被删除元素的迭代器失效。<br><img src=\"image/unorder_map非法化.jpg\" alt=\"case\"><h3 id=\"std-unordered-map\"><a href=\"#std-unordered-map\" class=\"headerlink\" title=\"std::unordered_map\"></a><em>std::unordered_map</em></h3><h4 id=\"底层实现及其解决-hash-冲突方法\"><a href=\"#底层实现及其解决-hash-冲突方法\" class=\"headerlink\" title=\"底层实现及其解决 hash 冲突方法\"></a>底层实现及其解决 <em>hash</em> 冲突方法</h4></li>\n</ul>\n</li>\n</ul>\n<p><em>std::unorder_map</em>  解决冲突方式是 <strong>拉链法</strong>（数组的每个元素都连着一个链表？）：将所有产生冲突的关键字所对应的数据全部存储在同一个线性链表中（<em>bucket</em>）。这个方法解决数据存储位置发生冲突的哈希表，整个存储结构如图 1 所示。</p>\n<div align=\"center\"><img src=\"./image/hashtable.gif\"> </div>\n\n<p>  其中 p_i表示存储的各个键值对。</p>\n<p>当使用无序容器存储键值对时，会先申请一整块连续的存储空间，但此空间并不用来直接存储键值对，而是存储各个链表的头指针，各键值对真正的存储位置是各个链表的节点。<code>STL</code> 标准库默认选用<code>vector</code>容器存储各个链表的头指针。<code>STL</code> 标准库中，将图 1 中的各个链表称为桶 <em>bucket</em>，每个桶都有自己的编号（从 0 开始）。当有新键值对存储到无序容器中时，整个存储过程分为如下几步：</p>\n<ul>\n<li>将该键值对中 <code>key</code> 的值带入设计好的哈希函数，会得到一个哈希值: <em>H = hash(key)</em>；</li>\n<li>将 H 和无序容器拥有桶的数量 n 做整除运算（即<code>H % n</code>），该结果即表示应将此键值对存储到的桶的编号；</li>\n<li><p>建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上</p>\n<p><strong>其他解决冲突的方法</strong></p>\n</li>\n<li>开放地址法：<script type=\"math/tex; mode=display\">\nH =(hash(key) + d)  \\%  m</script></li>\n</ul>\n<pre><code> 其中`m`是哈希表的表长，`d`是一个增量，当产生冲突时，选择以下三种方法一种获取d的值，然后计算，直到计算出的*hash* 值不存在冲突。\n\n+  线性探测法：d = 1,2,3,...\n+  二次探测法：d = 12,-12, 22, -22...\n+  伪随机数探测法: d = 伪随机数\n</code></pre><ul>\n<li>再哈希法<code>rehasp</code><br>当通过哈希函数求得的哈希地址同其他关键字产生冲突时，使用另一个哈希函数计算，直到冲突不再发生</li>\n</ul>\n<h4 id=\"rehashp\"><a href=\"#rehashp\" class=\"headerlink\" title=\"rehashp\"></a>rehashp</h4><p>上述的拉链法解决了哈希冲突的问题，但是当插入元素很多，产生了严重哈希冲突时，就会导致某个链表长度越来越长，进而导致哈希表的查找就会退化为链表，效率降低为O(n)的时间复杂度。</p>\n<p> 哈希表存储结构还有一个重要的属性，称为负载因子<code>load factor</code>，用于衡量容器存储键值对的空/满程度：即负载因子越大，意味着容器越满，即各链表中挂载着越多的键值对，这无疑会降低容器查找目标键值对的效率；反之，负载因子越小，容器肯定越空，但并不一定各个链表中挂载的键值对就越少。</p>\n<blockquote>\n<p> 负载因子的计算方法为：负载因子 = 容器存储的总键值对 / 桶数</p>\n</blockquote>\n<p><code>STL</code> 中默认情况下，无序容器的最大负载因子为 1.0。如果操作无序容器过程中，使得最大复杂因子超过了默认值，则容器会自动增加桶数，并重新进行哈希，以此来减小负载因子的值。需要注意的是，此过程会导致容器迭代器失效，但指向单个键值对的引用或者指针仍然有效。</p>\n<p>因此当插入元素过多，使得负载因子的大于1.0，就会产生<em>rehash</em>行为，来改善即将下降的效率。</p>\n<p> <strong>STL中的 <em>unordered_map</em> 的 <em>rehash</em> 策略</strong><br>一下代码节选自g++的<em>STL</em>库：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// __n_bkt is current bucket count, __n_elt is current element count,</span></span><br><span class=\"line\"><span class=\"comment\">// and __n_ins is number of elements to be inserted.  Do we need to</span></span><br><span class=\"line\"><span class=\"comment\">// increase bucket count?  If so, return make_pair(true, n), where n</span></span><br><span class=\"line\"><span class=\"comment\">// is the new bucket count.  If not, return make_pair(false, 0).</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::pair&lt;<span class=\"keyword\">bool</span>, <span class=\"keyword\">size_t</span>&gt;</span><br><span class=\"line\"> _M_need_rehash(<span class=\"keyword\">size_t</span> __n_bkt, <span class=\"keyword\">size_t</span> __n_elt, <span class=\"keyword\">size_t</span> __n_ins) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__n_elt + __n_ins &gt;= _M_next_resize) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">double</span> __min_bkts = (__n_elt + __n_ins) / (<span class=\"keyword\">long</span> <span class=\"keyword\">double</span>)_M_max_load_factor;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__min_bkts &gt;= __n_bkt)</span><br><span class=\"line\">      <span class=\"comment\">//  这个是需要rehash 时返回的策略</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_pair(<span class=\"literal\">true</span>, </span><br><span class=\"line\">                            _M_next_bkt(<span class=\"built_in\">std</span>::max&lt;<span class=\"keyword\">size_t</span>&gt;(__builtin_floor(__min_bkts) + <span class=\"number\">1</span>,</span><br><span class=\"line\">                                                         __n_bkt * _S_growth_factor)));</span><br><span class=\"line\"></span><br><span class=\"line\">        _M_next_resize  = __builtin_floor(__n_bkt * (<span class=\"keyword\">long</span> <span class=\"keyword\">double</span>)_M_max_load_factor);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_pair(<span class=\"literal\">false</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_pair(<span class=\"literal\">false</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _M_next_bkt(<span class=\"keyword\">size_t</span> __n) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> __max_width = <span class=\"built_in\">std</span>::min&lt;<span class=\"keyword\">size_t</span>&gt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">size_t</span>), <span class=\"number\">8</span>);           <span class=\"comment\">// 8 个字节</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> __max_bkt   = <span class=\"keyword\">size_t</span>(<span class=\"number\">1</span>) &lt;&lt; (__max_width * __CHAR_BIT__ - <span class=\"number\">1</span>); <span class=\"comment\">// 2 ^ 63</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> __res           = __clp2(__n);        <span class=\"comment\">// 计算大于等于 n 的最小的2的幂</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__res == __n) __res &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__res == <span class=\"number\">0</span>) __res = __max_bkt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Set next resize to the max value so that we never try to rehash again</span></span><br><span class=\"line\">  <span class=\"comment\">// as we already reach the biggest possible bucket number.</span></span><br><span class=\"line\">  <span class=\"comment\">// Note that it might result in max_load_factor not being respected.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__res == __max_bkt)</span><br><span class=\"line\">    _M_next_resize = <span class=\"keyword\">size_t</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    _M_next_resize = __builtin_ceil(__res * (<span class=\"keyword\">long</span> <span class=\"keyword\">double</span>)_M_max_load_factor);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> __res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，在这个类的前面有定义：</p>\n<blockquote>\n<ul>\n<li><strong><em>_M_max_load_factor</em></strong> 初始化为 1.0</li>\n<li><strong><em>static const size_t _S_growth_factor = 2;</em></strong></li>\n</ul>\n</blockquote>\n<p>整个扩容的策略大致是按照2倍的策略增长，但是并不严格按照。在MSVC中按照的是8倍的扩充策略。</p>\n<h4 id=\"多线程下的-std-unordered-map\"><a href=\"#多线程下的-std-unordered-map\" class=\"headerlink\" title=\"多线程下的 std::unordered_map\"></a>多线程下的 <em>std::unordered_map</em></h4><p><code>STL</code>中的 哈希表 是线程不安全的（其实 <code>STL</code> 库都是线程不安全的）。 比如两个线程同时向 <em>std::unordered_map</em> 中插入数据，当发生<em>rehash</em>时，如果不加锁，可能导致两个线程都会产生<em>rehash</em>。</p>\n<p><strong>如何优化 多线程读写操作？这里要借鉴下java的分段锁。</strong></p>\n<h4 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h4><ul>\n<li><a href=\"http://c.biancheng.net/view/3437.html\" target=\"_blank\" rel=\"noopener\">hash</a></li>\n<li><a href=\"http://c.biancheng.net/view/7235.html\" target=\"_blank\" rel=\"noopener\">std::unordered_map底层原理</a></li>\n<li>g++ 中 <em>std::unordered_map</em> 的实现</li>\n</ul>\n<h3 id=\"map-与-红黑树\"><a href=\"#map-与-红黑树\" class=\"headerlink\" title=\"map 与 红黑树.\"></a><em>map</em> 与 红黑树.</h3><ul>\n<li><p>红黑树的规则</p>\n<ol>\n<li>树根始终为黑色</li>\n<li>外部节点均为黑色</li>\n<li>其余节点若为红色，则器孩子节点必为黑色</li>\n<li>从任一外部外部节点到根节点的沿途，黑色节点的数目相等</li>\n</ol>\n<p>条件1和2说明，红色节点均是内部节点，其父节点及左、右孩子节点必然存在；另外条件3说明，红节点之父必为黑色，因此树中任一通路都不含相邻的红节点</p>\n</li>\n<li><p>红黑树的效率为什么比AVL树高?如果只有查询操作哪种树的效率高?</p>\n<p>红黑树的效率高,是因为不需要像<code>AVL</code>树那样,为了维护高度平衡性,而不断地动态调整以维护左右子树高度差不超过1.红黑树降低了对平衡度的要求,以减少每次插入/删除操作时的动态调整次数.但是就查询效率而言,是不如<code>AVL</code>树的.</p>\n</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h4 id=\"如何进行性能排查？找出性能瓶颈？性能测试？有什么工具：\"><a href=\"#如何进行性能排查？找出性能瓶颈？性能测试？有什么工具：\" class=\"headerlink\" title=\"如何进行性能排查？找出性能瓶颈？性能测试？有什么工具：\"></a>如何进行性能排查？找出性能瓶颈？性能测试？有什么工具：</h4><ul>\n<li><em>valgrind</em> :可以查找代码问题<h4 id=\"GDB学习参考链接\"><a href=\"#GDB学习参考链接\" class=\"headerlink\" title=\"GDB学习参考链接\"></a>GDB学习参考链接</h4></li>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/2879\" target=\"_blank\" rel=\"noopener\">GDB学习1</a></li>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/2880\" target=\"_blank\" rel=\"noopener\">GDB学习2</a></li>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/2881\" target=\"_blank\" rel=\"noopener\">GDB学习3</a></li>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/2882\" target=\"_blank\" rel=\"noopener\">GDB学习4</a></li>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/2883\" target=\"_blank\" rel=\"noopener\">GDB学习5</a></li>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/2884\" target=\"_blank\" rel=\"noopener\">GDB学习6</a></li>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/2885\" target=\"_blank\" rel=\"noopener\">GDB学习7</a></li>\n</ul>\n","slug":"Cpp","updated":"2020-08-11T13:33:03.365Z","comments":true,"link":"","permalink":"/2020/08/11/Cpp/","excerpt":"","categories":[],"tags":[]},{"title":"C++_boost_library","date":"2020-07-28T18:15:03.000Z","path":"2020/07/29/C-boost-library/","text":"C++ boost library 使用指北目前版本：1.73.0 Window boost official getting startedOfficial document Signals2 解读观察者模式代码实现：","raw":"---\ntitle: C++_boost_library\ndate: 2020-07-29 02:15:03\ntags:\n    - C++\n    - boost\n---\n\n# C++ boost library 使用指北\n\n目前版本：1.73.0  \n\n[Window boost official getting started](https://www.boost.org/doc/libs/1_73_0/more/getting_started/windows.html)  \n[Official document](https://www.boost.org/doc/libs/1_73_0)  \n\n## Signals2 解读\n\n观察者模式代码实现：\n\n","content":"<h1 id=\"C-boost-library-使用指北\"><a href=\"#C-boost-library-使用指北\" class=\"headerlink\" title=\"C++ boost library 使用指北\"></a>C++ boost library 使用指北</h1><p>目前版本：1.73.0  </p>\n<p><a href=\"https://www.boost.org/doc/libs/1_73_0/more/getting_started/windows.html\" target=\"_blank\" rel=\"noopener\">Window boost official getting started</a><br><a href=\"https://www.boost.org/doc/libs/1_73_0\" target=\"_blank\" rel=\"noopener\">Official document</a>  </p>\n<h2 id=\"Signals2-解读\"><a href=\"#Signals2-解读\" class=\"headerlink\" title=\"Signals2 解读\"></a>Signals2 解读</h2><p>观察者模式代码实现：</p>\n","slug":"C-boost-library","updated":"2020-08-06T07:05:28.078Z","comments":true,"link":"","permalink":"/2020/07/29/C-boost-library/","excerpt":"","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"boost","slug":"boost","permalink":"/tags/boost/"}]},{"title":"stl-implement","date":"2020-07-06T03:13:02.000Z","path":"2020/07/06/stl-implement/","text":"自己实现部分STL（Standard Template Library）容器部分List智能指针SharedPtr ver11234567891011121314151617181920// mysharedptr.h#pragma onceusing namespace std;template&lt;class T&gt;class MySharedPtr&#123;public: MySharedPtr(T* _p); MySharedPtr(const MySharedPtr&amp; r); MySharedPtr&amp; operator=(const MySharedPtr&amp; r); T operator*(); ~MySharedPtr(); int use_count();private: T* p; int* count;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// mysharedptr.cpp#include \"mysharedptr.h\"#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;MySharedPtr&lt;T&gt;::MySharedPtr(T* _p):p(_p)&#123; cout &lt;&lt; \"constructor\" &lt;&lt; endl; count = new int(0); if (p != nullptr) *count = 1;&#125;template MySharedPtr&lt;int&gt;::MySharedPtr(int* _p); // declaration和definition如果不放在一起的写法，这里只用到了构造和析构，如果用别的方法也应该加上这个声明template&lt;class T&gt;MySharedPtr&lt;T&gt;::MySharedPtr(const MySharedPtr&amp; r) &#123; cout &lt;&lt; \"copy constructor\" &lt;&lt; endl; p = r.p; count = r.count; *r.count++;&#125;template&lt;class T&gt;MySharedPtr&lt;T&gt;&amp; MySharedPtr&lt;T&gt;::operator=(const MySharedPtr&amp; r) &#123; if (-- * count == 0) &#123; delete p; delete count; &#125; p = r.p; count = r.count; *r.count++; return *this;&#125;template&lt;class T&gt;T MySharedPtr&lt;T&gt;::operator*() &#123; return *p;&#125;template&lt;class T&gt;MySharedPtr&lt;T&gt;::~MySharedPtr()&#123; if (-- * count == 0) &#123; delete p; delete count; &#125;&#125;template MySharedPtr&lt;int&gt;::~MySharedPtr(); // declaration和definition如果不放在一起的写法template&lt;class T&gt;int MySharedPtr&lt;T&gt;::use_count() &#123; return *count;&#125; 类模板的声明和定义应该放在一起，这里是不放在一起的写法 SharedPtr ver2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172template&lt;class T&gt;class SharedPtr&#123;public: SharedPtr(); SharedPtr(T* p); SharedPtr(SharedPtr&amp; sp); ~SharedPtr(); SharedPtr&amp; operator= (const SharedPtr&amp; sp); int use_count();private: T* p; int* refCount;&#125;;template&lt;class T&gt;SharedPtr&lt;T&gt;::SharedPtr():p(nullptr),refCount(new int(0))&#123;&#125;template&lt;class T&gt;SharedPtr&lt;T&gt;::SharedPtr(T* _p) : p(_p), refCount(new int(1))&#123;&#125;template&lt;class T&gt;SharedPtr&lt;T&gt;::SharedPtr(SharedPtr&amp; sp) : p(sp.p), refCount(&amp;(++*(sp.refCount)))&#123;&#125;template&lt;class T&gt;SharedPtr&lt;T&gt;::~SharedPtr()&#123; if (p &amp;&amp; --*refCount == 0) &#123; delete p; delete refCount; &#125;&#125;template&lt;class T&gt;SharedPtr&lt;T&gt;&amp; SharedPtr&lt;T&gt;::operator= (const SharedPtr&amp; other) &#123; if (this == &amp;other) return *this; ++* other.refCount; if (-- * refCount == 0) &#123; delete p; delete refCount; &#125; p = other.p; refCount = other.refCount; return *this;&#125;template&lt;class T&gt;int SharedPtr&lt;T&gt;::use_count()&#123; return *refCount;&#125;int main() &#123; int* p = new int(3); SharedPtr&lt;int&gt; sp(p); SharedPtr&lt;int&gt; ssp(p); SharedPtr&lt;int&gt; sssp(sp); cout &lt;&lt; sp.use_count() &lt;&lt; \" \" &lt;&lt; ssp.use_count() &lt;&lt; \" \" &lt;&lt; sssp.use_count() &lt;&lt; endl; // output: 2 1 2 return 0;&#125;","raw":"---\ntitle: stl-implement\ndate: 2020-07-06 11:13:02\ntags:\n    - stl\n    - C/C++\n---\n\n# 自己实现部分STL（Standard Template Library）\n\n## 容器部分\n\n### List\n\n## 智能指针\n\n### SharedPtr ver1\n\n``` C++\n// mysharedptr.h\n\n#pragma once\nusing namespace std;\n\ntemplate<class T>\nclass MySharedPtr\n{\npublic:\n\tMySharedPtr(T* _p);\n\tMySharedPtr(const MySharedPtr& r);\n\tMySharedPtr& operator=(const MySharedPtr& r);\n\tT operator*();\n\t~MySharedPtr();\n\tint use_count();\n\nprivate:\n\tT* p;\n\tint* count;\n};\n```\n\n``` C++\n// mysharedptr.cpp\n\n#include \"mysharedptr.h\"\n#include <iostream>\nusing namespace std;\n\ntemplate<class T>\nMySharedPtr<T>::MySharedPtr(T* _p):p(_p){\n\tcout << \"constructor\" << endl;\n\tcount = new int(0);\n\tif (p != nullptr)\n\t\t*count = 1;\n}\ntemplate MySharedPtr<int>::MySharedPtr(int* _p); // declaration和definition如果不放在一起的写法，这里只用到了构造和析构，如果用别的方法也应该加上这个声明\n\ntemplate<class T>\nMySharedPtr<T>::MySharedPtr(const MySharedPtr& r) {\n\tcout << \"copy constructor\" << endl;\n\tp = r.p;\n\tcount = r.count;\n\t*r.count++;\n}\n\ntemplate<class T>\nMySharedPtr<T>& MySharedPtr<T>::operator=(const MySharedPtr& r) {\n\tif (-- * count == 0) {\n\t\tdelete p;\n\t\tdelete count;\n\t}\n\tp = r.p;\n\tcount = r.count;\n\t*r.count++;\n\treturn *this;\n}\n\ntemplate<class T>\nT MySharedPtr<T>::operator*() {\n\treturn *p;\n}\n\ntemplate<class T>\nMySharedPtr<T>::~MySharedPtr(){\n\tif (-- * count == 0) {\n\t\tdelete p;\n\t\tdelete count;\n\t}\n}\n\ntemplate MySharedPtr<int>::~MySharedPtr(); // declaration和definition如果不放在一起的写法\n\ntemplate<class T>\nint MySharedPtr<T>::use_count() {\n\treturn *count;\n}\n```\n类模板的声明和定义应该放在一起，这里是不放在一起的写法\n\n\n### SharedPtr ver2\n\n``` C++\ntemplate<class T>\nclass SharedPtr\n{\npublic:\n\tSharedPtr();\n    SharedPtr(T* p);\n    SharedPtr(SharedPtr& sp);\n\t~SharedPtr();\n\n    SharedPtr& operator= (const SharedPtr& sp);\n    int use_count();\n\nprivate:\n    T* p;\n    int* refCount;\n};\n\ntemplate<class T>\nSharedPtr<T>::SharedPtr():p(nullptr),refCount(new int(0))\n{\n}\n\ntemplate<class T>\nSharedPtr<T>::SharedPtr(T* _p) : p(_p), refCount(new int(1))\n{\n}\n\ntemplate<class T>\nSharedPtr<T>::SharedPtr(SharedPtr& sp) : p(sp.p), refCount(&(++*(sp.refCount)))\n{\n}\n\ntemplate<class T>\nSharedPtr<T>::~SharedPtr()\n{\n    if (p && --*refCount == 0) {\n        delete p;\n        delete refCount;\n    }\n}\n\ntemplate<class T>\nSharedPtr<T>& SharedPtr<T>::operator= (const SharedPtr& other) {\n    if (this == &other)\n        return *this;\n\n    ++* other.refCount;\n    if (-- * refCount == 0) {\n        delete p;\n        delete refCount;\n    }\n\n    p = other.p;\n    refCount = other.refCount;\n    return *this;\n}\n\ntemplate<class T>\nint SharedPtr<T>::use_count(){\n    return *refCount;\n}\n\n\nint main() {\n    int* p = new int(3);\n    SharedPtr<int> sp(p);\n    SharedPtr<int> ssp(p);\n    SharedPtr<int> sssp(sp);\n    cout << sp.use_count() << \" \" << ssp.use_count() << \" \" << sssp.use_count() << endl;\n\t// output: 2 1 2\n    return 0;\n}\n\n```","content":"<h1 id=\"自己实现部分STL（Standard-Template-Library）\"><a href=\"#自己实现部分STL（Standard-Template-Library）\" class=\"headerlink\" title=\"自己实现部分STL（Standard Template Library）\"></a>自己实现部分STL（Standard Template Library）</h1><h2 id=\"容器部分\"><a href=\"#容器部分\" class=\"headerlink\" title=\"容器部分\"></a>容器部分</h2><h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><h3 id=\"SharedPtr-ver1\"><a href=\"#SharedPtr-ver1\" class=\"headerlink\" title=\"SharedPtr ver1\"></a>SharedPtr ver1</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mysharedptr.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">MySharedPtr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tMySharedPtr(T* _p);</span><br><span class=\"line\">\tMySharedPtr(<span class=\"keyword\">const</span> MySharedPtr&amp; r);</span><br><span class=\"line\">\tMySharedPtr&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> MySharedPtr&amp; r);</span><br><span class=\"line\">\tT <span class=\"keyword\">operator</span>*();</span><br><span class=\"line\">\t~MySharedPtr();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_count</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tT* p;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* count;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mysharedptr.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"mysharedptr.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">MySharedPtr</span>&lt;T&gt;:</span>:MySharedPtr(T* _p):p(_p)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"constructor\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tcount = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t*count = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> MySharedPtr&lt;<span class=\"keyword\">int</span>&gt;::MySharedPtr(<span class=\"keyword\">int</span>* _p); <span class=\"comment\">// declaration和definition如果不放在一起的写法，这里只用到了构造和析构，如果用别的方法也应该加上这个声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">MySharedPtr</span>&lt;T&gt;:</span>:MySharedPtr(<span class=\"keyword\">const</span> MySharedPtr&amp; r) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copy constructor\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tp = r.p;</span><br><span class=\"line\">\tcount = r.count;</span><br><span class=\"line\">\t*r.count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">MySharedPtr</span>&lt;T&gt;&amp; <span class=\"title\">MySharedPtr</span>&lt;T&gt;:</span>:<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> MySharedPtr&amp; r) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (-- * count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> count;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp = r.p;</span><br><span class=\"line\">\tcount = r.count;</span><br><span class=\"line\">\t*r.count++;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span> <span class=\"title\">MySharedPtr</span>&lt;T&gt;:</span>:<span class=\"keyword\">operator</span>*() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">MySharedPtr</span>&lt;T&gt;:</span>:~MySharedPtr()&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (-- * count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> count;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> MySharedPtr&lt;<span class=\"keyword\">int</span>&gt;::~MySharedPtr(); <span class=\"comment\">// declaration和definition如果不放在一起的写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">int</span> <span class=\"title\">MySharedPtr</span>&lt;T&gt;:</span>:use_count() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类模板的声明和定义应该放在一起，这里是不放在一起的写法</p>\n<h3 id=\"SharedPtr-ver2\"><a href=\"#SharedPtr-ver2\" class=\"headerlink\" title=\"SharedPtr ver2\"></a>SharedPtr ver2</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">SharedPtr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tSharedPtr();</span><br><span class=\"line\">    SharedPtr(T* p);</span><br><span class=\"line\">    SharedPtr(SharedPtr&amp; sp);</span><br><span class=\"line\">\t~SharedPtr();</span><br><span class=\"line\"></span><br><span class=\"line\">    SharedPtr&amp; <span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> SharedPtr&amp; sp);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_count</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* refCount;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">SharedPtr</span>&lt;T&gt;:</span>:SharedPtr():p(<span class=\"literal\">nullptr</span>),refCount(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">SharedPtr</span>&lt;T&gt;:</span>:SharedPtr(T* _p) : p(_p), refCount(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">SharedPtr</span>&lt;T&gt;:</span>:SharedPtr(SharedPtr&amp; sp) : p(sp.p), refCount(&amp;(++*(sp.refCount)))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">SharedPtr</span>&lt;T&gt;:</span>:~SharedPtr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &amp;&amp; --*refCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> refCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">SharedPtr</span>&lt;T&gt;&amp; <span class=\"title\">SharedPtr</span>&lt;T&gt;:</span>:<span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> SharedPtr&amp; other) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ++* other.refCount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (-- * refCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> refCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = other.p;</span><br><span class=\"line\">    refCount = other.refCount;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">int</span> <span class=\"title\">SharedPtr</span>&lt;T&gt;:</span>:use_count()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *refCount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    SharedPtr&lt;<span class=\"keyword\">int</span>&gt; sp(p);</span><br><span class=\"line\">    SharedPtr&lt;<span class=\"keyword\">int</span>&gt; ssp(p);</span><br><span class=\"line\">    SharedPtr&lt;<span class=\"keyword\">int</span>&gt; sssp(sp);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; ssp.use_count() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; sssp.use_count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// output: 2 1 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","slug":"stl-implement","updated":"2020-08-06T07:07:42.470Z","comments":true,"link":"","permalink":"/2020/07/06/stl-implement/","excerpt":"","categories":[],"tags":[{"name":"stl","slug":"stl","permalink":"/tags/stl/"},{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}]},{"title":"C++中的设计模式","date":"2020-06-14T07:39:46.000Z","path":"2020/06/14/C-Singleton/","text":"1.单例模式下面的代码为C++中单例模式的实现，需要注意的是instance的初始化，这是因为类的成员变量在使用前必须先初始化。懒汉模式： 123456789101112131415161718192021222324252627class Singleton &#123;private: static Singleton* instance; Singleton() &#123;&#125;;public: static Singleton* GetInstance(); void func();&#125;;Singleton* Singleton::GetInstance() &#123; if (!instance) &#123; instance = new Singleton(); &#125; return instance;&#125;void Singleton::func() &#123; cout &lt;&lt; \"hello\" &lt;&lt; endl;&#125;Singleton* Singleton::instance = nullptr; // 记得初始化int main() &#123; Singleton* ins = Singleton::GetInstance(); ins-&gt;func(); return 0;&#125; 为了避免多线程创建出多个instance实例（C++的new非线程安全），应使用饿汉模式：12345678910111213141516171819202122232425class Singleton &#123;private: static Singleton* instance; Singleton() &#123;&#125;;public: static Singleton* GetInstance(); void func();&#125;;Singleton* Singleton::GetInstance() &#123; // 不再需要判空创建 return instance;&#125;void Singleton::func() &#123; cout &lt;&lt; \"hello\" &lt;&lt; endl;&#125;Singleton* Singleton::instance = new Singleton(); // 最开始就初始化实例int main() &#123; Singleton* ins = Singleton::GetInstance(); ins-&gt;func(); return 0;&#125;","raw":"---\ntitle: C++中的设计模式\ndate: 2020-06-14 15:39:46\ntags:\n    - 设计模式\n    - C++\n    - 单例模式\n---\n\n# 1.单例模式\n\n下面的代码为C++中单例模式的实现，需要注意的是instance的初始化，这是因为类的成员变量在使用前必须先初始化。\n懒汉模式：\n\n``` C++\nclass Singleton {\nprivate:\n\tstatic Singleton* instance;\n\tSingleton() {};\npublic:\n\tstatic Singleton* GetInstance();\n\tvoid func();\n};\n\nSingleton* Singleton::GetInstance() {\n\tif (!instance) {\n\t\tinstance = new Singleton();\n\t}\n\treturn instance;\n}\n\nvoid Singleton::func() {\n\tcout << \"hello\" << endl;\n}\n\nSingleton* Singleton::instance = nullptr; // 记得初始化\n\nint main() {\n\tSingleton* ins = Singleton::GetInstance();\n\tins->func();\n\treturn 0;\n}\n```\n\n为了避免多线程创建出多个instance实例（C++的new非线程安全），应使用饿汉模式：\n``` C++\nclass Singleton {\nprivate:\n\tstatic Singleton* instance;\n\tSingleton() {};\npublic:\n\tstatic Singleton* GetInstance();\n\tvoid func();\n};\n\nSingleton* Singleton::GetInstance() {\n    // 不再需要判空创建\n\treturn instance;\n}\n\nvoid Singleton::func() {\n\tcout << \"hello\" << endl;\n}\n\nSingleton* Singleton::instance = new Singleton(); // 最开始就初始化实例\n\nint main() {\n\tSingleton* ins = Singleton::GetInstance();\n\tins->func();\n\treturn 0;\n}\n```","content":"<h1 id=\"1-单例模式\"><a href=\"#1-单例模式\" class=\"headerlink\" title=\"1.单例模式\"></a>1.单例模式</h1><p>下面的代码为C++中单例模式的实现，需要注意的是instance的初始化，这是因为类的成员变量在使用前必须先初始化。<br>懒汉模式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> Singleton* instance;</span><br><span class=\"line\">\tSingleton() &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Singleton* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton* Singleton::GetInstance() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">\t\tinstance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Singleton::func() &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton* Singleton::instance = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 记得初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSingleton* ins = Singleton::GetInstance();</span><br><span class=\"line\">\tins-&gt;func();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了避免多线程创建出多个instance实例（C++的new非线程安全），应使用饿汉模式：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> Singleton* instance;</span><br><span class=\"line\">\tSingleton() &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Singleton* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton* Singleton::GetInstance() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不再需要判空创建</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Singleton::func() &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton* Singleton::instance = <span class=\"keyword\">new</span> Singleton(); <span class=\"comment\">// 最开始就初始化实例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSingleton* ins = Singleton::GetInstance();</span><br><span class=\"line\">\tins-&gt;func();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","slug":"C-Singleton","updated":"2020-06-14T07:51:34.632Z","comments":true,"link":"","permalink":"/2020/06/14/C-Singleton/","excerpt":"","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"/tags/单例模式/"}]},{"title":"Unity中的多线程与线程池应用","date":"2020-06-05T05:00:19.000Z","path":"2020/06/05/UnityMultiThreading/","text":"Part 1 Unity中的多线程 FileStream读取本地文件 1234567891011byte[] buffer;void LoadFiletoBuffer()&#123; // 假如很卡 Thread.Sleep(3000); // 通过路径加载本地图片 FileStream fs = new FileStream(&quot;C:\\\\Users\\\\Administrator\\\\Downloads\\\\pic.jpg&quot;, FileMode.Open); buffer = new byte[fs.Length]; fs.Read(buffer, 0, buffer.Length); fs.Close();&#125; buffer—&gt;Unity texture2d—&gt;Unity sprite，使用UnityEngine中组件的动作必须在主线程完成，所以这段逻辑不能放到LoadFiletoBuffer中这里使用协程的目的是异步（在buffer加载进来之后）创建texture以及sprite 123456789101112131415161718IEnumerator OnLoad()&#123; while (buffer == null) &#123; yield return 0; &#125; Debug.Log(&quot;load tex&quot;); Texture2D tex = new Texture2D(2, 2); var iSLoad = tex.LoadImage(buffer); tex.Apply(); if (!iSLoad) &#123; Debug.Log(&quot;Texture存在但生成Texture失败!&quot;); &#125; img.sprite = Sprite.Create(tex, new Rect(0, 0, 5939, 3341), Vector2.zero);&#125; 最外层接口，两种方法的区别在于load file这3000ms主线程是否卡死 12345678910111213141516/// &lt;summary&gt;/// 文件流加载图片/// &lt;/summary&gt;void FileStreamLoadTexture()&#123; // load file by sub thread Thread childThread = new Thread(new ThreadStart(LoadFiletoBuffer)); childThread.Start(); //// load file by main thread //LoadFiletoBuffer(); Debug.Log(&quot;start coroutine&quot;); StartCoroutine(&quot;OnLoad&quot;); Debug.Log(&quot;end coroutine&quot;);&#125; Part 2 线程池C# System.Threading.ThreadPool类提供了线程池的实现，都是静态方法，不需要实例化PS： CLR指公共语言运行时(Common Language Runtime)线程池初始化时是没有线程的，线程池里的线程的初始化与其他线程一样，但是在完成任务以后，该线程不会自行销毁，而是以挂起的状态返回到线程池。直到应用程序再次向线程池发出请求时，线程池里挂起的线程就会再度激活执行任务。 参考资料 12345678910111213141516171819202122/// &lt;summary&gt;/// 文件流加载图片/// &lt;/summary&gt;void FileStreamLoadTexture()&#123; //// load file by sub thread //Thread childThread = new Thread(new ThreadStart(LoadFiletoBuffer)); //childThread.Start(); // use thread pool ThreadPool.GetAvailableThreads(out int workerThreads, out int completionProtThreads); // 800 200；out/ref的区别：out不需要初始化 Debug.Log(&quot;Thread Pool1: &quot; + workerThreads + &quot; &quot; + completionProtThreads); ThreadPool.QueueUserWorkItem(new WaitCallback(LoadFiletoBuffer), null); //// load file by main thread //LoadFiletoBuffer(); Debug.Log(&quot;start coroutine&quot;); StartCoroutine(&quot;OnLoad&quot;); Debug.Log(&quot;end coroutine&quot;);&#125; part 3 C#中的async和await属于System.Threading.Task，async/await Task是C#中更先进的，也是微软大力推广的特性，我们在开发中可以尝试使用Task来替代Thread/ThreadPool，处理本地IO和网络IO任务是尽量使用async/await来提高任务执行效率。await后边是个异步方法，也就是说async自定义的异步方法中有一个或者多个await，每个await后边还是一个返回值为 Task\\（返回值为T类型） Task（没有返回值，但是可以查看异步调用的状态） void（调用完就不关心了，没有互动了）的异步方法 最底层这个异步方法往往来自BCL（C#的基础类库，例如WebClient.DownloadStringTaskAsync(url)） 123456789async Task&lt;int&gt; CountCharactersAsync(int id, string site)&#123; Console.WriteLine(&quot;starting countingcharacters&quot;); WebClient wc = new WebClient(); string result = await wc.DownloadStringTaskAsync(new Uri(site)); Console.WriteLine(&quot;countingcharacters completed&quot;); return result.Length;&#125; 20.3.5 Wait()/WaitAll()/WaitAny()20.10 BeginInvoke()和EndInvoke()——《C#图解教程》","raw":"---\ntitle: Unity中的多线程与线程池应用\ndate: 2020-06-05 13:00:19\ntags:\n    - Unity\n    - 多线程\n    - 线程池\n---\n\n# Part 1 Unity中的多线程\n\n* FileStream读取本地文件\n``` C#\nbyte[] buffer;\nvoid LoadFiletoBuffer()\n{\n    // 假如很卡\n    Thread.Sleep(3000);\n    // 通过路径加载本地图片\n    FileStream fs = new FileStream(\"C:\\\\Users\\\\Administrator\\\\Downloads\\\\pic.jpg\", FileMode.Open);\n    buffer = new byte[fs.Length];\n    fs.Read(buffer, 0, buffer.Length);\n    fs.Close();\n}\n```\n\n* buffer-->Unity texture2d-->Unity sprite，使用UnityEngine中组件的动作必须在主线程完成，所以这段逻辑不能放到LoadFiletoBuffer中\n这里使用协程的目的是异步（在buffer加载进来之后）创建texture以及sprite\n``` C#\nIEnumerator OnLoad()\n{\n    while (buffer == null)\n    {\n        yield return 0;\n    }\n    Debug.Log(\"load tex\");\n\n    Texture2D tex = new Texture2D(2, 2);\n    var iSLoad = tex.LoadImage(buffer);\n    tex.Apply();\n    if (!iSLoad)\n    {\n        Debug.Log(\"Texture存在但生成Texture失败!\");\n    }\n\n    img.sprite = Sprite.Create(tex, new Rect(0, 0, 5939, 3341), Vector2.zero);\n}\n```\n\n* 最外层接口，两种方法的区别在于load file这3000ms主线程是否卡死\n``` C#\n/// <summary>\n/// 文件流加载图片\n/// </summary>\nvoid FileStreamLoadTexture()\n{\n    // load file by sub thread\n    Thread childThread = new Thread(new ThreadStart(LoadFiletoBuffer));\n    childThread.Start();\n\n    //// load file by main thread\n    //LoadFiletoBuffer();\n\n    Debug.Log(\"start coroutine\");\n    StartCoroutine(\"OnLoad\");\n    Debug.Log(\"end coroutine\");\n}\n```\n\n# Part 2 线程池\n\nC# System.Threading.ThreadPool类提供了线程池的实现，都是静态方法，不需要实例化  \nPS： CLR指公共语言运行时(Common Language Runtime)  \n线程池初始化时是没有线程的，线程池里的线程的初始化与其他线程一样，但是在完成任务以后，该线程不会自行销毁，而是以挂起的状态返回到线程池。直到应用程序再次向线程池发出请求时，线程池里挂起的线程就会再度激活执行任务。  \n\n[参考资料](https://www.cnblogs.com/scmail81/archive/2018/08/19/9503266.html)\n\n``` C#\n/// <summary>\n/// 文件流加载图片\n/// </summary>\nvoid FileStreamLoadTexture()\n{\n    //// load file by sub thread\n    //Thread childThread = new Thread(new ThreadStart(LoadFiletoBuffer));\n    //childThread.Start();\n\n    // use thread pool\n    ThreadPool.GetAvailableThreads(out int workerThreads, out int completionProtThreads); // 800 200；out/ref的区别：out不需要初始化\n    Debug.Log(\"Thread Pool1: \" + workerThreads + \" \" + completionProtThreads);\n\n    ThreadPool.QueueUserWorkItem(new WaitCallback(LoadFiletoBuffer), null);\n\n    //// load file by main thread\n    //LoadFiletoBuffer();\n\n    Debug.Log(\"start coroutine\");\n    StartCoroutine(\"OnLoad\");\n    Debug.Log(\"end coroutine\");\n}\n```\n\n# part 3 C#中的async和await\n\n属于System.Threading.Task，async/await Task是C#中更先进的，也是微软大力推广的特性，我们在开发中可以尝试使用Task来替代Thread/ThreadPool，处理本地IO和网络IO任务是尽量使用async/await来提高任务执行效率。  \nawait后边是个异步方法，也就是说async自定义的异步方法中有一个或者多个await，每个await后边还是一个返回值为\n* Task\\<T>（返回值为T类型）\n* Task（没有返回值，但是可以查看异步调用的状态）\n* void（调用完就不关心了，没有互动了）的异步方法\n\n最底层这个异步方法往往来自BCL（C#的基础类库，例如WebClient.DownloadStringTaskAsync(url)）  \n\n``` C#\nasync Task<int> CountCharactersAsync(int id, string site){\n    Console.WriteLine(\"starting countingcharacters\");\n    WebClient wc = new WebClient();\n\n    string result = await wc.DownloadStringTaskAsync(new Uri(site));\n\n    Console.WriteLine(\"countingcharacters completed\");\n    return result.Length;\n}\n```\n\n20.3.5 Wait()/WaitAll()/WaitAny()  \n20.10 BeginInvoke()和EndInvoke()  \n——《C#图解教程》","content":"<h1 id=\"Part-1-Unity中的多线程\"><a href=\"#Part-1-Unity中的多线程\" class=\"headerlink\" title=\"Part 1 Unity中的多线程\"></a>Part 1 Unity中的多线程</h1><ul>\n<li><p>FileStream读取本地文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] buffer;</span><br><span class=\"line\">void LoadFiletoBuffer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 假如很卡</span><br><span class=\"line\">    Thread.Sleep(3000);</span><br><span class=\"line\">    // 通过路径加载本地图片</span><br><span class=\"line\">    FileStream fs = new FileStream(&quot;C:\\\\Users\\\\Administrator\\\\Downloads\\\\pic.jpg&quot;, FileMode.Open);</span><br><span class=\"line\">    buffer = new byte[fs.Length];</span><br><span class=\"line\">    fs.Read(buffer, 0, buffer.Length);</span><br><span class=\"line\">    fs.Close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>buffer—&gt;Unity texture2d—&gt;Unity sprite，使用UnityEngine中组件的动作必须在主线程完成，所以这段逻辑不能放到LoadFiletoBuffer中<br>这里使用协程的目的是异步（在buffer加载进来之后）创建texture以及sprite</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IEnumerator OnLoad()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (buffer == null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        yield return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Debug.Log(&quot;load tex&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Texture2D tex = new Texture2D(2, 2);</span><br><span class=\"line\">    var iSLoad = tex.LoadImage(buffer);</span><br><span class=\"line\">    tex.Apply();</span><br><span class=\"line\">    if (!iSLoad)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Log(&quot;Texture存在但生成Texture失败!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    img.sprite = Sprite.Create(tex, new Rect(0, 0, 5939, 3341), Vector2.zero);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最外层接口，两种方法的区别在于load file这3000ms主线程是否卡死</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 文件流加载图片</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">void FileStreamLoadTexture()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // load file by sub thread</span><br><span class=\"line\">    Thread childThread = new Thread(new ThreadStart(LoadFiletoBuffer));</span><br><span class=\"line\">    childThread.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">    //// load file by main thread</span><br><span class=\"line\">    //LoadFiletoBuffer();</span><br><span class=\"line\"></span><br><span class=\"line\">    Debug.Log(&quot;start coroutine&quot;);</span><br><span class=\"line\">    StartCoroutine(&quot;OnLoad&quot;);</span><br><span class=\"line\">    Debug.Log(&quot;end coroutine&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"Part-2-线程池\"><a href=\"#Part-2-线程池\" class=\"headerlink\" title=\"Part 2 线程池\"></a>Part 2 线程池</h1><p>C# System.Threading.ThreadPool类提供了线程池的实现，都是静态方法，不需要实例化<br>PS： CLR指公共语言运行时(Common Language Runtime)<br>线程池初始化时是没有线程的，线程池里的线程的初始化与其他线程一样，但是在完成任务以后，该线程不会自行销毁，而是以挂起的状态返回到线程池。直到应用程序再次向线程池发出请求时，线程池里挂起的线程就会再度激活执行任务。  </p>\n<p><a href=\"https://www.cnblogs.com/scmail81/archive/2018/08/19/9503266.html\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 文件流加载图片</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">void FileStreamLoadTexture()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //// load file by sub thread</span><br><span class=\"line\">    //Thread childThread = new Thread(new ThreadStart(LoadFiletoBuffer));</span><br><span class=\"line\">    //childThread.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">    // use thread pool</span><br><span class=\"line\">    ThreadPool.GetAvailableThreads(out int workerThreads, out int completionProtThreads); // 800 200；out/ref的区别：out不需要初始化</span><br><span class=\"line\">    Debug.Log(&quot;Thread Pool1: &quot; + workerThreads + &quot; &quot; + completionProtThreads);</span><br><span class=\"line\"></span><br><span class=\"line\">    ThreadPool.QueueUserWorkItem(new WaitCallback(LoadFiletoBuffer), null);</span><br><span class=\"line\"></span><br><span class=\"line\">    //// load file by main thread</span><br><span class=\"line\">    //LoadFiletoBuffer();</span><br><span class=\"line\"></span><br><span class=\"line\">    Debug.Log(&quot;start coroutine&quot;);</span><br><span class=\"line\">    StartCoroutine(&quot;OnLoad&quot;);</span><br><span class=\"line\">    Debug.Log(&quot;end coroutine&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"part-3-C-中的async和await\"><a href=\"#part-3-C-中的async和await\" class=\"headerlink\" title=\"part 3 C#中的async和await\"></a>part 3 C#中的async和await</h1><p>属于System.Threading.Task，async/await Task是C#中更先进的，也是微软大力推广的特性，我们在开发中可以尝试使用Task来替代Thread/ThreadPool，处理本地IO和网络IO任务是尽量使用async/await来提高任务执行效率。<br>await后边是个异步方法，也就是说async自定义的异步方法中有一个或者多个await，每个await后边还是一个返回值为</p>\n<ul>\n<li>Task\\<t>（返回值为T类型）</t></li>\n<li>Task（没有返回值，但是可以查看异步调用的状态）</li>\n<li>void（调用完就不关心了，没有互动了）的异步方法</li>\n</ul>\n<p>最底层这个异步方法往往来自BCL（C#的基础类库，例如WebClient.DownloadStringTaskAsync(url)）  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async Task&lt;int&gt; CountCharactersAsync(int id, string site)&#123;</span><br><span class=\"line\">    Console.WriteLine(&quot;starting countingcharacters&quot;);</span><br><span class=\"line\">    WebClient wc = new WebClient();</span><br><span class=\"line\"></span><br><span class=\"line\">    string result = await wc.DownloadStringTaskAsync(new Uri(site));</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine(&quot;countingcharacters completed&quot;);</span><br><span class=\"line\">    return result.Length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>20.3.5 Wait()/WaitAll()/WaitAny()<br>20.10 BeginInvoke()和EndInvoke()<br>——《C#图解教程》</p>\n","slug":"UnityMultiThreading","updated":"2020-06-28T09:11:21.882Z","comments":true,"link":"","permalink":"/2020/06/05/UnityMultiThreading/","excerpt":"","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"/tags/Unity/"},{"name":"多线程","slug":"多线程","permalink":"/tags/多线程/"},{"name":"线程池","slug":"线程池","permalink":"/tags/线程池/"}]},{"title":"可编程渲染管线","date":"2020-04-14T07:49:36.000Z","path":"2020/04/14/hardware3d/","text":"Hardware 3DCOM： framebuffer: 双重缓冲是一个画（用户操作），一个已经画好的传输给显示器做显示，一个称为front，另一个称为back buffer。还可以有多重缓冲，缓冲层数越多，会导致画面延迟加重，但是更加连贯顺滑。原因是有时候front没花完，显示器已经逐像素扫描完一个frame，显示器就得等front buffer。vsync：防tearing，就是等显示器一个frame完成再载入下一个buffer constant buffer: 用来存变换矩阵，目的是用shader控制图形旋转，而不是改变vertices的坐标 shader中对于matric的修饰词 row_major会降低速度 DirectX Math： SIMD(single instruction multiple data) depth buffer shares memory with stencil buffer(模板缓冲): masking like mirror,portals. depth buffer optimized for depth direct toolkit for loading texture会省掉很多工作，所以这里用了GDI+ hlsl intrinsic functions attenuation imGUI使用方法：根目录的header和source文件 + examples里的对应平台文件（例如dx11+win32的四个文件） 3D Fundamentalrasterization rule: left-top rule; 《Unity shader 入门精要》概念合集NDC与视锥体剪裁：视锥体剪裁在cpu中进行，gpu流水线中还有一次culling，是按NDC空间进行剪裁（超出-1到1就裁剪，dx的z-axis是0-1）。这两次剪裁功能相似，第一次的目的是减轻gpu负担。 模板测试（stencil test）：可以理解为深度测试中的深度这个概念有开发者人为设定。 blend（混合）/output merger early-z 数学相关点坐标：\\left[ \\begin{matrix} x \\\\ y \\\\ z \\\\ 1 \\end{matrix} \\right] （如果是行向量，下边变换矩阵要转置）方向矢量：\\left[ \\begin{matrix} x \\\\ y \\\\ z \\\\ 0 \\end{matrix} \\right]基础变换矩阵：\\left[ \\begin{matrix} M_{3*3} & t_{3*1} \\\\ 0_{1*3} & 1 \\end{matrix} \\right]之所以这样设置是为了使变换矩阵的计算结果正确；顶点变换中如果存在平移需要四维矩阵，方向矢量变换使用三维即可 M：旋转缩放；t：平移（如果坐标点或向量是行向量，t的位置要换到左下角） 复合变换依赖顺序，本质原因是矩阵乘法不满足交换律：$P{new} = M{translation} M{rotation} M{scale} P_{old}$ 执行顺序为从右到左，绝大多数情况按照缩放，旋转，平移的顺序 空间变换流程：模型空间-&gt;世界空间-&gt;观察（相机）空间-&gt;剪裁空间（视锥体剔除）-&gt;屏幕空间（剪裁空间转NDC转屏幕像素） 一般来说，模型空间到剪裁空间会合并为MVP矩阵（Model-View-Projection） 光照模型 BRDF（bidirectional reflection distribution function） BRDF经验模型（能量不守恒，简化的数学公式）： Lambert：反射强度不受角度影响，反射角度受平面影响 标准光照模型（Phong）：自发光，高光反射，漫反射，环境光（需要入射光，反射光，表面法线，视角方向） blinn-phong：与phong相比不需要计算反射方向，取而代之的是视角和入射光线的平均值归一化后的结果 基于物理的BRDF模型（判断条件：是否满足交换律，即光路可逆；是否能量守恒）： cook-torrance BRDF：微面元模型用来表示pbs（physical based shading）中的高光，D是法线分布函数，G是阴影遮蔽函数，F是菲涅尔反射函数 ward BRDF 实现细节： 漫反射符合兰伯特定律，即反射光线强度与表面法线和光源方向之间夹角的余弦值成正比 纹理映射纹理放大缩小的问题需要调整Filter Mode（Point,Bilinear,Trilinear）；缩小时最常使用mipmapping（多级渐远纹理技术）：典型的用空间换时间（多33%的空间） bump mapping（凹凸映射）：分为两种，高度纹理（height map）模拟表面位移（displacement），得到一个修改后的法线值，称之为高度映射；另一种是法线纹理（normal map），直接做法线映射 1.在切线空间下进行光照计算；2.在世界空间下计算，前者效率往往优于后者 albedo是tex2D（CG的函数，对纹理进行采样）的结果；ambient是环境光diffuse是漫反射specular是高光 法线纹理（normal map）可以使用DXT5nm的压缩格式，因为相比较普通图，法线纹理只有两个通道必不可少，第三个通道可以通过前两个推导出来，这种压缩方法可以减少内存占用 透明效果Alpha Test/Alpha Blending：透明度测试只有完全透明和完全不透两种可能；透明度混合可以实现半透明 半透物体是开启深度测试但是关闭深度写入的，这导致渲染顺序变得十分重要（因为关闭了深度写入）；应该渲染不透明物体之后再渲染半透明物体；如果都是半透明，按相机距离排序，从后往前渲染，开启深度测试，但是关闭深度写入 双面渲染：unity的Cull指令默认是Back，也就是背对相机的渲染图元不会被渲染 渲染路径更复杂的光照： 前向渲染：颜色缓冲区和深度缓冲区；unity的前向渲染有三种，逐像素处理（最强平行光和重要光源用这种方式），逐顶点处理，球谐函数（spherical harmonics）前向渲染的问题是，场景内有大量光源的情况下性能急剧下降，因为每个光源都要计算一次光照结果（一个光源一个pass） 延迟渲染：G-buffer（Geometry），包含两个pass，第一个使用深度缓冲计算哪些片元可见；第二个计算片元信息，即光照计算不支持抗锯齿；不能处理半透明；对硬件有要求MRT（multiple render targets）Unity的延迟渲染需要提供两个pass：第一个用于渲染G-buffer；第二个用于计算真正的光照模型 APIUnity shader中的矩阵是按行优先的，Unity脚本中有个Matrix4x4是按列优先 UnityRoot/Data/CGIncludes/ 里边有官方提供的.cginc文件，其中例如UnityCG.cginc十分值得学习 《Direct12 3D游戏开发实战》——龙书数学相关view transform矩阵，观察空间到世界空间的坐标变化矩阵为： W = \\left[ \\begin{matrix} u_{x} & u_{y} & u_{z} & 0 \\\\ v_{x} & v_{y} & v_{z} & 0 \\\\ w_{x} & w_{y} & w_{z} & 0 \\\\ Q_{x} & Q_{y} & Q_{z} & 1 \\end{matrix} \\right]其中，Q_{w} = (Q_{x},Q_{y},Q_{z},1)，u_{w} = (u_{x},u_{y},u_{z},0)，v_{w}还有w_{w}分别表示了观察空间中原点，x轴，y轴，z轴相对于世界空间的齐次坐标。相对的，世界空间到观察空间的变化矩阵为W^{-1}，世界矩阵可以分解为一个旋转矩阵和一个平移矩阵的乘积，即W=RT。 V=W^{-1}=(RT)^{-1}=T^{-1}R^{-1}=T^{-1}R^{T}= \\left[ \\begin{matrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ -Q_{x} & -Q_{y} & -Q_{z} & 1 \\end{matrix} \\right] \\left[ \\begin{matrix} u_{x} & u_{y} & u_{z} & 0 \\\\ v_{x} & v_{y} & v_{z} & 0 \\\\ w_{x} & w_{y} & w_{z} & 0 \\\\ 0 & 0 & 0 & 1 \\end{matrix} \\right] = \\left[ \\begin{matrix} u_{x} & u_{y} & u_{z} & 0 \\\\ v_{x} & v_{y} & v_{z} & 0 \\\\ w_{x} & w_{y} & w_{z} & 0 \\\\ -Q_{x} \\cdot u & -Q_{y} \\cdot v & -Q_{z} \\cdot w & 1 \\end{matrix} \\right]由此得到， V= \\left[ \\begin{matrix} u_{x} & u_{y} & u_{z} & 0 \\\\ v_{x} & v_{y} & v_{z} & 0 \\\\ w_{x} & w_{y} & w_{z} & 0 \\\\ -Q_{x} \\cdot u & -Q_{y} \\cdot v & -Q_{z} \\cdot w & 1 \\end{matrix} \\right]Unreal source code review","raw":"---\ntitle: 可编程渲染管线\ndate: 2020-04-14 15:49:36\nmathjax: true\ntags: \n    - Dx12\n    - WindowsApp\n    - COM\n    - Shader\n---\n\n# Hardware 3D\n\nCOM：\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Ut5zYcDKGwk\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\nframebuffer: 双重缓冲是一个画（用户操作），一个已经画好的传输给显示器做显示，一个称为front，另一个称为back buffer。  \n还可以有多重缓冲，缓冲层数越多，会导致画面延迟加重，但是更加连贯顺滑。原因是有时候front没花完，显示器已经逐像素扫描完一个frame，显示器就得等front buffer。  \nvsync：防tearing，就是等显示器一个frame完成再载入下一个buffer  \n\nconstant buffer: 用来存变换矩阵，目的是用shader控制图形旋转，而不是改变vertices的坐标  \n\nshader中对于matric的修饰词 row_major会降低速度  \n\nDirectX Math： SIMD(single instruction multiple data)  \n\ndepth buffer shares memory with stencil buffer(模板缓冲): masking like mirror,portals. depth buffer optimized for depth  \n\ndirect toolkit for loading texture会省掉很多工作，所以这里用了GDI+  \n\n[hlsl intrinsic functions](https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions)  \n\n[attenuation](http://wiki.ogre3d.org/-Point+Light+Attenuation)\n\n## imGUI\n\n使用方法：根目录的header和source文件 + examples里的对应平台文件（例如dx11+win32的四个文件）  \n\n# 3D Fundamental\n\nrasterization rule: left-top rule;\n\n# 《Unity shader 入门精要》\n\n## 概念合集\n\n[NDC与视锥体剪裁](https://www.zhihu.com/question/304277310)：视锥体剪裁在cpu中进行，gpu流水线中还有一次culling，是按NDC空间进行剪裁（超出-1到1就裁剪，dx的z-axis是0-1）。这两次剪裁功能相似，第一次的目的是减轻gpu负担。  \n\n模板测试（stencil test）：可以理解为深度测试中的深度这个概念有开发者人为设定。  \n\nblend（混合）/output merger\n\nearly-z\n\n## 数学相关\n\n点坐标：$$\\left[ \\begin{matrix}\n        x \\\\\n        y \\\\\n        z \\\\\n        1 \\end{matrix} \\right]$$ （如果是行向量，下边变换矩阵要转置）\n方向矢量：$$\\left[ \\begin{matrix}\n        x \\\\\n        y \\\\\n        z \\\\\n        0 \\end{matrix} \\right]$$\n基础变换矩阵：$$\n\\left[  \\begin{matrix}\n        M_{3*3} & t_{3*1} \\\\\n        0_{1*3} & 1 \n        \\end{matrix}\n\\right]$$\n之所以这样设置是为了使变换矩阵的计算结果正确；顶点变换中如果存在平移需要四维矩阵，方向矢量变换使用三维即可  \n\nM：旋转缩放；t：平移（如果坐标点或向量是行向量，t的位置要换到左下角）  \n\n复合变换依赖顺序，本质原因是矩阵乘法不满足交换律：$P_{new} = M_{translation} M_{rotation} M_{scale} P_{old}$ 执行顺序为从右到左，绝大多数情况按照缩放，旋转，平移的顺序  \n\n空间变换流程：模型空间->世界空间->观察（相机）空间->剪裁空间（视锥体剔除）->屏幕空间（剪裁空间转NDC转屏幕像素）  \n\n一般来说，模型空间到剪裁空间会合并为MVP矩阵（Model-View-Projection） \n\n## 光照模型\n\n* BRDF（bidirectional reflection distribution function）\n* BRDF经验模型（能量不守恒，简化的数学公式）：\n  * Lambert：反射强度不受角度影响，反射角度受平面影响\n  * 标准光照模型（Phong）：自发光，高光反射，漫反射，环境光（需要入射光，反射光，表面法线，视角方向）\n  * blinn-phong：与phong相比不需要计算反射方向，取而代之的是视角和入射光线的平均值归一化后的结果\n* 基于物理的BRDF模型（判断条件：是否满足交换律，即光路可逆；是否能量守恒）：\n  * cook-torrance BRDF：微面元模型用来表示pbs（physical based shading）中的高光，D是法线分布函数，G是阴影遮蔽函数，F是菲涅尔反射函数\n  * ward BRDF\n\n实现细节：\n* 漫反射符合兰伯特定律，即反射光线强度与表面法线和光源方向之间夹角的余弦值成正比  \n\n## 纹理映射\n\n纹理放大缩小的问题需要调整Filter Mode（Point,Bilinear,Trilinear）；\n缩小时最常使用mipmapping（多级渐远纹理技术）：典型的用空间换时间（多33%的空间）  \n\nbump mapping（凹凸映射）：分为两种，高度纹理（height map）模拟表面位移（displacement），得到一个修改后的法线值，称之为高度映射；另一种是法线纹理（normal map），直接做法线映射  \n\n1.在切线空间下进行光照计算；2.在世界空间下计算，前者效率往往优于后者  \n\nalbedo是tex2D（CG的函数，对纹理进行采样）的结果；  \nambient是环境光  \ndiffuse是漫反射  \nspecular是高光  \n\n法线纹理（normal map）可以使用DXT5nm的压缩格式，因为相比较普通图，法线纹理只有两个通道必不可少，第三个通道可以通过前两个推导出来，这种压缩方法可以减少内存占用  \n\n## 透明效果\n\nAlpha Test/Alpha Blending：透明度测试只有完全透明和完全不透两种可能；透明度混合可以实现半透明    \n\n半透物体是开启深度测试但是关闭深度写入的，这导致渲染顺序变得十分重要（因为关闭了深度写入）；应该**渲染不透明物体之后再渲染半透明物体**；如果都是半透明，按相机距离排序，从后往前渲染，开启深度测试，但是关闭深度写入  \n\n双面渲染：unity的Cull指令默认是Back，也就是背对相机的渲染图元不会被渲染  \n\n## 渲染路径\n\n更复杂的光照：\n* 前向渲染：颜色缓冲区和深度缓冲区；unity的前向渲染有三种，逐像素处理（最强平行光和重要光源用这种方式），逐顶点处理，球谐函数（spherical harmonics）  \n前向渲染的问题是，场景内有大量光源的情况下性能急剧下降，因为每个光源都要计算一次光照结果（一个光源一个pass）\n* 延迟渲染：G-buffer（Geometry），包含两个pass，第一个使用深度缓冲计算哪些片元可见；第二个计算片元信息，即光照计算  \n不支持抗锯齿；不能处理半透明；对硬件有要求MRT（multiple render targets）  \nUnity的延迟渲染需要提供两个pass：第一个用于渲染G-buffer；第二个用于计算真正的光照模型\n\n## API\n\nUnity shader中的矩阵是按行优先的，Unity脚本中有个Matrix4x4是按列优先  \n\nUnityRoot/Data/CGIncludes/ 里边有官方提供的.cginc文件，其中例如UnityCG.cginc十分值得学习  \n\n# 《Direct12 3D游戏开发实战》——龙书\n\n## 数学相关\n\nview transform矩阵，观察空间到世界空间的坐标变化矩阵为：\n$$\nW = \n\\left[  \\begin{matrix}\n        u_{x} & u_{y} & u_{z} & 0 \\\\\n        v_{x} & v_{y} & v_{z} & 0 \\\\\n        w_{x} & w_{y} & w_{z} & 0 \\\\\n        Q_{x} & Q_{y} & Q_{z} & 1\n        \\end{matrix}\n\\right]\n$$\n其中，$$Q_{w} = (Q_{x},Q_{y},Q_{z},1)$$，$$u_{w} = (u_{x},u_{y},u_{z},0)$$，$$v_{w}$$还有$$w_{w}$$分别表示了观察空间中原点，x轴，y轴，z轴相对于世界空间的齐次坐标。  \n相对的，世界空间到观察空间的变化矩阵为$$W^{-1}$$，世界矩阵可以分解为一个旋转矩阵和一个平移矩阵的乘积，即$$W=RT$$。\n$$\nV=W^{-1}=(RT)^{-1}=T^{-1}R^{-1}=T^{-1}R^{T}=\n$$\n$$\n\\left[  \\begin{matrix}\n        1 & 0 & 0 & 0 \\\\\n        0 & 1 & 0 & 0 \\\\\n        0 & 0 & 1 & 0 \\\\\n        -Q_{x} & -Q_{y} & -Q_{z} & 1\n        \\end{matrix}\n\\right]\n\\left[  \\begin{matrix}\n        u_{x} & u_{y} & u_{z} & 0 \\\\\n        v_{x} & v_{y} & v_{z} & 0 \\\\\n        w_{x} & w_{y} & w_{z} & 0 \\\\\n        0 & 0 & 0 & 1\n        \\end{matrix}\n\\right]\n=\n\\left[  \\begin{matrix}\n        u_{x} & u_{y} & u_{z} & 0 \\\\\n        v_{x} & v_{y} & v_{z} & 0 \\\\\n        w_{x} & w_{y} & w_{z} & 0 \\\\\n        -Q_{x} \\cdot u & -Q_{y} \\cdot v & -Q_{z} \\cdot w & 1\n        \\end{matrix}\n\\right]\n$$\n由此得到，\n$$\nV=\n\\left[  \\begin{matrix}\n        u_{x} & u_{y} & u_{z} & 0 \\\\\n        v_{x} & v_{y} & v_{z} & 0 \\\\\n        w_{x} & w_{y} & w_{z} & 0 \\\\\n        -Q_{x} \\cdot u & -Q_{y} \\cdot v & -Q_{z} \\cdot w & 1\n        \\end{matrix}\n\\right]\n$$\n\n# Unreal source code review\n\n","content":"<h1 id=\"Hardware-3D\"><a href=\"#Hardware-3D\" class=\"headerlink\" title=\"Hardware 3D\"></a>Hardware 3D</h1><p>COM：</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Ut5zYcDKGwk\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<p>framebuffer: 双重缓冲是一个画（用户操作），一个已经画好的传输给显示器做显示，一个称为front，另一个称为back buffer。<br>还可以有多重缓冲，缓冲层数越多，会导致画面延迟加重，但是更加连贯顺滑。原因是有时候front没花完，显示器已经逐像素扫描完一个frame，显示器就得等front buffer。<br>vsync：防tearing，就是等显示器一个frame完成再载入下一个buffer  </p>\n<p>constant buffer: 用来存变换矩阵，目的是用shader控制图形旋转，而不是改变vertices的坐标  </p>\n<p>shader中对于matric的修饰词 row_major会降低速度  </p>\n<p>DirectX Math： SIMD(single instruction multiple data)  </p>\n<p>depth buffer shares memory with stencil buffer(模板缓冲): masking like mirror,portals. depth buffer optimized for depth  </p>\n<p>direct toolkit for loading texture会省掉很多工作，所以这里用了GDI+  </p>\n<p><a href=\"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\" target=\"_blank\" rel=\"noopener\">hlsl intrinsic functions</a>  </p>\n<p><a href=\"http://wiki.ogre3d.org/-Point+Light+Attenuation\" target=\"_blank\" rel=\"noopener\">attenuation</a></p>\n<h2 id=\"imGUI\"><a href=\"#imGUI\" class=\"headerlink\" title=\"imGUI\"></a>imGUI</h2><p>使用方法：根目录的header和source文件 + examples里的对应平台文件（例如dx11+win32的四个文件）  </p>\n<h1 id=\"3D-Fundamental\"><a href=\"#3D-Fundamental\" class=\"headerlink\" title=\"3D Fundamental\"></a>3D Fundamental</h1><p>rasterization rule: left-top rule;</p>\n<h1 id=\"《Unity-shader-入门精要》\"><a href=\"#《Unity-shader-入门精要》\" class=\"headerlink\" title=\"《Unity shader 入门精要》\"></a>《Unity shader 入门精要》</h1><h2 id=\"概念合集\"><a href=\"#概念合集\" class=\"headerlink\" title=\"概念合集\"></a>概念合集</h2><p><a href=\"https://www.zhihu.com/question/304277310\" target=\"_blank\" rel=\"noopener\">NDC与视锥体剪裁</a>：视锥体剪裁在cpu中进行，gpu流水线中还有一次culling，是按NDC空间进行剪裁（超出-1到1就裁剪，dx的z-axis是0-1）。这两次剪裁功能相似，第一次的目的是减轻gpu负担。  </p>\n<p>模板测试（stencil test）：可以理解为深度测试中的深度这个概念有开发者人为设定。  </p>\n<p>blend（混合）/output merger</p>\n<p>early-z</p>\n<h2 id=\"数学相关\"><a href=\"#数学相关\" class=\"headerlink\" title=\"数学相关\"></a>数学相关</h2><p>点坐标：<script type=\"math/tex\">\\left[ \\begin{matrix}\n        x \\\\\n        y \\\\\n        z \\\\\n        1 \\end{matrix} \\right]</script> （如果是行向量，下边变换矩阵要转置）<br>方向矢量：<script type=\"math/tex\">\\left[ \\begin{matrix}\n        x \\\\\n        y \\\\\n        z \\\\\n        0 \\end{matrix} \\right]</script><br>基础变换矩阵：<script type=\"math/tex\">\\left[  \\begin{matrix}\n        M_{3*3} & t_{3*1} \\\\\n        0_{1*3} & 1 \n        \\end{matrix}\n\\right]</script><br>之所以这样设置是为了使变换矩阵的计算结果正确；顶点变换中如果存在平移需要四维矩阵，方向矢量变换使用三维即可  </p>\n<p>M：旋转缩放；t：平移（如果坐标点或向量是行向量，t的位置要换到左下角）  </p>\n<p>复合变换依赖顺序，本质原因是矩阵乘法不满足交换律：$P<em>{new} = M</em>{translation} M<em>{rotation} M</em>{scale} P_{old}$ 执行顺序为从右到左，绝大多数情况按照缩放，旋转，平移的顺序  </p>\n<p>空间变换流程：模型空间-&gt;世界空间-&gt;观察（相机）空间-&gt;剪裁空间（视锥体剔除）-&gt;屏幕空间（剪裁空间转NDC转屏幕像素）  </p>\n<p>一般来说，模型空间到剪裁空间会合并为MVP矩阵（Model-View-Projection） </p>\n<h2 id=\"光照模型\"><a href=\"#光照模型\" class=\"headerlink\" title=\"光照模型\"></a>光照模型</h2><ul>\n<li>BRDF（bidirectional reflection distribution function）</li>\n<li>BRDF经验模型（能量不守恒，简化的数学公式）：<ul>\n<li>Lambert：反射强度不受角度影响，反射角度受平面影响</li>\n<li>标准光照模型（Phong）：自发光，高光反射，漫反射，环境光（需要入射光，反射光，表面法线，视角方向）</li>\n<li>blinn-phong：与phong相比不需要计算反射方向，取而代之的是视角和入射光线的平均值归一化后的结果</li>\n</ul>\n</li>\n<li>基于物理的BRDF模型（判断条件：是否满足交换律，即光路可逆；是否能量守恒）：<ul>\n<li>cook-torrance BRDF：微面元模型用来表示pbs（physical based shading）中的高光，D是法线分布函数，G是阴影遮蔽函数，F是菲涅尔反射函数</li>\n<li>ward BRDF</li>\n</ul>\n</li>\n</ul>\n<p>实现细节：</p>\n<ul>\n<li>漫反射符合兰伯特定律，即反射光线强度与表面法线和光源方向之间夹角的余弦值成正比  </li>\n</ul>\n<h2 id=\"纹理映射\"><a href=\"#纹理映射\" class=\"headerlink\" title=\"纹理映射\"></a>纹理映射</h2><p>纹理放大缩小的问题需要调整Filter Mode（Point,Bilinear,Trilinear）；<br>缩小时最常使用mipmapping（多级渐远纹理技术）：典型的用空间换时间（多33%的空间）  </p>\n<p>bump mapping（凹凸映射）：分为两种，高度纹理（height map）模拟表面位移（displacement），得到一个修改后的法线值，称之为高度映射；另一种是法线纹理（normal map），直接做法线映射  </p>\n<p>1.在切线空间下进行光照计算；2.在世界空间下计算，前者效率往往优于后者  </p>\n<p>albedo是tex2D（CG的函数，对纹理进行采样）的结果；<br>ambient是环境光<br>diffuse是漫反射<br>specular是高光  </p>\n<p>法线纹理（normal map）可以使用DXT5nm的压缩格式，因为相比较普通图，法线纹理只有两个通道必不可少，第三个通道可以通过前两个推导出来，这种压缩方法可以减少内存占用  </p>\n<h2 id=\"透明效果\"><a href=\"#透明效果\" class=\"headerlink\" title=\"透明效果\"></a>透明效果</h2><p>Alpha Test/Alpha Blending：透明度测试只有完全透明和完全不透两种可能；透明度混合可以实现半透明    </p>\n<p>半透物体是开启深度测试但是关闭深度写入的，这导致渲染顺序变得十分重要（因为关闭了深度写入）；应该<strong>渲染不透明物体之后再渲染半透明物体</strong>；如果都是半透明，按相机距离排序，从后往前渲染，开启深度测试，但是关闭深度写入  </p>\n<p>双面渲染：unity的Cull指令默认是Back，也就是背对相机的渲染图元不会被渲染  </p>\n<h2 id=\"渲染路径\"><a href=\"#渲染路径\" class=\"headerlink\" title=\"渲染路径\"></a>渲染路径</h2><p>更复杂的光照：</p>\n<ul>\n<li>前向渲染：颜色缓冲区和深度缓冲区；unity的前向渲染有三种，逐像素处理（最强平行光和重要光源用这种方式），逐顶点处理，球谐函数（spherical harmonics）<br>前向渲染的问题是，场景内有大量光源的情况下性能急剧下降，因为每个光源都要计算一次光照结果（一个光源一个pass）</li>\n<li>延迟渲染：G-buffer（Geometry），包含两个pass，第一个使用深度缓冲计算哪些片元可见；第二个计算片元信息，即光照计算<br>不支持抗锯齿；不能处理半透明；对硬件有要求MRT（multiple render targets）<br>Unity的延迟渲染需要提供两个pass：第一个用于渲染G-buffer；第二个用于计算真正的光照模型</li>\n</ul>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><p>Unity shader中的矩阵是按行优先的，Unity脚本中有个Matrix4x4是按列优先  </p>\n<p>UnityRoot/Data/CGIncludes/ 里边有官方提供的.cginc文件，其中例如UnityCG.cginc十分值得学习  </p>\n<h1 id=\"《Direct12-3D游戏开发实战》——龙书\"><a href=\"#《Direct12-3D游戏开发实战》——龙书\" class=\"headerlink\" title=\"《Direct12 3D游戏开发实战》——龙书\"></a>《Direct12 3D游戏开发实战》——龙书</h1><h2 id=\"数学相关-1\"><a href=\"#数学相关-1\" class=\"headerlink\" title=\"数学相关\"></a>数学相关</h2><p>view transform矩阵，观察空间到世界空间的坐标变化矩阵为：</p>\n<script type=\"math/tex; mode=display\">\nW = \n\\left[  \\begin{matrix}\n        u_{x} & u_{y} & u_{z} & 0 \\\\\n        v_{x} & v_{y} & v_{z} & 0 \\\\\n        w_{x} & w_{y} & w_{z} & 0 \\\\\n        Q_{x} & Q_{y} & Q_{z} & 1\n        \\end{matrix}\n\\right]</script><p>其中，<script type=\"math/tex\">Q_{w} = (Q_{x},Q_{y},Q_{z},1)</script>，<script type=\"math/tex\">u_{w} = (u_{x},u_{y},u_{z},0)</script>，<script type=\"math/tex\">v_{w}</script>还有<script type=\"math/tex\">w_{w}</script>分别表示了观察空间中原点，x轴，y轴，z轴相对于世界空间的齐次坐标。<br>相对的，世界空间到观察空间的变化矩阵为<script type=\"math/tex\">W^{-1}</script>，世界矩阵可以分解为一个旋转矩阵和一个平移矩阵的乘积，即<script type=\"math/tex\">W=RT</script>。</p>\n<script type=\"math/tex; mode=display\">\nV=W^{-1}=(RT)^{-1}=T^{-1}R^{-1}=T^{-1}R^{T}=</script><script type=\"math/tex; mode=display\">\n\\left[  \\begin{matrix}\n        1 & 0 & 0 & 0 \\\\\n        0 & 1 & 0 & 0 \\\\\n        0 & 0 & 1 & 0 \\\\\n        -Q_{x} & -Q_{y} & -Q_{z} & 1\n        \\end{matrix}\n\\right]\n\\left[  \\begin{matrix}\n        u_{x} & u_{y} & u_{z} & 0 \\\\\n        v_{x} & v_{y} & v_{z} & 0 \\\\\n        w_{x} & w_{y} & w_{z} & 0 \\\\\n        0 & 0 & 0 & 1\n        \\end{matrix}\n\\right]\n=\n\\left[  \\begin{matrix}\n        u_{x} & u_{y} & u_{z} & 0 \\\\\n        v_{x} & v_{y} & v_{z} & 0 \\\\\n        w_{x} & w_{y} & w_{z} & 0 \\\\\n        -Q_{x} \\cdot u & -Q_{y} \\cdot v & -Q_{z} \\cdot w & 1\n        \\end{matrix}\n\\right]</script><p>由此得到，</p>\n<script type=\"math/tex; mode=display\">\nV=\n\\left[  \\begin{matrix}\n        u_{x} & u_{y} & u_{z} & 0 \\\\\n        v_{x} & v_{y} & v_{z} & 0 \\\\\n        w_{x} & w_{y} & w_{z} & 0 \\\\\n        -Q_{x} \\cdot u & -Q_{y} \\cdot v & -Q_{z} \\cdot w & 1\n        \\end{matrix}\n\\right]</script><h1 id=\"Unreal-source-code-review\"><a href=\"#Unreal-source-code-review\" class=\"headerlink\" title=\"Unreal source code review\"></a>Unreal source code review</h1>","slug":"hardware3d","updated":"2020-07-08T13:51:39.323Z","comments":true,"link":"","permalink":"/2020/04/14/hardware3d/","excerpt":"","categories":[],"tags":[{"name":"Dx12","slug":"Dx12","permalink":"/tags/Dx12/"},{"name":"WindowsApp","slug":"WindowsApp","permalink":"/tags/WindowsApp/"},{"name":"COM","slug":"COM","permalink":"/tags/COM/"},{"name":"Shader","slug":"Shader","permalink":"/tags/Shader/"}]},{"title":"SEE THROUGH OCCLUSIONS:DETAILED HUMAN SHAPE ESTIMATION FROM A SINGLE IMAGE WITH OCCLUSIONS","date":"2020-03-31T04:45:53.000Z","path":"2020/03/31/ICIP/","text":"SEE THROUGH OCCLUSIONS:DETAILED HUMAN SHAPE ESTIMATION FROM A SINGLE IMAGE WITH OCCLUSIONSAbstract3D human body shape and pose reconstructing from a single RGB image is a challenging task in the field of computer vision and computer graphics. Since occlusions are prevalent in real application scenarios, it’s important to develop 3D human body reconstruction algorithms with occlusions. However, existing methods didn’t take this problem into account. In this paper, we present a novel depth estimation Neural Network, named Detailed Human Depth Network(DHDNet), which aims to reconstruct the detailed and completed depth map from a single RGB image contains occlusions of human body. Inspired by the previous works [1, 2], we propose an end-to-end method to obtain the fine detailed 3D human mesh. The proposed method follows a coarse-to-fine refinement scheme. Using the depth information generated from DHDNet, the coarse 3D mesh can recover detailed spatial structure, even the part behind occlusions. We also construct DepthHuman, a 2D in-the-wild human dataset containing over 18000 synthetic human depth maps and corresponding RGB images. Extensive experimental results demonstrate that our approach has significant improvement in 3D mesh reconstruction accuracy on the occluded parts. StatusICIP under review — 2020.1.31ACCEPTED — 2020.5.16 Links","raw":"---\ntitle: SEE THROUGH OCCLUSIONS:DETAILED HUMAN SHAPE ESTIMATION FROM A SINGLE IMAGE WITH OCCLUSIONS\ndate: 2020-03-31 12:45:53\ntags:\n    - ICIP\n    - 三维人体重建\n    - 深度学习\n    - shift_net\n    - hmd\n---\n\n# SEE THROUGH OCCLUSIONS:DETAILED HUMAN SHAPE ESTIMATION FROM A SINGLE IMAGE WITH OCCLUSIONS\n\n## Abstract\n\n3D human body shape and pose reconstructing from a single RGB image is a challenging task in the field of computer vision and computer graphics. Since occlusions are prevalent in real application scenarios, it’s important to develop 3D human body reconstruction algorithms with occlusions. However, existing methods didn’t take this problem into account. In this paper, we present a novel depth estimation Neural Network, named Detailed Human Depth Network(DHDNet), which aims to reconstruct the detailed and completed depth map from a single RGB image contains occlusions of human body. Inspired by the previous works [1, 2], we propose an end-to-end method to obtain the fine detailed 3D human mesh. The proposed method follows a coarse-to-fine refinement scheme. Using the depth information generated from DHDNet, the coarse 3D mesh can recover detailed spatial structure, even the part behind occlusions. We also construct DepthHuman, a 2D in-the-wild human dataset containing over 18000 synthetic human depth maps and corresponding RGB images. Extensive experimental results demonstrate that our approach has significant improvement in 3D mesh reconstruction accuracy on the occluded parts.\n\n## Status\n\nICIP under review -- 2020.1.31  \nACCEPTED          -- 2020.5.16  \n\n{% asset_img accepted.png review %}  \n\n## Links\n\n{% pdf ICIP.pdf %}\n\n{% asset_img 6.PNG details %}  \n{% asset_img 7.PNG depth %}  \n{% asset_img Capture.PNG comparison %}  \n{% asset_img system6.png end-to-end system %}  ","content":"<h1 id=\"SEE-THROUGH-OCCLUSIONS-DETAILED-HUMAN-SHAPE-ESTIMATION-FROM-A-SINGLE-IMAGE-WITH-OCCLUSIONS\"><a href=\"#SEE-THROUGH-OCCLUSIONS-DETAILED-HUMAN-SHAPE-ESTIMATION-FROM-A-SINGLE-IMAGE-WITH-OCCLUSIONS\" class=\"headerlink\" title=\"SEE THROUGH OCCLUSIONS:DETAILED HUMAN SHAPE ESTIMATION FROM A SINGLE IMAGE WITH OCCLUSIONS\"></a>SEE THROUGH OCCLUSIONS:DETAILED HUMAN SHAPE ESTIMATION FROM A SINGLE IMAGE WITH OCCLUSIONS</h1><h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>3D human body shape and pose reconstructing from a single RGB image is a challenging task in the field of computer vision and computer graphics. Since occlusions are prevalent in real application scenarios, it’s important to develop 3D human body reconstruction algorithms with occlusions. However, existing methods didn’t take this problem into account. In this paper, we present a novel depth estimation Neural Network, named Detailed Human Depth Network(DHDNet), which aims to reconstruct the detailed and completed depth map from a single RGB image contains occlusions of human body. Inspired by the previous works [1, 2], we propose an end-to-end method to obtain the fine detailed 3D human mesh. The proposed method follows a coarse-to-fine refinement scheme. Using the depth information generated from DHDNet, the coarse 3D mesh can recover detailed spatial structure, even the part behind occlusions. We also construct DepthHuman, a 2D in-the-wild human dataset containing over 18000 synthetic human depth maps and corresponding RGB images. Extensive experimental results demonstrate that our approach has significant improvement in 3D mesh reconstruction accuracy on the occluded parts.</p>\n<h2 id=\"Status\"><a href=\"#Status\" class=\"headerlink\" title=\"Status\"></a>Status</h2><p>ICIP under review — 2020.1.31<br>ACCEPTED          — 2020.5.16  </p>\n<img src=\"/2020/03/31/ICIP/accepted.png\" title=\"review\">  \n<h2 id=\"Links\"><a href=\"#Links\" class=\"headerlink\" title=\"Links\"></a>Links</h2>\n\n\t<div class=\"row\">\n    <embed src=\"ICIP.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n<img src=\"/2020/03/31/ICIP/6.PNG\" title=\"details\">  \n<img src=\"/2020/03/31/ICIP/7.PNG\" title=\"depth\">  \n<img src=\"/2020/03/31/ICIP/Capture.PNG\" title=\"comparison\">  \n<img src=\"/2020/03/31/ICIP/system6.png\" title=\"end-to-end system\">  ","slug":"ICIP","updated":"2020-05-16T05:36:01.758Z","comments":true,"link":"","permalink":"/2020/03/31/ICIP/","excerpt":"","categories":[],"tags":[{"name":"ICIP","slug":"ICIP","permalink":"/tags/ICIP/"},{"name":"三维人体重建","slug":"三维人体重建","permalink":"/tags/三维人体重建/"},{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"shift_net","slug":"shift-net","permalink":"/tags/shift-net/"},{"name":"hmd","slug":"hmd","permalink":"/tags/hmd/"}]},{"title":"DOTS & ECS & RP","date":"2020-03-04T10:19:17.000Z","path":"2020/03/04/DOTSandECS/","text":"About ECSOLD: GameObjects &amp; MonoBehaviours Object-oriented create一个叫Player的GameObject，用若干MonoBehaviour作为Player的组件，实现功能（例如renderer,physics,movement）。 NEW: Entities &amp; Components &amp; Systems data-oriented group together components contain data (只是数据结构，不包含逻辑) contain behaviour （逻辑只在这里） 就是数据和逻辑分开了，这样cpu可以读到连续的内存，不需要每个GO来回在内存里跳 DOTSDATA ORIENTED TECHNOLOGY STACK三部分组成： C# Job system 多线程，unity的性能问题主要来源于主循环update线程是单线程的 C#创建线程并管理每个线程的工作很困难，job system来管理线程，并且分配任务（assigns jobs） entity component system burst compiler 把C#编译成高度适用于Job system的机器码 Render PipelineScriptable render pipeline SRPUniversal render pipeline URP(LWRP)High definition render pipeline(HDRP) Build-in renderer TutorialQuadrant System in Unity ECS (Find Target/Obstacle Avoidance/Boids) Note1234World.Active.EntityManager; // desperatedWorld.DefaultGameObjectInjectionWorld.EntityManager; // use thistypeof(RenderBounds); // make the mesh visable URP下需要用unlit/transparent材质","raw":"---\ntitle: DOTS & ECS & RP\ndate: 2020-03-04 18:19:17\ntags:\n    - Unity\n    - ECS\n    - DOTS\n---\n\n## About ECS\nOLD:  \n    GameObjects & MonoBehaviours  \n    Object-oriented  \n    create一个叫Player的GameObject，用若干MonoBehaviour作为Player的组件，实现功能（例如renderer,physics,movement）。\n\nNEW:  \n    Entities & Components & Systems  \n    data-oriented  \n1. group together components\n2. contain data (只是数据结构，不包含逻辑)\n3. contain behaviour （逻辑只在这里）\n\n就是数据和逻辑分开了，这样cpu可以读到连续的内存，不需要每个GO来回在内存里跳\n\n## DOTS\nDATA ORIENTED TECHNOLOGY STACK  \n三部分组成：\n1. C# Job system\n   1. 多线程，unity的性能问题主要来源于主循环update线程是单线程的\n   2. C#创建线程并管理每个线程的工作很困难，job system来管理线程，并且分配任务（assigns jobs）\n2. entity component system\n3. burst compiler\n   1. 把C#编译成高度适用于Job system的机器码\n\n\n## Render Pipeline\nScriptable render pipeline SRP  \nUniversal render pipeline URP(LWRP)  \nHigh definition render pipeline(HDRP)  \n\nBuild-in renderer\n\n### Tutorial\n\nQuadrant System in Unity ECS (Find Target/Obstacle Avoidance/Boids)  \n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/hP4Vu6JbzSo\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>  \n\n\n### Note\n``` C#\nWorld.Active.EntityManager; // desperated\nWorld.DefaultGameObjectInjectionWorld.EntityManager; // use this\n\ntypeof(RenderBounds); // make the mesh visable\n```\n\nURP下需要用unlit/transparent材质  \n\n","content":"<h2 id=\"About-ECS\"><a href=\"#About-ECS\" class=\"headerlink\" title=\"About ECS\"></a>About ECS</h2><p>OLD:<br>    GameObjects &amp; MonoBehaviours<br>    Object-oriented<br>    create一个叫Player的GameObject，用若干MonoBehaviour作为Player的组件，实现功能（例如renderer,physics,movement）。</p>\n<p>NEW:<br>    Entities &amp; Components &amp; Systems<br>    data-oriented  </p>\n<ol>\n<li>group together components</li>\n<li>contain data (只是数据结构，不包含逻辑)</li>\n<li>contain behaviour （逻辑只在这里）</li>\n</ol>\n<p>就是数据和逻辑分开了，这样cpu可以读到连续的内存，不需要每个GO来回在内存里跳</p>\n<h2 id=\"DOTS\"><a href=\"#DOTS\" class=\"headerlink\" title=\"DOTS\"></a>DOTS</h2><p>DATA ORIENTED TECHNOLOGY STACK<br>三部分组成：</p>\n<ol>\n<li>C# Job system<ol>\n<li>多线程，unity的性能问题主要来源于主循环update线程是单线程的</li>\n<li>C#创建线程并管理每个线程的工作很困难，job system来管理线程，并且分配任务（assigns jobs）</li>\n</ol>\n</li>\n<li>entity component system</li>\n<li>burst compiler<ol>\n<li>把C#编译成高度适用于Job system的机器码</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Render-Pipeline\"><a href=\"#Render-Pipeline\" class=\"headerlink\" title=\"Render Pipeline\"></a>Render Pipeline</h2><p>Scriptable render pipeline SRP<br>Universal render pipeline URP(LWRP)<br>High definition render pipeline(HDRP)  </p>\n<p>Build-in renderer</p>\n<h3 id=\"Tutorial\"><a href=\"#Tutorial\" class=\"headerlink\" title=\"Tutorial\"></a>Tutorial</h3><p>Quadrant System in Unity ECS (Find Target/Obstacle Avoidance/Boids)  </p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/hP4Vu6JbzSo\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>  \n\n\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">World.Active.EntityManager; // desperated</span><br><span class=\"line\">World.DefaultGameObjectInjectionWorld.EntityManager; // use this</span><br><span class=\"line\"></span><br><span class=\"line\">typeof(RenderBounds); // make the mesh visable</span><br></pre></td></tr></table></figure>\n<p>URP下需要用unlit/transparent材质  </p>\n","slug":"DOTSandECS","updated":"2020-03-18T06:36:52.090Z","comments":true,"link":"","permalink":"/2020/03/04/DOTSandECS/","excerpt":"","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"/tags/Unity/"},{"name":"ECS","slug":"ECS","permalink":"/tags/ECS/"},{"name":"DOTS","slug":"DOTS","permalink":"/tags/DOTS/"}]},{"title":"云服务器相关","date":"2020-02-12T12:00:24.000Z","path":"2020/02/12/CloudServer/","text":"云上项目Hotfixxlua到webgl的坑 1xlua.hotfix ChatRoomMirror聊天室 Mysql更改user的host地址：1update user set host = '%' where user = 'root'; 改成linux之后要重新做server了 Homehttp://providencezhang.cnvuejs+node+nginx link三者的关系简单来说，nginx可以反向代理多个node项目，做负载均衡等。如果没有服务端逻辑无需node，vuejs+nginx即可 Blogblog.providencezhang.cn 解析到了 taye310.github.iohexo + github pages只能提供静态页面，unity webgl需要网页服务器能解析.unityweb文件，在IIS上需要在mapping上单独设置（mimetype），这个可能是导致不能在github pages上部署unity webgl项目的原因。 计划要不要直接换skynet - 需要Ubuntu环境 √消息机制是不是可以自己实现一套，看skynet吧 xlua热更demo实现C#这个attribute到底怎么用 日志2020.2.10服务器win版本，客户端webgl，IIS部署成功 2020.2.12业务：增加聊天记录；实现：不论是用streamasset还是加mysql数据库，服务器和客户端内容都需要分开server记聊天记录 client是不用记的command不能有返回值，传入参数类型也有限制，正确的方法：12345678910111213but yeah you cant do that, I use ClientRpc&apos;s so for example if i have a float that&apos;s called &quot;exampleValue&quot; and want to update it on the client you could something like this:[Command]public void CmdRecuestNewValues()&#123;RpcGiveNewValues(exampleValue);&#125;[ClientRpc]public void RpcGiveNewValues(float value)&#123;exampleValue = value;&#125;then if you call the CmdRecuestNewValues(); command you will update you values. 2020.2.14unity URP vs HDRP 2020.2.19刷leetcode，首页整好看点！！！找个模板，后端用wordpress集成什么意思？？域名备案终于下来咯 2020.3.9ubuntu上不要用系统代理（更新conda包会报错未知sock版本），chrome用Omega插件，命令行用proxychain4Skynet腾讯云上想用skynet的话要用ubuntu这样的话主页要换成nginx，不想装图形界面了，用共享文件夹samba远程写脚本，到linux下build 2020.3.10云服务器重装了ubuntu，用vscode remote development就可以远程调试，ssh添加了两对，一是新建的Home，二是github用的在.ssh里的一对samba配置教程传文件用sftp就好，局域网可以用samba 2020.3.11-s reload ``` 123456789101112131415161718[conf](https://blog.csdn.net/WanJiaBaoBao/article/details/83349622) Nginx location设置二级域名时 root下边要有这个名字的文件夹 ``` bashserver&#123; listen 80; #1.你想让你的这个项目跑在哪个端口 server_name providencezhang.cn; #2.当前服务器ip location / &#123; root /home/ubuntu/ftp/www/home; #3.dist文件的位置(我是直接放在home目录下了) # try_files $uri $uri/ /index.html; #4.重定向,内部文件的指向(照写) &#125; location /static &#123; alias /home/ubuntu/github/simpleweb; #3.dist文件的位置(我是直接放在home目录下了) # try_files $uri $uri/ /index.html; #4.重定向,内部文件的指向(照写) &#125; location /api &#123; #4.当请求跨域时配置端口转发 proxy_pass http://175.24.57.128:8848/api; #5.转发地址 &#125; &#125; 2020.3.12用firewall-cmd开nginx的80端口 2020.3.13最终目标：多人在线游戏，用dots skynet源码 简单demo跑通逻辑（登陆，心跳，消息机制） 客户端开发 前后端连接 2020.3.14git代理设置 2020.3.26dots到webgl 会出现问题 link12sudo nginx -t # 测试配置是否成功sudo nginx -s reload # 重启服务 xlua的热更到webgl有问题","raw":"---\ntitle: 云服务器相关\ndate: 2020-02-12 20:00:24\ntags: \n    - 云服务\n    - 腾讯云\n---\n\n# 云上项目\n\n## Hotfix\n\n[xlua到webgl的坑](http://blog.okbase.net/unity3d/archive/56120.html)  \n\n``` lua\nxlua.hotfix\n```\n\n## ChatRoom\n\nMirror聊天室\n\nMysql更改user的host地址：\n``` sql\nupdate user set host = '%' where user = 'root';\n```\n\n改成linux之后要重新做server了  \n\n## Home\n\nhttp://providencezhang.cn  \nvuejs+node+nginx [link](https://segmentfault.com/a/1190000018099632)  \n[三者的关系](https://www.zhihu.com/question/294219455?sort=created)  \n简单来说，nginx可以反向代理多个node项目，做负载均衡等。如果没有服务端逻辑无需node，vuejs+nginx即可  \n\n## Blog\n\nblog.providencezhang.cn 解析到了 taye310.github.io  \nhexo + github pages只能提供静态页面，unity webgl需要网页服务器能解析.unityweb文件，在IIS上需要在mapping上单独设置（mimetype），这个可能是导致不能在github pages上部署unity webgl项目的原因。\n\n## 计划\n\n要不要直接换skynet - 需要Ubuntu环境 √\n消息机制是不是可以自己实现一套，看skynet吧  \n\nxlua热更demo实现  \nC#这个attribute到底怎么用\n\n## 日志\n\n### 2020.2.10\n服务器win版本，客户端webgl，IIS部署成功\n\n### 2020.2.12\n业务：增加聊天记录；实现：不论是用streamasset还是加mysql数据库，服务器和客户端内容都需要分开  \nserver记聊天记录 client是不用记的  \ncommand不能有返回值，传入参数类型也有限制，正确的方法：\n```\nbut yeah you cant do that, I use ClientRpc's so for example if i have a float that's called \"exampleValue\" and want to update it on the client you could something like this:\n\n[Command]\npublic void CmdRecuestNewValues(){\nRpcGiveNewValues(exampleValue);\n}\n\n[ClientRpc]\npublic void RpcGiveNewValues(float value){\nexampleValue = value;\n}\n\nthen if you call the CmdRecuestNewValues(); command you will update you values.\n```\n\n### 2020.2.14\nunity URP vs HDRP\n\n### 2020.2.19\n刷leetcode，首页整好看点！！！找个模板，后端用wordpress集成什么意思？？  \n域名备案终于下来咯\n\n### 2020.3.9\nubuntu上不要用系统代理（更新conda包会报错未知sock版本），chrome用Omega插件，命令行用proxychain4  \nSkynet  \n腾讯云上想用skynet的话要用ubuntu  \n这样的话主页要换成nginx，不想装图形界面了，用共享文件夹samba远程写脚本，到linux下build  \n\n### 2020.3.10\n云服务器重装了ubuntu，用vscode remote development就可以远程调试，ssh添加了两对，一是新建的Home，二是github用的在.ssh里的一对  \n[samba配置教程](https://blog.csdn.net/qq_28719743/article/details/84872396)  \n传文件用sftp就好，局域网可以用samba\n\n### 2020.3.11\n``` nginx -s reload ```  \n[conf](https://blog.csdn.net/WanJiaBaoBao/article/details/83349622)  \nNginx location设置二级域名时 root下边要有这个名字的文件夹  \n``` bash\nserver{\n        listen 80;     #1.你想让你的这个项目跑在哪个端口\n        server_name providencezhang.cn;     #2.当前服务器ip\n       \tlocation / {\n        \troot /home/ubuntu/ftp/www/home;     #3.dist文件的位置(我是直接放在home目录下了) \n            # try_files $uri $uri/ /index.html;     #4.重定向,内部文件的指向(照写)\n        }\n\t\tlocation /static {\n        \talias /home/ubuntu/github/simpleweb;     #3.dist文件的位置(我是直接放在home目录下了) \n            # try_files $uri $uri/ /index.html;     #4.重定向,内部文件的指向(照写)\n        }\n        location /api {  #4.当请求跨域时配置端口转发\n            proxy_pass http://175.24.57.128:8848/api; #5.转发地址\n        } \n    }\n```\n\n### 2020.3.12\n用firewall-cmd开nginx的80端口\n\n### 2020.3.13\n最终目标：多人在线游戏，用dots  \n1. skynet源码  \n2. 简单demo跑通逻辑（登陆，心跳，消息机制）\n3. 客户端开发\n4. 前后端连接\n\n### 2020.3.14\n[git代理设置](https://echo.xuchaoji.com/index.php/archives/110/)\n\n### 2020.3.26\ndots到webgl 会出现问题 [link](https://forum.unity.com/threads/bug-crash-with-a-fresh-project-on-ios-monopinvokecallback.827634/)  \n``` conf\nsudo nginx -t         # 测试配置是否成功\nsudo nginx -s reload  # 重启服务\n```\nxlua的热更到webgl有问题","content":"<h1 id=\"云上项目\"><a href=\"#云上项目\" class=\"headerlink\" title=\"云上项目\"></a>云上项目</h1><h2 id=\"Hotfix\"><a href=\"#Hotfix\" class=\"headerlink\" title=\"Hotfix\"></a>Hotfix</h2><p><a href=\"http://blog.okbase.net/unity3d/archive/56120.html\" target=\"_blank\" rel=\"noopener\">xlua到webgl的坑</a>  </p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xlua.hotfix</span><br></pre></td></tr></table></figure>\n<h2 id=\"ChatRoom\"><a href=\"#ChatRoom\" class=\"headerlink\" title=\"ChatRoom\"></a>ChatRoom</h2><p>Mirror聊天室</p>\n<p>Mysql更改user的host地址：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> host = <span class=\"string\">'%'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span> = <span class=\"string\">'root'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>改成linux之后要重新做server了  </p>\n<h2 id=\"Home\"><a href=\"#Home\" class=\"headerlink\" title=\"Home\"></a>Home</h2><p><a href=\"http://providencezhang.cn\" target=\"_blank\" rel=\"noopener\">http://providencezhang.cn</a><br>vuejs+node+nginx <a href=\"https://segmentfault.com/a/1190000018099632\" target=\"_blank\" rel=\"noopener\">link</a><br><a href=\"https://www.zhihu.com/question/294219455?sort=created\" target=\"_blank\" rel=\"noopener\">三者的关系</a><br>简单来说，nginx可以反向代理多个node项目，做负载均衡等。如果没有服务端逻辑无需node，vuejs+nginx即可  </p>\n<h2 id=\"Blog\"><a href=\"#Blog\" class=\"headerlink\" title=\"Blog\"></a>Blog</h2><p>blog.providencezhang.cn 解析到了 taye310.github.io<br>hexo + github pages只能提供静态页面，unity webgl需要网页服务器能解析.unityweb文件，在IIS上需要在mapping上单独设置（mimetype），这个可能是导致不能在github pages上部署unity webgl项目的原因。</p>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><p>要不要直接换skynet - 需要Ubuntu环境 √<br>消息机制是不是可以自己实现一套，看skynet吧  </p>\n<p>xlua热更demo实现<br>C#这个attribute到底怎么用</p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><h3 id=\"2020-2-10\"><a href=\"#2020-2-10\" class=\"headerlink\" title=\"2020.2.10\"></a>2020.2.10</h3><p>服务器win版本，客户端webgl，IIS部署成功</p>\n<h3 id=\"2020-2-12\"><a href=\"#2020-2-12\" class=\"headerlink\" title=\"2020.2.12\"></a>2020.2.12</h3><p>业务：增加聊天记录；实现：不论是用streamasset还是加mysql数据库，服务器和客户端内容都需要分开<br>server记聊天记录 client是不用记的<br>command不能有返回值，传入参数类型也有限制，正确的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">but yeah you cant do that, I use ClientRpc&apos;s so for example if i have a float that&apos;s called &quot;exampleValue&quot; and want to update it on the client you could something like this:</span><br><span class=\"line\"></span><br><span class=\"line\">[Command]</span><br><span class=\"line\">public void CmdRecuestNewValues()&#123;</span><br><span class=\"line\">RpcGiveNewValues(exampleValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[ClientRpc]</span><br><span class=\"line\">public void RpcGiveNewValues(float value)&#123;</span><br><span class=\"line\">exampleValue = value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">then if you call the CmdRecuestNewValues(); command you will update you values.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2020-2-14\"><a href=\"#2020-2-14\" class=\"headerlink\" title=\"2020.2.14\"></a>2020.2.14</h3><p>unity URP vs HDRP</p>\n<h3 id=\"2020-2-19\"><a href=\"#2020-2-19\" class=\"headerlink\" title=\"2020.2.19\"></a>2020.2.19</h3><p>刷leetcode，首页整好看点！！！找个模板，后端用wordpress集成什么意思？？<br>域名备案终于下来咯</p>\n<h3 id=\"2020-3-9\"><a href=\"#2020-3-9\" class=\"headerlink\" title=\"2020.3.9\"></a>2020.3.9</h3><p>ubuntu上不要用系统代理（更新conda包会报错未知sock版本），chrome用Omega插件，命令行用proxychain4<br>Skynet<br>腾讯云上想用skynet的话要用ubuntu<br>这样的话主页要换成nginx，不想装图形界面了，用共享文件夹samba远程写脚本，到linux下build  </p>\n<h3 id=\"2020-3-10\"><a href=\"#2020-3-10\" class=\"headerlink\" title=\"2020.3.10\"></a>2020.3.10</h3><p>云服务器重装了ubuntu，用vscode remote development就可以远程调试，ssh添加了两对，一是新建的Home，二是github用的在.ssh里的一对<br><a href=\"https://blog.csdn.net/qq_28719743/article/details/84872396\" target=\"_blank\" rel=\"noopener\">samba配置教程</a><br>传文件用sftp就好，局域网可以用samba</p>\n<h3 id=\"2020-3-11\"><a href=\"#2020-3-11\" class=\"headerlink\" title=\"2020.3.11\"></a>2020.3.11</h3><figure class=\"highlight nginx\"><figcaption><span>-s reload ```  </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[conf](https://blog.csdn.net/WanJiaBaoBao/article/details/83349622)  </span><br><span class=\"line\"><span class=\"attribute\">Nginx</span> location设置二级域名时 root下边要有这个名字的文件夹  </span><br><span class=\"line\">``` bash</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">        <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;     <span class=\"comment\">#1.你想让你的这个项目跑在哪个端口</span></span><br><span class=\"line\">        <span class=\"attribute\">server_name</span> providencezhang.cn;     <span class=\"comment\">#2.当前服务器ip</span></span><br><span class=\"line\">       \t<span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">        \t<span class=\"attribute\">root</span> /home/ubuntu/ftp/www/home;     <span class=\"comment\">#3.dist文件的位置(我是直接放在home目录下了) </span></span><br><span class=\"line\">            <span class=\"comment\"># try_files $uri $uri/ /index.html;     #4.重定向,内部文件的指向(照写)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"attribute\">location</span> /static &#123;</span><br><span class=\"line\">        \t<span class=\"attribute\">alias</span> /home/ubuntu/github/simpleweb;     <span class=\"comment\">#3.dist文件的位置(我是直接放在home目录下了) </span></span><br><span class=\"line\">            <span class=\"comment\"># try_files $uri $uri/ /index.html;     #4.重定向,内部文件的指向(照写)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"attribute\">location</span> /api &#123;  <span class=\"comment\">#4.当请求跨域时配置端口转发</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://175.24.57.128:8848/api; <span class=\"comment\">#5.转发地址</span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2020-3-12\"><a href=\"#2020-3-12\" class=\"headerlink\" title=\"2020.3.12\"></a>2020.3.12</h3><p>用firewall-cmd开nginx的80端口</p>\n<h3 id=\"2020-3-13\"><a href=\"#2020-3-13\" class=\"headerlink\" title=\"2020.3.13\"></a>2020.3.13</h3><p>最终目标：多人在线游戏，用dots  </p>\n<ol>\n<li>skynet源码  </li>\n<li>简单demo跑通逻辑（登陆，心跳，消息机制）</li>\n<li>客户端开发</li>\n<li>前后端连接</li>\n</ol>\n<h3 id=\"2020-3-14\"><a href=\"#2020-3-14\" class=\"headerlink\" title=\"2020.3.14\"></a>2020.3.14</h3><p><a href=\"https://echo.xuchaoji.com/index.php/archives/110/\" target=\"_blank\" rel=\"noopener\">git代理设置</a></p>\n<h3 id=\"2020-3-26\"><a href=\"#2020-3-26\" class=\"headerlink\" title=\"2020.3.26\"></a>2020.3.26</h3><p>dots到webgl 会出现问题 <a href=\"https://forum.unity.com/threads/bug-crash-with-a-fresh-project-on-ios-monopinvokecallback.827634/\" target=\"_blank\" rel=\"noopener\">link</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t         # 测试配置是否成功</span><br><span class=\"line\">sudo nginx -s reload  # 重启服务</span><br></pre></td></tr></table></figure></p>\n<p>xlua的热更到webgl有问题</p>\n","slug":"CloudServer","updated":"2020-03-31T09:55:10.587Z","comments":true,"link":"","permalink":"/2020/02/12/CloudServer/","excerpt":"","categories":[],"tags":[{"name":"云服务","slug":"云服务","permalink":"/tags/云服务/"},{"name":"腾讯云","slug":"腾讯云","permalink":"/tags/腾讯云/"}]},{"title":"校招学习笔记","date":"2019-09-16T08:41:40.000Z","path":"2019/09/16/校招学习笔记/","text":"笔试计算机网络资料TCP创建连接：三次握手释放连接：四次挥手 SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。 TLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。 操作系统数据库BCNF（修正的第三范式3NF） C++C++ &amp; C#/Unity notebook 数据结构与算法github 贪心算法实例 位运算相关 （重要）单调栈：link 并查集：link1leetcode 990 等式方程的可满足性定义：根节点作为代表元，代表一类数据；每个数据都存一个自己的父节点；优化：由于是树形结构，肯定绕不开树的高度这个问题（越高查询效率越慢） 路径压缩：查询过程中，更改节点指向，降低树高——隔代压缩/完全压缩 按秩合并：秩为树高或者节点个数（1、2两种方法选一即可） 线段树，有点谜 十大排序 冒泡：两层循环，两两比较12345678template&lt;typename T&gt; //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符void bubble_sort(T arr[], int len) &#123; int i, j; for (i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) swap(arr[j], arr[j + 1]);&#125; 选择：未排序序列里找最小（大）的放到最前边12345678910template&lt;typename T&gt; //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（&gt;）的運算子功能void selection_sort(std::vector&lt;T&gt;&amp; arr) &#123; for (int i = 0; i &lt; arr.size() - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; arr.size(); j++) if (arr[j] &lt; arr[min]) min = j; std::swap(arr[i], arr[min]); &#125;&#125; 插入：未排序序列的第一个，插入到已排序序列中的合适位置，已排序序列从后往前遍历arr[j+1] = arr[j]插排的问题在于：如果在后面来了一个特别小的元素，需要全部移动，那么排序的效率特别低。1234567891011void insertion_sort(int arr[],int len)&#123; for(int i=1;i&lt;len;i++)&#123; int key=arr[i]; int j=i-1; while((j&gt;=0) &amp;&amp; (key&lt;arr[j]))&#123; arr[j+1]=arr[j]; j--; &#125; arr[j+1]=key; &#125;&#125; 希尔（插入排序改进）：n个数先分n/2组(gap = n/2)，分组进行插入排序（n=10，也就是1st数和6th数一组进行插入排序，2-7，3-8，4-9，5-10），然后gap = n/4…123456789101112131415template&lt;typename T&gt;void shell_sort(T array[], int length) &#123; int h = 1; while (h &lt; length / 3) &#123; h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; length; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123; std::swap(array[j], array[j - h]); &#125; &#125; h = h / 3; &#125;&#125; 快排：第一个做pivot，小于大于放左右，在迭代12345678910111213141516171819202122232425//严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) &#123; int pivot = A[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123; --high; &#125; A[low] = A[high]; while (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123; ++low; &#125; A[high] = A[low]; &#125; A[low] = pivot; return low; &#125; void QuickSort(int A[], int low, int high) //快排母函数 &#123; if (low &lt; high) &#123; int pivot = Paritition1(A, low, high); QuickSort(A, low, pivot - 1); QuickSort(A, pivot + 1, high); &#125; &#125; 归并：分两半，分不到不能分，在一层一层合并回来；合并的时候保证每层有序12345678910111213141516171819202122232425262728293031void Merge(vector&lt;int&gt; &amp;Array, int front, int mid, int end) &#123; // preconditions: // Array[front...mid] is sorted // Array[mid+1 ... end] is sorted // Copy Array[front ... mid] to LeftSubArray // Copy Array[mid+1 ... end] to RightSubArray vector&lt;int&gt; LeftSubArray(Array.begin() + front, Array.begin() + mid + 1); vector&lt;int&gt; RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1); int idxLeft = 0, idxRight = 0; LeftSubArray.insert(LeftSubArray.end(), numeric_limits&lt;int&gt;::max()); RightSubArray.insert(RightSubArray.end(), numeric_limits&lt;int&gt;::max()); // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i] for (int i = front; i &lt;= end; i++) &#123; if (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) &#123; Array[i] = LeftSubArray[idxLeft]; idxLeft++; &#125; else &#123; Array[i] = RightSubArray[idxRight]; idxRight++; &#125; &#125;&#125;void MergeSort(vector&lt;int&gt; &amp;Array, int front, int end) &#123; if (front &gt;= end) return; int mid = (front + end) / 2; MergeSort(Array, front, mid); MergeSort(Array, mid + 1, end); Merge(Array, front, mid, end);&#125; 堆排序，构建最大/最小堆时： 父结点索引：(i-1)/2（这里计算机中的除以2，省略掉小数） 左孩子索引：2*i+1 右孩子索引：2*i+2 123456789101112131415161718192021222324252627void max_heapify(int arr[], int start, int end) &#123; // 建立父節點指標和子節點指標 int dad = start; int son = dad * 2 + 1; while (son &lt;= end) &#123; // 若子節點指標在範圍內才做比較 if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的 son++; if (arr[dad] &gt; arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數 return; else &#123; // 否則交換父子內容再繼續子節點和孫節點比較 swap(arr[dad], arr[son]); dad = son; son = dad * 2 + 1; &#125; &#125;&#125;void heap_sort(int arr[], int len) &#123; // 初始化，i從最後一個父節點開始調整 for (int i = len / 2 - 1; i &gt;= 0; i--) max_heapify(arr, i, len - 1); // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢 for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr[0], arr[i]); max_heapify(arr, 0, i - 1); &#125;&#125; 计数/桶排序 基数排序 稳定性：稳定性是一个特别重要的评估标准。稳定的算法在排序的过程中不会改变元素彼此的位置的相对次序,反之不稳定的排序算法经常会改变这个次序,这是我们不愿意看到的。 查找算法 动态规划详解 时间复杂度计算：参考资料 对数阶怎么来的：循环的时候i不是+常数来的，是i=i*2这样乘来的就是对数阶复杂度了1for(i&lt;100) i=i*2; $i^2=100$ -&gt; $O(log_{2}100)$ 二叉树计算公式总结： n个节点的二叉树一共有((2n)!)/(n! * (n+1)!)种 catalan数 n层二叉树的第n层最多为2^(n-1)个 二叉树节点计算公式 N = n0+n1+n2，度为0的叶子节点比度为2的节点数多一个。N=1n1+2n2+1 对任何一棵二叉树T，如果其终端节点数为n0，度为2的节点数为n2，则n0=n2+1 具有n个节点的完全二叉树的深度为log2(n + 1) 图计算公式总结：N个点的无向完全图边数为：N*（N-1）/2；先手获胜必须总数为奇数；N=1,2,3,……,9,10代入公式，为奇数的只有N=2,3,6,7,10这5个。 无向图：遍历：DFS用栈 / BFS用队列邻接矩阵法存图 占用空间与什么有关在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图，则其中的极大连通子图称为连通分量，这里所谓的极大是指子图中包含的顶点个数极大。A,边的条数为C（n,2）=n(n-1)/2B,G是完全图，必定是连通图。所以连通分量只有其自身C，G是完全图，必定是连通图D，每个顶点都与其余n-1个顶点相连，则n个顶点度的和为n(n-1) 无向带权图的最小生成树算法——Prim及Kruskal算法思路 带权图分为有向和无向，无向图的最短路径又叫做最小生成树，有prime算法和kruskal算法；有向图的最短路径算法有dijkstra算法和floyd算法。 最小生成树（prime算法、kruskal算法） 和 最短路径算法（floyd、dijkstra） 广义表：head() 返回列表的第一个元素；tail() 返回列表的删去第一个元素之后的剩余列表； hash：装填因子：对5个对象进行hash,而内存中，准备了20个位置，那么还有15个空位，最后装填因子就是5/20 = 0.25，所以装填因子越小，产生冲突的可能越小。1、hash索引仅满足“=”、“IN”和“&lt;=&gt;”查询，不能使用范围查询因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。2、hash索引无法被用来进行数据的排序操作由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样，所以数据库无法利用hash索引中的值进行排序操作。3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。 循环队列：front=rear意味着队空或者队满，再入队或者出队就要上溢或者下溢了 杂项：KMP算法：一种不舍弃之前匹配信息的字符串匹配算法，时间复杂度O(m+n) 其中next[j]就是第j个元素前j-1个元素首尾重合部分个数加一输出受限的双端队列,即删除限制在一端进行,而插入仍允许在两端进行. 其他知识点创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 正则表达式： leetcode刷题109 有序链表转换二叉搜索树 快慢指针加递归 每次递归，都是把链表分成两段；前面的那个链表末尾必须要加上nullptr，才算是分成了两个链表。 56 合并区间 push_back 和 emplace_back的区别，e更好 因为少一个构造函数 emplace可以直接传入构造对象需要的元素，然后自己调用其构造函数！ 712 两个字符串的最小ascii删除和 DP LCS 最长公共子序列（Longest Common Sequence） 最优子结构/重叠子问题（用dp就是查表得到的不用重新计算） 407 接雨水2 208 实现前缀树 207 课程表有向无权图是否存在环，用拓扑排序（记入度、还有邻接表，然后从入度为1的点开始删边就可以了，看最后入度是否都为0）判断，还可以使用DFS 面试题41. 数据流中的中位数二分查找插入用到了模板函数lower_bound/upper_bound(store.begin(), store.end(), num)时间复杂度 $O(logN) + O(N)$ 约等于$O(N)$（重要）优先队列priority_queue 时间复杂度$O(logN)$ 本质上是个堆，一棵完全二叉树123456//对于基础类型 默认是大顶堆 priority_queue&lt;int&gt; a; //等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a; // 这里一定要有空格，不然成了右移运算符↓↓ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; c; //这样就是小顶堆 820 单词的压缩编码：字典树 面试题62. 圆圈中最后剩下的数字：约瑟夫环12345678910int f(int n, int m) &#123; if (n == 1) return 0; int x = f(n - 1, m); return (m + x) % n;&#125;int lastRemaining(int n, int m) &#123; return f(n, m);&#125; 123456int lastRemaining(int n, int m) &#123; int f = 0; for (int i = 2; i != n + 1; ++i) f = (m + f) % i; return f; &#125; 135 分发糖果（头条笔试题） 887 鸡蛋掉落，vivo笔试题第一种方法： 问题转换成dp[i][j]表示有i个鸡蛋、j次扔鸡蛋次数时可以测的最多楼层，扔鸡蛋次数最多不会超过N次（线性扫描）；所以当dp[i][j]等于N的时候j的值就是我们想要的答案 dp[j][m] = dp[j - 1][m - 1] + dp[j][m-1] + 1第二中状态定义和转移公式： 按着题意来dp[k][n]表示k个鸡蛋，n层楼的最少测试次数，dp[K,N] = 1+min_{1","raw":"---\ntitle: 校招学习笔记\ndate: 2019-09-16 16:41:40\nmathjax: true\ntags: \n    - 刷题\n---\n\n# 笔试\n\n## 计算机网络\n\n[资料](https://github.com/huihut/interview#%EF%B8%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)  \nTCP创建连接：三次握手  \n释放连接：四次挥手  \n\nSSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。  \n\nTLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。  \n\n\n## 操作系统\n\n\n\n## 数据库\n\n[BCNF（修正的第三范式3NF）](https://blog.csdn.net/qq_43079376/article/details/93647335)\n\n## C++\n\n[C++ & C#/Unity notebook](https://taye310.github.io/2019/02/18/lang-notebook/)\n\n## 数据结构与算法\n\n[github](https://github.com/huihut/interview)  \n\n[贪心算法实例](https://leetcode-cn.com/problems/jump-game-ii/)\n\n[位运算相关](https://www.zhihu.com/question/38206659/answer/763034261)\n\n（重要）单调栈：[link](https://blog.csdn.net/lucky52529/article/details/89155694)\n\n并查集：[link1](https://zhuanlan.zhihu.com/p/93647900)  \n[leetcode 990 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-/)  \n定义：根节点作为代表元，代表一类数据；每个数据都存一个自己的父节点；  \n优化：由于是树形结构，肯定绕不开树的高度这个问题（越高查询效率越慢）\n1. 路径压缩：查询过程中，更改节点指向，降低树高——隔代压缩/完全压缩\n2. 按秩合并：秩为树高或者节点个数（1、2两种方法选一即可）\n<div style=\"width:300px\">\n    {% asset_img unionfind.png %}\n</div>\n\n[线段树，有点谜](https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/)\n\n**十大排序**\n\n冒泡：两层循环，两两比较  \n``` C++\ntemplate<typename T> //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(>)运算符\nvoid bubble_sort(T arr[], int len) {\n        int i, j;\n        for (i = 0; i < len - 1; i++)\n                for (j = 0; j < len - 1 - i; j++)\n                        if (arr[j] > arr[j + 1])\n                                swap(arr[j], arr[j + 1]);\n}\n```\n\n选择：未排序序列里找最小（大）的放到最前边  \n``` C++\ntemplate<typename T> //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（>）的運算子功能\nvoid selection_sort(std::vector<T>& arr) {\n        for (int i = 0; i < arr.size() - 1; i++) {\n                int min = i;\n                for (int j = i + 1; j < arr.size(); j++)\n                        if (arr[j] < arr[min])\n                                min = j;\n                std::swap(arr[i], arr[min]);\n        }\n}\n```\n\n插入：未排序序列的第一个，插入到已排序序列中的合适位置，已排序序列从后往前遍历arr[j+1] = arr[j]  \n插排的问题在于：如果在后面来了一个特别小的元素，需要全部移动，那么排序的效率特别低。  \n``` C++\nvoid insertion_sort(int arr[],int len){\n        for(int i=1;i<len;i++){\n                int key=arr[i];\n                int j=i-1;\n                while((j>=0) && (key<arr[j])){\n                        arr[j+1]=arr[j];\n                        j--;\n                }\n                arr[j+1]=key;\n        }\n}\n```\n\n希尔（插入排序改进）：n个数先分n/2组(gap = n/2)，分组进行插入排序（n=10，也就是1st数和6th数一组进行插入排序，2-7，3-8，4-9，5-10），然后gap = n/4...  \n``` C++\ntemplate<typename T>\nvoid shell_sort(T array[], int length) {\n    int h = 1;\n    while (h < length / 3) {\n        h = 3 * h + 1;\n    }\n    while (h >= 1) {\n        for (int i = h; i < length; i++) {\n            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {\n                std::swap(array[j], array[j - h]);\n            }\n        }\n        h = h / 3;\n    }\n}\n```\n\n快排：第一个做pivot，小于大于放左右，在迭代  \n``` C++\n//严蔚敏《数据结构》标准分割函数\n Paritition1(int A[], int low, int high) {\n   int pivot = A[low];\n   while (low < high) {\n     while (low < high && A[high] >= pivot) {\n       --high;\n     }\n     A[low] = A[high];\n     while (low < high && A[low] <= pivot) {\n       ++low;\n     }\n     A[high] = A[low];\n   }\n   A[low] = pivot;\n   return low;\n }\n\n void QuickSort(int A[], int low, int high) //快排母函数\n {\n   if (low < high) {\n     int pivot = Paritition1(A, low, high);\n     QuickSort(A, low, pivot - 1);\n     QuickSort(A, pivot + 1, high);\n   }\n }\n```\n\n归并：分两半，分不到不能分，在一层一层合并回来；合并的时候保证每层有序  \n``` C++\nvoid Merge(vector<int> &Array, int front, int mid, int end) {\n    // preconditions:\n    // Array[front...mid] is sorted\n    // Array[mid+1 ... end] is sorted\n    // Copy Array[front ... mid] to LeftSubArray\n    // Copy Array[mid+1 ... end] to RightSubArray\n    vector<int> LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);\n    vector<int> RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);\n    int idxLeft = 0, idxRight = 0;\n    LeftSubArray.insert(LeftSubArray.end(), numeric_limits<int>::max());\n    RightSubArray.insert(RightSubArray.end(), numeric_limits<int>::max());\n    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]\n    for (int i = front; i <= end; i++) {\n        if (LeftSubArray[idxLeft] < RightSubArray[idxRight]) {\n            Array[i] = LeftSubArray[idxLeft];\n            idxLeft++;\n        } else {\n            Array[i] = RightSubArray[idxRight];\n            idxRight++;\n        }\n    }\n}\n\nvoid MergeSort(vector<int> &Array, int front, int end) {\n    if (front >= end)\n        return;\n    int mid = (front + end) / 2;\n    MergeSort(Array, front, mid);\n    MergeSort(Array, mid + 1, end);\n    Merge(Array, front, mid, end);\n}\n```\n\n堆排序，构建最大/最小堆时：\n1. 父结点索引：(i-1)/2（这里计算机中的除以2，省略掉小数）\n2. 左孩子索引：2*i+1\n3. 右孩子索引：2*i+2  \n\n``` C++\nvoid max_heapify(int arr[], int start, int end) {\n    // 建立父節點指標和子節點指標\n    int dad = start;\n    int son = dad * 2 + 1;\n    while (son <= end) { // 若子節點指標在範圍內才做比較\n        if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的\n            son++;\n        if (arr[dad] > arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數\n            return;\n        else { // 否則交換父子內容再繼續子節點和孫節點比較\n            swap(arr[dad], arr[son]);\n            dad = son;\n            son = dad * 2 + 1;\n        }\n    }\n}\n\nvoid heap_sort(int arr[], int len) {\n    // 初始化，i從最後一個父節點開始調整\n    for (int i = len / 2 - 1; i >= 0; i--)\n        max_heapify(arr, i, len - 1);\n    // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢\n    for (int i = len - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        max_heapify(arr, 0, i - 1);\n    }\n}\n```\n\n计数/桶排序  \n\n基数排序\n\n稳定性：稳定性是一个特别重要的评估标准。稳定的算法在排序的过程中不会改变元素彼此的位置的相对次序,反之不稳定的排序算法经常会改变这个次序,这是我们不愿意看到的。\n\n**查找算法**\n\n\n**动态规划**\n[详解](https://mp.weixin.qq.com/s/yEfrTK7UhRN0XX0_FVLyGA)\n\n**时间复杂度计算：**\n[参考资料](https://blog.csdn.net/kun1280437633/article/details/80770296)  \n\n对数阶怎么来的：循环的时候i不是+常数来的，是i=i*2这样乘来的就是对数阶复杂度了  \n``` bash\nfor(i<100) i=i*2;\n```\n$i^2=100$ -> $O(log_{2}100)$ \n\n**二叉树计算公式总结：**  \n1. n个节点的二叉树一共有((2n)!)/(n! * (n+1)!)种 [catalan数](https://blog.csdn.net/iG_xdd/article/details/79808519)\n2. n层二叉树的第n层最多为2^(n-1)个\n3. 二叉树节点计算公式 N = n0+n1+n2，度为0的叶子节点比度为2的节点数多一个。N=1*n1+2*n2+1\n4. 对任何一棵二叉树T，如果其终端节点数为n0，度为2的节点数为n2，则n0=n2+1\n5. 具有n个节点的完全二叉树的深度为log2(n + 1)\n\n**图计算公式总结：**  \nN个点的无向完全图边数为：N*（N-1）/2；  \n先手获胜必须总数为奇数；  \nN=1,2,3,......,9,10代入公式，为奇数的只有N=2,3,6,7,10这5个。  \n\n> **无向图：**  \n遍历：DFS用栈 / BFS用队列  \n邻接矩阵法存图 占用空间与什么有关  \n在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图，则其中的极大连通子图称为连通分量，这里所谓的极大是指子图中包含的顶点个数极大。  \nA,边的条数为C（n,2）=n(n-1)/2  \nB,G是完全图，必定是连通图。所以连通分量只有其自身  \nC，G是完全图，必定是连通图  \nD，每个顶点都与其余n-1个顶点相连，则n个顶点度的和为n(n-1)  \n\n> **无向带权图的最小生成树算法——Prim及Kruskal算法思路**  \n 带权图分为有向和无向，无向图的最短路径又叫做最小生成树，有prime算法和kruskal算法；有向图的最短路径算法有dijkstra算法和floyd算法。  \n [最小生成树（prime算法、kruskal算法） 和 最短路径算法（floyd、dijkstra）](https://www.cnblogs.com/aiyelinglong/archive/2012/03/26/2418707.html)  \n\n> **广义表：**  \nhead() 返回列表的第一个元素；\ntail() 返回列表的删去第一个元素之后的剩余列表；  \n\n> **hash：**  \n装填因子：对5个对象进行hash,而内存中，准备了20个位置，那么还有15个空位，最后装填因子就是5/20 = 0.25，所以装填因子越小，产生冲突的可能越小。  \n1、hash索引仅满足“=”、“IN”和“<=>”查询，不能使用范围查询  \n因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。  \n2、hash索引无法被用来进行数据的排序操作  \n由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样，所以数据库无法利用hash索引中的值进行排序操作。  \n3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。  \n4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。  \n对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。  \n\n> **循环队列：**  \nfront=rear意味着队空或者队满，再入队或者出队就要上溢或者下溢了  \n\n> **杂项：**  \nKMP算法：一种不舍弃之前匹配信息的字符串匹配算法，时间复杂度O(m+n) 其中*next[j]就是第j个元素前j-1个元素首尾重合部分个数加一*  \n输出受限的双端队列,即删除限制在一端进行,而插入仍允许在两端进行.  \n\n## 其他知识点\n\n创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。  \n结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。  \n行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。  \n\n正则表达式：\n\n## leetcode刷题\n\n109 有序链表转换二叉搜索树\n    快慢指针加递归 每次递归，都是把链表分成两段；前面的那个链表末尾必须要加上nullptr，才算是分成了两个链表。\n\n56  合并区间\n    push_back 和 emplace_back的区别，e更好 因为少一个构造函数  \n    [emplace可以直接传入构造对象需要的元素，然后自己调用其构造函数！](https://blog.csdn.net/Kprogram/article/details/82055673)  \n\n712 两个字符串的最小ascii删除和\n    DP LCS 最长公共子序列（Longest Common Sequence）\n    最优子结构/重叠子问题（用dp就是查表得到的不用重新计算）\n\n407 接雨水2\n\n208 实现前缀树  \n\n207 课程表  \n有向无权图是否存在环，用拓扑排序（记入度、还有邻接表，然后从入度为1的点开始删边就可以了，看最后入度是否都为0）判断，还可以使用DFS\n\n面试题41. 数据流中的中位数  \n二分查找插入用到了模板函数lower_bound/upper_bound(store.begin(), store.end(), num)  \n时间复杂度 $O(logN) + O(N)$ 约等于$O(N)$  \n（重要）[优先队列priority_queue](https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/solution/xiang-jie-you-xian-dui-lie-tan-xin-suan-fa-by-z1m/) 时间复杂度$O(logN)$ 本质上是个堆，一棵完全二叉树  \n``` C++\n//对于基础类型 默认是大顶堆\n    priority_queue<int> a; \n    //等同于 priority_queue<int, vector<int>, less<int> > a;\n     \n    //      这里一定要有空格，不然成了右移运算符↓↓\n    priority_queue<int, vector<int>, greater<int> > c;  //这样就是小顶堆\n```\n\n820 [单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words/)：字典树  \n\n[面试题62](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/). 圆圈中最后剩下的数字：约瑟夫环  \n``` C++\nint f(int n, int m) {\n    if (n == 1)\n        return 0;\n    int x = f(n - 1, m);\n    return (m + x) % n;\n}\n\nint lastRemaining(int n, int m) {\n    return f(n, m);\n}\n```\n``` C++\nint lastRemaining(int n, int m) {\n        int f = 0;\n        for (int i = 2; i != n + 1; ++i)\n            f = (m + f) % i;\n        return f;\n    }\n```\n\n135 [分发糖果（头条笔试题）](https://leetcode-cn.com/problems/candy/)  \n\n887 [鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)，vivo笔试题  \n第一种方法： 问题转换成dp[i][j]表示有i个鸡蛋、j次扔鸡蛋次数时可以测的最多楼层，扔鸡蛋次数最多不会超过N次（线性扫描）；所以当dp[i][j]等于N的时候j的值就是我们想要的答案  \n$$dp[j][m] = dp[j - 1][m - 1] + dp[j][m-1] + 1$$\n\n第二中状态定义和转移公式： 按着题意来dp[k][n]表示k个鸡蛋，n层楼的最少测试次数，$$dp[K,N] = 1+min_{1<=X<=N}(max(dp(K-1,X-1),dp(K,N-X)))$$  \n\n**剑指offer系列：**  \nsize_t: 与int固定四个字节不同有所不同,size_t的取值range是目标平台下最大可能的数组尺寸,一些平台下size_t的范围小于int的正数范围,又或者大于unsigned int. 使用Int既有可能浪费，又有可能范围不够大。  \n``` C++\nstring replaceSpace(string s) {\n    size_t pos;\n    while(true){\n        pos = s.find(\" \");\n        if(pos<string::npos){\n            s.replace(pos,1,\"%20\");\n        }else{\n            break;\n        }\n    }\n    return s;\n}\n```\n\n面试题16. 数值的整数次方： 可以用位运算，$3^5 = 3^{101_{2}} = 3^{2^2+2^0} = 9^2*3^1$  \n\nvector的insert方法使用迭代器参数可以用来合并vector  \n\n``` C++\nwhile(!s.empty()&&pos<popped.size()&&popped[pos] == s.top()){//三个条件的顺序很重要\n```\n\n中序遍历用 栈  \n\n837.新21点和 983 旅行票价 动态规划+从后遍历经典题；看起来很麻烦，代码很简单  \n\n63.不同路径II；动态规划求解而非递归，用到了滚动数组来优化dp，滚动数组应该多看一下  \n\n## 牛客刷题\n\nunion的大小取决于它所有的成员中，占用空间最大的一个成员的大小，并且需要内存对齐  \n\nc++的类体中，方法以外的区域不允许有初始化，简单类型是可以的，但是有构造函数的复杂对象则不行了，比如string对象！\n\n``` bash\nerror,expected identifier before numeric constant\n```\n\n### 猿辅导真题\n\n[击鼓传花](https://www.nowcoder.com/test/question/done?tid=35339605&qid=808488#summary)，k个人传n次，最后一个人要是第一个人  \ndp可以70%，要用矩阵快速幂没用过  \n\n\n\n# 面试\n\n项目经历的star原则 p6  \n\n## 面试问题总结 \n\n分别在什么时候使用引用和指针：指向的对象不为空的时候使用\n\n为什么要分栈和对，不能合并？：栈的好处是：方便、快、有效避免内存碎片化。栈的问题是：不利于管理大内存、数据的生命周期难于控制，所以栈不利于动态地管理并且有效地利用宝贵的内存资源。于是我们有了堆  \n\n[伽马校正（gamma correction）](https://blog.csdn.net/w450468524/article/details/51649651)：需要注意的是，像法线贴图，高光贴图等通常是在线性空间中生成的的，无需进行反伽马校正  \n\n[z-fighting](https://zhuanlan.zhihu.com/p/78769570)：模型闪烁的问题  \n\nsetpass call & batches：一次cpu把数据交给gpu处理叫一个drawcall。draw位于setpasscall 和batch中。使用相同材质信息draw call 才能放到一个batch中。一个材质球引用的shader可以有多个pass，因此携带这个材质球的物体会被渲染多次，\"激活\"一一个pass的过程就是set pass call。因此改变影响 pass的行为都会触发一次set pass call（比如游戏运行中开启阴影进而影响了渲染管线），因此把set pass call 作为影响drawcall的一个标准。  \n\n如何检测内存泄漏，怎么写代码可以尽可能避免内存泄漏：  \n判断内存是否泄漏的方法：\n* 检查资源的使用情况，特别是纹理、网格等资源的使用\n* 通过Profiler来检测WebStream或SerializedFile的使用情况\n* 通过Android PSS/iOS Instrument反馈的App线程内存来查看\n\nC#多线程  \n``` C++\nclass A\n{\n    virtual int test () = 0;\n}\n\nclass B : public A\n{\npublic :\n    virtual int test () {\n        return 10;\n    }\n}\n```\n\nC#attribute  \n\n哈希解决冲突：开放定址法，再哈希法，链地址法  \n这个方法的基本思想是：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止  \n链地址法解决冲突的做法是：如果哈希表空间为 0 ～ m - 1 ，设置一个由 m 个指针分量组成的一维数组 ST[ m ], 凡哈希地址为 i 的数据元素都插入到头指针为 ST[ i ] 的链表中。这种方法有点近似于邻接表的基本思想，且这种方法适合于冲突比较严重的情况  \n\n哈希索引和b+树索引：\n* 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；\n* 从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；\n同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；\n* 哈希索引也不支持多列联合索引的最左匹配规则；\n* B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。\n\nC#的虚函数的override和new：前者是重写（覆盖），后者只是隐藏了父类中的虚函数，如果用父类指针指向子类对象，调用new的函数，调用的还是父类的。总结通俗的讲：new：父类看不到子类的new的新方法，子类看不到父类被new的方法， 而override: 父类和子类看到的都是子类override后的方法。\n\n线程池的概念：避免频繁创建销毁线程，等待队列、线程管理\n\nUnity的生命周期：awake，update，fixedupdate，lateupdate\n\n为什么IP在网络层，TCP、UDP在传输层，它们是怎么工作的？  \nip在网络层，负责路由；tcp/udp在传输层负责一有链接或者无连接的方式传送消息\n\nDrawCall的含义就是CPU调用图像编程接口，以命令GPU进行渲染的操作。\n\nlua元表：设置了元表的table，如果元表的index是个table，外层表索引的数据为nil就上元表的这个index里找\n\nfixedupdate\\update\\lateupdate：fixed物理相关的都放在里边，因为他是固定时间间隔（也是每帧update一次）；update是每帧一次，但是时间间隔不一定，看渲染效率；late在update之后。  \n\n模板和宏的区别：\n1. 宏是在预处理阶段处理，模板是在编译阶段处理\n2. 宏不会进行类型检查，只会单纯的进行文本替换，模板会进行类型检查。比如下面代码模板就会出错，而宏不会\n3. 宏直接就可以产生代码，而编译器遇到模板定义时，并不产生代码，只有当模板实例化后时才会产生代码。\n\n协程底层实现：函数返回一个迭代器类型，函数中可以多次yield return就像数组下标一样\n\n如何做虚拟地址映射：虚拟地址是4g，user3，kernel1，结构是页表\n\n进程如何分配地址：堆栈、静态、常量、自由\n\n[C++如何保证类不被继承](https://blog.csdn.net/isunbin/article/details/99568217)：借助友元来实现，因为友元这个特性是不可以被继承的。如果一个类的构造函数要借助它的友元类，那么继承了这个类的类就无法构造自己的对象。从而杜绝了被继承  \n``` C++\n#include <iostream>\nusing namespace std;\nclass C;\n \nclass BASE {\nprivate:\n    BASE() {}\n    friend class C;    //设class C为class BASE的友元\n};\n \nclass C : public virtual BASE\n{};\n \nclass D : public C \n{};\n \nint main()\n{\n    C c;\n    //D d;   不可以实例化对象\n}\n```\n\nMatcap的原理并不复杂，就是使用一张中间为球面的图片作为不同法线方向的光照颜色，然后将这些颜色根据模型的法线信息渲染到相应位置。用于均一表面反射材质的着色器，在Zbrush/Mudbox等软件中被广泛运用。它借助一幅含有球面的图片作为视线空间的环境映射，计算成本非常低廉，当相机不转动时视觉效果极其出色。\n\n计算机中的流水线：每条指令分成多步，各指令间轮转顺序执行，实现并行效果（实际还是一条条执行的）；效率瓶颈，就让每一步更细分\n\n[帧同步与状态同步](https://blog.csdn.net/shaocize/article/details/89702151)：状态tcp，帧udp；同步每个单位的状态，单位数量增加数据量增加，帧同步同步操作，操作通过运算可以达到一致的状态（游戏逻辑执行在本地，所以不好防外挂，防的方法可以算状态hash对比，或者记录战斗数据分析），单位再多同步数据量也不会增加\n\nudp如何避免丢包：\n原因：\n1. 接收端处理时间过长导致丢包\n2. 发送的包巨大丢包\n3. 发送的包较大，超过接受者缓存导致丢包\n4. 发送的包频率太快\n\nnew和malloc的区别：  \nnew/delete（C++运算符）会自动调用构造函数和析构函数，底层是malloc/free（标准库函数，编译器无权控制其调用构造/析构函数），比其更智能  \n失败后前者抛异常，后者返回NULL，成功返回的都是指针  \n\n进程线程的区别：已有  \n\nvector/set实现机制：  \nvector用数组,set用的时红黑树。Vector内存分配使用的是STL的allocator分配器，采用二层分配机制，申请内存大于128K时使用malloc，小于128K时使用内存池，接着讲了一下内存池的机制，维护16个空闲链表之类的  \nvector动态增加大小时，并不是在原空间之后持续新空间（因为根本无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间，因此，一旦引起空间重新配置，指向原vector的所有迭代器都失效了，这是程序员易犯的一个错误，务必小心  \nset 底层红黑树（平衡二叉树）目的是为了高效检索\n\n数据库索引作用，怎么实现的：  \n高效获取数据，BTree索引、哈希索引、全文索引等  \n[BST、BTree、B+Tree](https://zhuanlan.zhihu.com/p/27700617)  \n\n虚函数如何实现动态多态的：  \n动态多态与静态多态，静态多态就是在系统编译期间就可以确定程序执行到这里将要执行哪个函数，函数的重载，对象名加点操作符执行成员函数等；\n多态的实现：分为两类，编译时的多态与运行时的多态。前者在编译的过程中确定了同名的具体操作对象，而后者是在程序运行过程中才多态地确定操作所指向的对象。这种确定操作具体对象的过程就是绑定。绑定工作在编译连接阶段完成的情况为静态绑定，在程序运行过程中完成的情况是动态绑定。  \n重载overload：函数名相同，但是函数参数不同。调用时根据参数的不同决定调用哪一个函数；  \n多态：函数名相同，函数形参也相同。调用时根据函数类型是虚函数还是普通成员函数决定调用哪一个。  \n\n纯虚函数的作用：向子类提供接口，定义纯虚函数的类为抽象类  \n\n结构体和类的区别：\n\n结构体为什么要字节对齐：\n\nLCA算法：\n\n### 图形学\n\n碰撞检测：\n1. 两个立方体的碰撞检测：\n   1. AABB（axis-aligned bounding box，不可旋转，有向包围盒）：\n   2. OBB（Oriented Bounding Box，可旋转）：\n2. 球体的碰撞检测：简单，圆心距离与半径相比较\n3. 三角形是否相交：遍历A的每条边，看有没有穿过B的\n\nHDR到LDR：tonemapping（色调映射）\n\n# 面经复盘\n\n## 字节跳动--游戏研发\n\n<div style=\"width:300px\">\n    {% asset_img jrtt1.jpg %}\n</div>\n\n1. \n```\n指针常量：int * const p\n常量指针：const int * p\n```\n\n2. 判断扇形区域内  \n算两点距离（半径） 算两向量夹角  \n\n3. 一万个球，知道圆心位置和半径，如何预处理/数据结构存储，新加球可以最少次数判断是否相交  \n八叉树  \n\n4. 4个人分100金币，第一个人怎么分半数以上人同意（智力题？）  \n给第三个人一个金币，不然他一个也拿不到  \n\n5. 无向图连通最小花费：最小生成树（prime，keruskal）//有向图最短路径（单源dijstra，多源floyd）  \nprime(加点法):每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。  \nkruskal(加边法):初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。\n\ndijkstra：类似prime  \n\nfloyd多源最短路径：动态规划Dis(i,j) = Dis(i,k) + Dis(k,j)  \n\n6. 字符串以词为单位反转  \n两个栈  \n\n7. 顶点着色器/片元着色器作用/什么是片元  \n顶点着色器：分为输入和输出两部分,负责的功能是把输入的数据进行矩阵变换位置,计算光照公式生成逐顶点颜⾊,⽣成/变换纹理坐标.并且把位置和纹理坐标这样的参数发送到片段着色器.  \n片元着色器：处理由光栅化阶段生成的每个片元，最终计算出每个像素的最终颜色。归根结底，实际上就是数据的集合。这个数据集合包含每一个像素的各个颜色分量和像素透明度的值。\n\n*光栅化*，就是计算出1920×1080这么长的RGB数组中，每一个RGB的值\n\n3D场景中将三角形作为基本*图元*\n\n片元是光栅化过程的产物；光栅化是将一个图元转变为一个二维图象，二维图象上每个点都包含了颜色、深度和纹理数据，将该点和相关信息叫做一个片元  \n\n设计模式！工厂/观察者/策略模式？  \n工厂模式：调用工厂只管给个名字，工厂里根据名字实例化对应的对象（选对应接口）；解决了接口选择的问题，拓展方便。\n\n观察者模式：mvc，子类继承一个update方法，使用者在notify所有监听的子类时调用基类update\n\n策略模式：核心是有个context，根据构造函数实例化了strategy的具体一种子类作为context的成员，因此context.excuteStrategy()可以调用context里的特定的strategy实例的doStrategy方法\n\nstl里的trace？  \ntrace()函数？调试用的\n\n工厂模式有几种？？  \n3：简单工厂/工厂模式/抽象工厂（工厂的工厂）\n\n光照模型公式  \n3D渲染中， 物体表面的光照计算公式为：  \n\nI = 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular);  \n\n其中，环境光(ambient)计算公式为：\n\nIambient = Aintensity * Acolor ; (Aintensity表示环境光强度，Acolor表示环境光颜色)\n\n漫反射光(diffuse)计算公式为：\n\nIdiffuse = Dintensity*Dcolor*N·L ; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量) ps:点乘是投影\n\n镜面光照(specular)计算公式为：\n\nIspecular = Sintensity*Scolor*(R·V)n ; (Sintensity表示镜面光照强度，Scolor表示镜面光颜色，R为光的反射向量，V为观察者向量)\n\n综上所得：整个光照公式为：\n\nI = Aintensity * Acolor + Dintensity*Dcolor*N.L + Sintensity*Scolor*(R.V)n ;\n\n将一些值合并，并使用白色作为光照颜色，则上述公式可简化为：\n\nI = A + D*N.L + (R.V)n\n\n类的内存结构  \n[link](https://blog.csdn.net/fenxinzi557/article/details/51995911)  \n记得字节对齐  \n\ncpp文件属性命令行分页栏中加入\n``` bash\n/d1 reportAllClassLayout\n```\n可以查看内存布局  \n包含虚函数的类头部有虚表指针，虚表真正的位置在静态存储区  \n\n``` C++\nchar c;\nint i; //是8字节 因为int之前的要对齐到int的4字节\n```\n类中有虚函数 要+4字节 因为有虚函数表  函数本身不占字节\n继承的子类要先放父类的数据拷贝  \n\n1. 对于基类，如果有虚函数，那么先存放虚函数表指针，然后存放自己的数据成员；如果没有虚函数，那么直接存放数据成员。 \n2. 对于单一继承的类对象，先存放父类的数据拷贝(包括虚函数表指针)，然后是本类的数据。 \n3. 虚函数表中，先存放父类的虚函数，再存放子类的虚函数 \n4. 如果重载了父类的某些虚函数，那么新的虚函数将虚函数表中父类的这些虚函数覆盖。 \n5. 对于多重继承，先存放第一个父类的数据拷贝，在存放第二个父类的数据拷贝，一次类推，最后存放自己的数据成员。其中每一个父类拷贝都包含一个虚函数表指针。如果子类重载了某个父类的某个虚函数，那么该将该父类虚函数表的函数覆盖。另外，子类自己的虚函数，存储于第一个父类的虚函数表后边部分。 \n6. 当对象的虚函数被调用是，编译器去查询对象的虚函数表，找到该函数，然后调用。\n\n构造函数/析构函数/虚函数  \n\n**在构造/析构函数中调用虚函数：** effective c++ 条款9：永远不要在构造函数或析构函数中调用虚函数\n\n<div style=\"width:300px\">\n    {% asset_img jrtt3.jpg %}\n</div>\n\n>> 信号量  \n信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。  \n\n互斥量和信号量的区别：  \n1. 互斥量用于线程的互斥，信号量用于线程的同步。  \n这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。  \n互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。  \n同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源  \n\n2. 互斥量值只能为0/1，信号量值可以为非负整数。  \n也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。  \n\n3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。  \n\n[互斥锁、自旋锁、读写锁](https://blog.csdn.net/judgejames/article/details/87286397)：读写锁，读可以多线程同时占有，写只能有一个线程占有，读写不同时，还有个不加锁状态；互斥锁，一次只能一个线程拥有互斥锁，其他线程只有等待；自旋锁，特殊的互斥锁，不睡眠，循环等待，好处是节省睡眠唤醒的资源  \n\n>> 死锁  \n\n>> 进程和线程的区别 PCB TCB\n1. 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）\n2. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。\n而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。\n3. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。\n4. 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。\n\n<div style=\"width:300px\">\n    {% asset_img jrtt2.jpg %}\n</div>\n>> 80个球找轻的  \n\n>> 64个人，提前准备名单卡片来确认是哪个人  \n\n>> 九宫格密码解锁的所有可能，大于等于四位数\n\n## 网易雷火--牛客网\n\n问简历内容  \n游戏内AI如何实现：有限状态机，行为树  \n一个UI被点击后发生了什么：  \n  \n**基础相关：**  \nC++虚函数机制，虚表，虚指针：  \n虚函数实在派生类可以覆写的函数，虚表存在于类内存中，记录了所有虚函数，每个虚表对应一个虚指针指向它，这个指针在类的每个实例化对象中都有。  \n\nc++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此，在子类从新声明该虚函数时，可以加，也可以不加，但习惯上每一层声明函数时都加virtual,使程序更加清晰。\n\n构造函数可以是虚函数吗？  \n不可以，虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。  \n\n>> C# 内存模型 堆和栈  \n[link](https://www.cnblogs.com/omg24/p/4202992.html)  \n<div style=\"width:400px\">\n    {% asset_img valueandref.png %}\n</div>\n[link2](https://www.cnblogs.com/xiaodongy/p/7989711.html)\n\nC# gc 值类型与引用类型  \n注：Ref和Out的区别在于Ref在传递前需要初始化。  \n值类型在栈上，引用类型在堆上；前者不需要gc，后者需要  \nclose()可以再open，dispose()后资源被标记为无用，等待gc回收  \n非托管资源需要在程序中显式释放  \n对象间相互引用导致了gc丧失实时性，变为不确定的方式，否则可以用引用计数这种方法判断对象是否无用  \nGC清理垃圾实际上就是调用析构函数  \nString对象是不可变的（只读），一旦创建不可改变，看似修改其实是返回了一个新对象  \n\n[随机在圆上生成n个点，这n个点在同一半圆的概率是多少？](https://blog.csdn.net/zmazon/article/details/8547278)\n\n\nlua闭包  \n内部（子）函数可以使用外部（父）函数的局部变量\n``` lua\nfunction test()\n    local i=0\n    return function() --尾调用\n        i+=1\n        return i\n    end\nend\nc1=test()\nc2=test() --c1,c2是建立在同一个函数，同一个局部变量的不同实例上面的两个不同的闭包\n          --闭包中的upvalue各自独立，调用一次test（）就会产生一个新的闭包\nprint(c1()) -->1\nprint(c1()) -->2//重复调用时每一个调用都会记住上一次调用后的值，就是说i=1了已经\nprint(c2())    -->1//闭包不同所以upvalue不同    \nprint(c2()) -->2\n```\n\nlua怎么实现面向对象  \n[lua作者的方法](http://www.lua.org/pil/16.html)  \nobject：用table做  \n    table后边也可以用冒号（是个语法糖，省了传self/this\n    ```\n        a.deposit(a,100) == a:deposit(100)\n    ```\n    ）  \n    ``` lua\n    function Account:withdraw (v)\n        self.balance = self.balance - v\n        end\n    ```\nclass：setmetatable  \n``` lua\nsetmetatable(a, {__index = b}) --b是object a的class\n```\n实现继承和重载\n[风云的方法](https://blog.codingnow.com/2006/06/oo_lua.html)  \n只定义一个class函数  \ntable [参考资料](https://www.cnblogs.com/msxh/p/8469340.html)  \n\n>> 算法：最长公共子字符串（动态规划）  \n状态转移方程$dp[i,j] = dp[i+1,j+1] + 1$ 用滚动数组可以省内存，优化\n\n>> 算法：n叉树子节点值的和最大，规则不能同时取相邻的节点  \n\n>> 渲染管线  \n1. Input Assembler Stage\n这个阶段的主要目的是根据用户提供的顶点及索引信息，构建多边形，主要有点、线段、三角形。给定顶点和索引，构建多边形的方法取决于所使用的基本图元的拓扑类型（Primitive Topology）。\n\n2. Vertex Shader Stage\n这是一个完全可编程的阶段，即完全由程序员自己来实现。该阶段的核心为模型顶点的各种空间变化；\n用户指定的所有顶点都是基于模型空间的，在Vertex Shader阶段，每个顶点要依次经历所有这些空间，最终转换为屏幕上对应的二维坐标，不同空间之间的切换称为“空间变换”，实现空间变换的基本工作即矩阵。\n\n3. Hull Shader Stage、Tessellation Stage、Domain Shader Stage\n这三个阶段其实共属于Tessellation Stage，即曲面细分阶段，可选阶段。这个是D3D11中刚加入的一个高级特性，主要用于如LOD（Level of Detail）技术中。\n\n4. Geometry Shader Stage\n这个也是D3D11中加入的新特性，为可选阶段。在这个阶段中，输入为一个完整的多边形，点、线段或三角形。这个阶段直接对输入的多边形进行操作，可以把其消灭，不再往下一个阶段传输；也可以衍生出新的多边形出来。总之，该阶段操作的对象是完整的多边形，相比于顶点着色阶段，其操作的对象是单个的顶点。\n\n5. Rasterizer Stage\n这个阶段属于不可编程阶段，即完全由硬件实现，主要包括：\n   1. 视口变换\n   2. 隐藏面消除（Backface Culling）\n   3. 顶点属性的插值计算\n说白了就是，三维空间的物体，放到二维屏幕上\n\n6. Pixel Shader Stage（fragment shader片元着色器）\n这个阶段也是完全可编程的一个阶段，也是跟顶点着色器阶段一样十分重要的阶段。因为在D3D11中，顶点着色器和像素着色器是程序员实现的两个最基本的阶段。\n像素着色器，从名字上也很容易看出，是在像素级别上进行的计算。对于三维空间中投影到屏幕上的每一个多边形，针对其在屏幕上所覆盖的每一个像素，逐个进行像素着色计算。这一阶段接受的数据是经过插值计算后的顶点属性。输出的是颜色值，以提供给下一阶段处理。\n像素着色器给程序员提供了相当多的灵活性和自由度，通过各种不同的算法来计算片段颜色以实现各种特效。\n\n7. Output Merger Stage\n这个阶段即输出片段的混合阶段。该阶段不可编程，但是高度可调节。程序员可以灵活地调整管线的状态来实现不同的特效。比如针对深度缓冲区、模板缓冲区，混合等可以有各种不同的状态。利用它们来实现各种特效后面也有特别详细的介绍。\n\n**二面：**  \n实习经历相关  \n\n游戏框架、设计模式  \n\n值类型与引用类型 引用类型创建慢的原因，具体到内存  \n\n博客上的文章 提了问题  \n\n手写二分查找  \n\n斐波那契数列递归与非递归写法 怎么优化  \n\n有什么要问的  \n\n## 面经——牛客\n\n### 游戏研发\n\n[字节1](https://www.nowcoder.com/discuss/386400)  \n\n[字节2](https://www.nowcoder.com/discuss/388667)  \n介绍const，const修饰成员函数放哪儿？  \n修饰变量，说明该变量不可以被改变；  \n修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；  \n修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；  \n修饰成员函数（放在最后），说明该成员函数内不能修改成员变量（修饰的实际上是this，this是成员函数的调用对象）。  \nconst int* p是p这个指针指向的值是个常量；  \nint* const p是p这个指针是个常量，但是*p何以变；  \n\nvector内存？[如何避免vector扩容](http://c.biancheng.net/view/7397.html)？\nvector对象在栈上，内容在堆上； reserve(n)强制容量为n  \n\n函数可以返回引用吗？  \n可以，函数返回值时会产生一个临时变量作为函数返回值的副本，返回引用直接返回内存  \n\n如何进行字符串拷贝？  \nstrcpy ```char   *strcpy(char   *dest,char   *src);```\n功能：把src所指由NULL结束的字符串复制到dest所指的数组中。  \n说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。  \n\n进程和线程？  \n进程包含线程，一个线程挂了整个进程挂，进程与进程之间不影响，进程是资源分配的最小单位，线程是资源调度的最小单位  \n\n多线程同步？如何避免两个线程争一个资源？  \n互斥锁和信号量  \n\n[TCP UDP](https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html)？  \n传输层协议，tcp可靠，有链接，upd延迟低，无连接  \n\nTCP四次挥手？（我说了个四次握手 感觉面试官楞了一下）  \n断开连接，四次挥手，全双工 两次FIN（关闭连接）两次ACK（响应）  \n\nUnity如何改变一个物体的位置 旋转？  \n\nUnity本地坐标和世界坐标？  \n\nUnity调整旋转需要传什么参数？参数在数学上叫做什么？（我潜意识说的欧拉角 看他点了点头）还能怎么修改？    \n[四元数](https://blog.csdn.net/candycat1992/article/details/41254799)：可以跟欧拉角互相转换，四维空间向量  \n\n了解图形学？（说只知道一点渲染管线就没问）  \n\n如何使用协程？协程和线程区别？  \n协程 IEnumerator startcoroutine  \n区别在于所有协程在一个线程内完成，是比线程更轻量的异步方法，在程序层面，而线程和进程在操作系统层面  \n\nC#拆装箱  \n装拆箱其实就是值类型和引用类型两者之间的类型转换操作，引用类型（object）都是在栈上放个地址，地址指向堆上的内存  \n装箱：值类型到引用类型（int->object）隐式转换  \n拆箱：反之，显式  \n\n[字节3](https://www.nowcoder.com/discuss/366357)  \n\n[网易1](https://www.nowcoder.com/discuss/259699)  \n\n[天美，字节创新业务，雷火](https://www.nowcoder.com/discuss/405621)\n\n[字节，雷火，b站](https://www.nowcoder.com/discuss/384810)\n\n[字节引擎](https://www.nowcoder.com/discuss/233959)  \n\n[字节游戏测试](https://www.nowcoder.com/discuss/390823)  \n自我介绍\ntcp与udp的区别  \ntcp是面向连接的，提供可靠的服务，保证数据完整性、没有重复、按顺序到达，udp无连接延迟低\n\n[http与https的区别，https的劣势](https://blog.csdn.net/xiaoming100001/article/details/81109617)  \n前者明文传输，后者可进行加密传输、身份认证  \n后者降低了用户的访问速度，加重服务端压力；ca证书年费花销  \n\n进程与线程的区别  \n资源分配最小单位和资源调度最小单位，线程挂整个进程挂，进程挂对其他的没影响；线程间通讯代价小  \n\n多态，gc  \nC++在语言层面是没有gc的，但是可以通过智能指针实现；C#有\n\nset与hashset的区别  \n\nmap与hashmap的区别  \n\n快排的原理  \n\n归并的原理  \n\n多线程  \n\nLinux的shell编程  \n\nhashmap的查找，删除，添加的时间复杂度  \n\n\n算法题：一个数组中有正数有负数（没有0），请将它排成正负相间的数组（多余的全部放后面），时间复杂度不超过O（n）;\n\n[网易游戏后端](https://www.nowcoder.com/discuss/241040)  \n8.20 一面 1h\n\n1.介绍实习和项目\n\n2.static变量的作用？你能想到的所有的都讲出来\n\n3.a文件里面定义一个static b文件include a  c文件也include a 编译链接有什么问题？\n会导致每个文件都有一个专属的static变量  \n\n4.a文件定义了一个static函数，b文件想用这个函数 该怎么做？你能想到几种方法？  \n套在一个普通函数里  \n\n5.C++面向对象三大特性？虚表你怎样理解？  \n封装继承多态，包含虚函数的类对象最开始会有个虚表指针，目的是父类指针指向子类对象的时候找到正确的方法进行调用\n\n6.[如何用C实现C++这三大特性？](https://www.cnblogs.com/zzdbullet/p/10563075.html)  \nstruct做数据结构，函数的话传一个struct类型指针进去做this  \n继承就在struct里放父类一个对象  \n多态需要自己写个struct作为虚表，放到父类的struct中\n\n7.tcp三握四挥\n\n8.linux进程管理，介绍一下过程\n\n\n二面是两个人一起面的，难度的话感觉还好 等三面了~\n\n8.30 二面 50min\n\n1.介绍实习和项目\n\n2.linux内存管理，虚拟内存机制\n\n3.lock-free的理解？cas为什么能够原子性？\n\n4.如果很多个线程 都在并发cas 但是一直不成功，怎么办？（这个我没明白他的意思\n\n5.内存屏障怎么理解？\n\n6.互斥锁和自旋锁的区别？\n\n7.互斥锁的底层原理？它不是busy-loop如何通知线程\n\n8.自旋锁什么时候用？和cas有什么区别？\n\n9.cas实现自旋锁\n\n10.timewait状态\n\n11.tcp的拥塞控制？非常详细的介绍四个算法，包括门限值怎样修改，什么时候触发快重传等这些\n\n12.智力题 在数轴上有n个点，从中找一个点，使得该点到其他所有点的距离之和最短？并证明\n\n13.查看一块共享内存被哪些进程持有，用什么命令？查看一个进程持有了哪些共享内存呢？\n\n### C++后端\n\n[腾讯字节后台开发](https://www.nowcoder.com/discuss/399967)  \n\n[字节后端](https://www.nowcoder.com/discuss/415859)  \n\n项目为什么选用flask这个框架，对这个框架了解多少，有哪些并发模型。  \n生产者消费者模型怎么实现的。  \n中间有个阻塞队列作为“仓库”\n共享内存的原理和实现。\n[进程间如何同步。](https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78591330)  \n临界区，互斥量，信号量，事件\n\n负载均衡的算法你了解哪些？项目中的负载均衡是怎么实现的。\n一致性哈希有了解过吗？\n主键索引是什么，B+树有什么好处，主键索引和普通索引有什么区别。\n查询慢怎么优化。\n父子进程间共享哪些资源。\n多线程之间共享哪些资源。\nTCP有哪些机制保证可靠传输。\n接收方，窗口缓存满了会怎么样，怎么知道又有空间了，通知发送的包再丢了怎么办。\n思路题：20000个高考生，分布0-750的成绩，内存足够大，怎么排序最快。\n代码题：aabbcsdaddabsds一个字符串，删除所有的ab。注意：aabb->ab->null。\n二面\n项目介绍。\nFFmpeg介绍一下。\n项目的进展现在怎么样？遇到了哪些问题，系统稳定性怎么优化。\n负载均衡怎么做的？怎么判断服务忙不忙。\n代码题：单链表判断是否有环？若有环如何判断环的入口。\n死锁的概念，避免死锁的具体方法。\n缓存机制有了解吗？缓存的替换策略有哪些，说一下。\n思考题：如何判断恶意刷接口的情况？记录了10T的请求记录，找出前100个高频访问用户。  \n\n[一致性哈希](https://www.jianshu.com/p/735a3d4789fc)和普通哈希有什么区别？  \n一致性哈希主要就是解决当机器减少或增加的时候，大面积的数据重新哈希的问题  \n都是多个数据库服务器的情况下，普通hash增加机器时要重新哈希  \n\n三面\n项目介绍\n你们数据交互主要是内存是吧，怎么设计的？\n怎么监控内存有没有泄漏，服务挂了数据会丢吗？\n服务之间的负载均衡是怎么做的？有哪些负载均衡算法？\nCPU调度算法有哪些。\n系统调用了解吗？有哪些类型。\nhttp状态码有哪些。\nhttp和https的区别是什么。\n代码题一：判断一棵二叉树是不是以根节点为镜像的。\n代码题二：实现一个队列的类，有取最大值的接口，且时间复杂度为O（1）。\n家在哪儿？看你实验室做了很多算法的东西，你自己的就业方向是怎么打算的？\n实习可以来北京吗？什么时候可以开始，能实习多久。  \n\n[字节后端](https://www.nowcoder.com/discuss/415504)  \n\n自我介绍+聊实习项目\n\n手撕代码：排课表，有依赖，拓扑排序\n\n数学题：两个人抛硬币，谁先抛到正面谁赢，公平吗？不公平的话先手胜率多少？怎么改规则变的公平？\n\n数据库为什么用B+树，为什么选择一个扁平的树而不是类似二叉树，B+树的度选取有什么讲究？最后一问没想出来，面试官说和磁盘的基本单位簇的大小有关。\n\n线程是不是越多越好？和CPU的核心数量是什么关系？线程状态？为什么会阻塞？  \n不是 占用内存，切换线程也浪费cpu资源；新建、就绪、运行、阻塞（回到就绪）、死亡\n\n还有一些基础记不起来了。。。\n\n五分钟后二面\n\n二面\n聊项目\n\nJava并发，哪些集合线程安全，原理。。。这里问了很多，差不多线程有关的都过了一遍。。。\n\n输入url后的过程，浏览器是怎么渲染页面的？\n\n数据库为什么需要，联合索引，MVCC\n\n智力题：1000个人，10个试管，测新冠。讲了两个方法，一个是2进制表示，一个二分。\n\n代码：下一个字典序\n\n二面面了将近1个半，好多内容记不清楚了。。。\n\n4.20三面\n自我介绍+项目\n\n单例各种写法\n\n双线程交替输出，要现场跑\n\n设计短网址（之前了解过，但答的不算好）\n\n平常咋学习\n\n### 银行面经\n\n[招商信用卡中心后台开发实习](https://www.nowcoder.com/discuss/426131)  \n作者：alanpeng\n链接：https://www.nowcoder.com/discuss/426131?type=post&order=time&pos=&page=0&channel=&source_id=1_post\n来源：牛客网\n\n4.21 招行信用卡中心 一面 牛客视频 17:00 30min\n\n自我介绍  \n项目介绍，问项目  \n转java可以吗  \n进程间通信的方式  \n管道，信号量，共享内存，socket套接字，消息队列  \n\n线程同步的方式  \n临界区、信号量、事件、互斥量  \n\n死锁的四个条件  \n原因：1.系统资源不足 2.进程运行推进顺序不合适 3.资源分配不当  \n必要条件：1.互斥条件 2.请求与保持条件 3.不剥夺条件 4.循环等待条件  \n\n[内核线程与用户线程的区别](https://www.cnblogs.com/gizing/p/10925286.html)  \n处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的\n处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。  \n\n内核线程：线程切换由内核控制，切换的时候来，要从源用户态进入内核态，切换完毕要从内核态返回用户态；可以很好的利用百smp，即利用多核cpu。windows线程就是这样的。\n用户级线程：用户态程序自己调度线度程切换问，不需要内核干涉，少了进出内核态的消耗，但不能很好的利用smp。答目前linux pthread大体是这么做的。  \n\n[线程的具体执行过程](https://blog.csdn.net/a314774167/article/details/81292981)  \n新建->就绪->运行->阻塞（等待阻塞、同步阻塞、其他阻塞）->死亡  \n\n[cpu调度算法](https://blog.csdn.net/Ciellee/article/details/88783635)  \n先来先服务调度（First Come First Serve）、短作业优先调度 （Short Job First）、响应比高者优先调度算法、优先数调度算法、循环轮转调度法（Round-Robin）  \n\n[线程sleep和wait方法作用和区别](https://blog.csdn.net/u011028345/article/details/73351070)  \n是否占用cpu，sleep是占着cpu睡觉\n\n页面置换算法、LRU的底层实现（哈希表和双向链表）  \n内存管理的算法。\n\nTCP三次握手过程\n长连接的保活机制、心跳包\n怎么处理已经失效的连接\nhttp的几种请求方式、GET/POST/PUT的区别\n开放题：12306为什么不买很多服务器，但是抢票的时候还是不卡？（扯CAP，最后面试官说其实不买很多服务器的原因是一年抢票也就那么几次，考虑投入使用比）\n高可用性的秒杀系统是怎么样的、使用情景（CAP舍弃C）\n还投了哪些公司？拿到了哪些offer？怎么看互联网和银行、怎么选择？\n反问\n4.24 招行信用卡中心 二面 qq视频 11:00 30min\n\n自我介绍\n项目介绍、问项目\nTCP三次握手四次挥手过程\n最大堆、创建过程、堆排序\n文件系统的索引用的什么数据结构\n讲一下B+树，为什么效率高，为什么不用哈希表\njava的(...)你知道吗（不知道）\n日常生活问题\n当班长怎么组织活动、具体步骤、有问题怎么解决\n语言选择、城市选择\n反问\n\n### 其他研发\n\n[趋势科技广联达后台](https://www.nowcoder.com/discuss/183215)  \n\n1. 笔试题第二题思路\n\n2. c 面向对象说一下  \n封装：数据和逻辑绑定；继承：对象产生父子关系，共用属性和方法；多态，静态多态（相同函数不同的参数）和动态多态（虚函数）\n\n3. 虚函数怎么实现的\n有虚函数的表会在最前边放个虚函数表，每个实例会根据虚函数表调用正确的方法\n\n4. 如果不用指针和引用，子类赋值给父类，会不会引发动态绑定，为什么？\n静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；  \n动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；  \n不会，因为对象的类型是确定，在**编译期**就确定了，指针或引用是在**运行期**根据他们绑定的具体对象确定  \n\n5. vector底层工作原理\n数组，每次容量到上线就翻倍增加（开辟新空间再复制）  \n\n6. 讲项目\n\n7. 讲讲最小二乘\n它的主要思想就是选择未知参数，使得理论值与观测值之差的平方和达到最小  \n\n8. 为什么采用最小二乘法而不用你一开始说的三次样条\n\n9.  近处用一次函数拟合，远处用高次函数拟合，你怎么判决这个边界的\n\n10. 算法了解哪些\n\n11. 动态规划和贪心算法有啥区别，分别举个栗子\n\n12. 贪心算法有什么缺点\n\n13. 说一下机器学习吧\n\n14. 数据结构了解哪些\n\n15. 树和图有啥区别\n能否成环，树有个根节点\n\n16. 什么地方会用到树\n\n[广联达远程面试](https://www.nowcoder.com/discuss/267138)  \n\n1. 自我介绍，重点介绍下项目\n\n2. 详细讲解项目是怎么实现的？（口才不好，描述半天……）\n\n3. 了解哪些常用数据结构？（数组、栈、树....）\n\n4. 那说一下B+树的原理，有什么优势？\n单一节点存储更多元素，减少IO\n所有查询都要找到叶子节点，查询稳定\n所有叶子节点形成有序链表，方便范围查询\n\n5. 介绍一下索引\n索引是对数据库表中一个或多个列（例如，employee 表的姓名 (name) 列）的值进行排序的结构。  \n\n6. mysql为什么用B+树索引，不用其他索引？（忘了，只说了下hash索引的一个缺点）\nB+-树特点是每层节点多，层数少，这样可以减少磁盘io次数，B+相比较B-因为数据都在叶子节点所以可以用链表将数据串起来，进行区间访问  \nAVL 数和红黑树基本都是存储在内存中才会使用的数据结构\n\n7. 情景题：实现一个栈，具有max方法，并且所有时间复杂度为O(1)\n8. 说一个常见的排序算法，除了冒泡排序（说了归并排序）\n9.  那写一下归并排序的实现\n10. 谈谈jvm（数据运行区、GC，这个了解比较多，扯得有点多，后来被打断了...）\n11. 反问环节\n\n[广联达C++实习](https://www.nowcoder.com/discuss/427484)  \n十分钟介绍项目  \nunity UI/游戏机制/shader/winapi+d3d/前端经历  \n\n除了C++还用过什么语言  \n\n指针与引用的区别  \n指针分配空间，引用只是别名  \n指针可以为空，引用不可以  \n\n面向对象的几个特点  \n封装，继承，多态  \n\n[c++几种类型转化](https://www.cnblogs.com/evenleee/p/10382335.html)  \nconst_cast：去const和volatile（所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取）  \nvolatile关键字的作用：防止编译器优化，也就是上边的操作  \nstatic_cast：无条件转换，静态类型转换，无运行时类型检查  \ndynamic_cast：有条件转换，动态类型转换，运行时检查类型安全  \nreinterpret_cast：仅重新解释类型，但没有进行二进制的转换\n\nstl的几个模块  \nvector,map,set,unordered_map,unordered_set\n\n泛型编程了解么?  \n函数模板、类模板  \nSTL就是很好的例子（pair等）\n\n说下你了解的排序算法  \n\n说下快排  \n\n[红黑树和AVL数树区别?  ](https://blog.csdn.net/liang3720/article/details/81700748)\n平衡二叉搜索树：红黑树只要大致的平衡，高度平衡树（avl）高度差最大为1；  \n红黑树的复杂度O(logn)，是平衡二叉树，是二叉搜索树  \nb树是平衡多路查找树，b+树只在叶子节点存数据，其他都是索引，应用是文件系统  \n\n说下斐波那契数列  \n最近在看什么书  \n\n[广联达开发](https://www.nowcoder.com/discuss/230890)  \n笔试：\n1. 填空题 ，快速排序找到第k小的数，再递归\n2. A，B 2个数组，交换其中一个元素使2个数组和相等\n\n3. 回文数\n先转到数组里，然后前后双指针遍历，比较。\n\n4. 给定圆的半径，求圆内包含的小正方形的最大的面积？（这题求解答）\n\n一面下午4点  \n1. 讲一讲一面第二题的思路，\n答：暴力法O（n*n）\n给你几分钟 ，能不能优化一下\n答：2数组元素之和 /2为期待结果，在A里面哪个换掉能得到期望值，而B中正好有该元素 则输出该元素\n2. 讲一讲第三题的思路\n3. 给一个数组，找出3个数的和为N\n4. 求a^b, a很长很大，b为2-9；\n面试管诱导我到正确的思路上，先算a b，a，b很大，再想a*a；最后想a^b；\n5. 朱元璋有很多后代，在一次会上，2个朱氏后代富商，想知道他们最近的共同祖先是谁？每个朱氏后代只能向上寻找其父亲是谁。答：转换为相交双链表求交点的问题\n6. 讲一讲项目，项目中遇到的困难，怎么解决的\n二面下午6点\n自我介绍\n人生中做的最对的事情是什么？映像深刻的挫折\n未来几年的职业规划\n未来几年的生活计划\n对广联达了解多少\n\n[广联达人工智能](https://www.nowcoder.com/discuss/242943)  \n[面经合集](https://www.nowcoder.com/discuss/322691)\n\n[腾讯测开](https://www.nowcoder.com/discuss/431828)  \nC++对象的大小是由哪些确定的  \n成员变量的大小，内存对齐，是否有虚函数，是否有虚继承\n\nC++虚函数和纯虚函数有什么不同  \n纯虚函数没有实现，不可以实例化\n\nC++的多态是怎么实现的  \n虚函数\n\nC++对象的内存布局\n单继承、多继承、菱形继承（分是否虚继承）\n\n计算机网络\ntcp为什么要三次握手和四次挥手\n数据库\nredis是什么\nredis是用来做什么用的\nredis跟mysql有什么不同\n编程题\n用Rand6实现Rand10\n判断链表是否有环，找出环的头部\n经典赛马问题\n二面 2020-05-26\n编程题\n后序遍历\n[无递归后序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/)\nC++\n宏定义结构体\nmemcpy可能会出的锅\nC++如何实现多态\n虚表是如何实现的  \n\n[new/malloc](https://blog.csdn.net/qq_40840459/article/details/81268252)的内存分配在哪  \nmalloc从堆上分配内存，new从自由存储区（是更高级更抽象的概念，一般由堆组成，程序可以通过重载new指定其他内存实现自由存储区）分配内存？？  \n“堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。”  \n\nmalloc的原理是通过系统调用实现的（在linux下是通过sbrk()系统调用实现）  \n\n编译原理\n函数调用的过程\n数据库\nmysql索引\nb+tree\n计算机网络\ntime_close是什么状态\n\n[腾讯测开实习](https://www.nowcoder.com/discuss/388960)  \n字母压缩  \n\n最小公倍数 = m*n/gcd(m,n)  \n最大公约数（gcd）: gcd(m,n) = gcd(n,m%n)\n\nvivo提前批后端  \ntcp四次挥手的time_wait等的是2msl（MSL是Maximum Segment Lifetime）  \n\n几十g的文件，字符串的出现次数  \n\n预防内存泄漏的方法，如何检测内存泄漏  \n\nhttp的get post等方法的细节  \n\ngdb调试工具  \n\nunique_ptr怎么声明  \n\n生产者消费者模型，怎么实际线程结构  \n\n两个链表求交点  \n方法一：哈希表存一个，遍历一个；方法二，快慢指针找相等  \n\nunordered_map具体用的什么解决冲突的  \n链地址法  \n\n\nvivohr面：  \n\n为什么想做这个职位  \n\n你认为这个职位需要哪些能力  \n\n对于求职公司看重哪些因素  \n\n独生子，父母工作，女朋友  \n\n工作城市  \n\n对该公司了解多少  \n\n提问\n\n[游戏引擎面经](https://www.nowcoder.com/discuss/402956)  \nC++：\n1.new和malloc区别：new/delete会调用构造和析构函数，是C++的关键字；malloc和free是c的库函数  \n\n2.STL中map的实现原理，怎么解决hash冲突  \nmap底层是红黑树，unordered_map是哈希表，解决冲突的方法是链地址法  \n\n3.STL迭代器失效的情况  \n* 由于插入元素，使得容器元素整体“迁移”导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效。\n* 由于删除元素使得某些元素次序发生变化使得原本指向某元素的迭代器不再指向希望指向的元素。\n\n4.右值引用的作用？std::move怎么实现的？  \n延长右值的生存时间，避免不必要的拷贝；move底层就是一个static_cast类型转换  \n\n5.三个智能指针说一下，weak_ptr如何判断是否失效？sizeof(shared_ptr)多少？  \nUnique，share，weak  \nweak_ptr是否失效三种方法：1.expired()方法返回true；2.use_count()返回0；3.weak_ptr转化为shared_ptr看是否有bad_weak_ptr exception  \n64位机器是16，32位是8，也就是两个指针的大小，shared_ptr管理的普通指针所指向的对象必须为new出来的  \n\n6.如何将C++类设置为不可继承  \n简单的：将构造析构函数设为私有，然后提供静态方法构造和析构  \n[最佳的](https://www.cnblogs.com/wxquare/p/7280025.html)：写个基类，构造析构私有，模板类型是友元；不可继承的类**虚继承**这个基类；其他类便不可继承该类  \n\n7.能否将构造函数设为虚函数  \n不可\n\n8.继承下虚表的变化情况？  \n数组一样的线性结构，按照基类的顺序，子类有就覆盖掉  \n\n9.sizeof空结构体  \n1\n\n10.register变量可以取地址吗？  \n可以\n\n11.指针和引用的区别  \n分配内存/只是别名；可以为空/必须初始化；可以任意改变/初始化后不能改变指向地址\n\n12.深拷贝和浅拷贝  \n复制出新空间/只是拿引用  \n\n13.函数如何返回多个值（引用或者std::pair,std::tuple)  \n14.C++  UB说几个  \n未定义行为：除零，访问越界，访问空指针，未初始化\n\n15.带有虚继承的子类内存分布  \n先放自己的，再放基类的属性，最开始有vbptr，存着成员变量的偏移量，用来找到公共基类的成员变量  \n\n16.C99变长数组是堆还是栈实现的？  \n变长数组分配在栈中\n\n操作系统&&计算机网络&&多线程:\n1.线程和进程的区别\n2.多发射了解吗  \n\n3.C++中多线程库实现PV操作用什么？\n4.TCP/IP三次握手，拥塞处理，滑动窗口\n5.指令重排发生在编译阶段还是运行阶段？\n6.智能指针是线程安全的吗？  \n\n(这部分感觉问的比较少，也没啥印象了，也都是基础了)\n\nLua：\n1.lua的__index和__newindex是什么？  \n__index是table进行索引时如果没有值，就调用__index（可以是function可以是table，是table就在table里索引）；  \n__newindex是给table不存在索引进行赋值时，调用__newindex（可以是function可以是table，如果是table就在这个table里赋值而不是原来外层的table）  \n\n2.lua的垃圾回收机制？是否存在互相引用现象？  \n语言级别的垃圾回收\n\n3.lua的元表怎么重载运算符？  \n用metatable\n\n4.lua怎么实现面向对象的机制？  \ntable做object，元表实现继承\n\n5.lua的table底层是怎么存储的？  \n为了提高table的插入查找效率，在table的设计上，采用了array数组和hashtable(哈希表)两种数据的结合。\n\n6.lua对栈的操作比较麻烦，有优化方法吗？  \n\n\n7.lua和C++怎么绑定，有什么库？\n8.lua的pairs和ipairs有什么区别?  \n* pairs遍历表中全部key，value\n* ipairs从下标为1开始遍历，然后下标累加1，如果某个下标元素不存在就终止遍历。这就导致如果下标不连续或者不是从1开始的表就会中断或者遍历不到元素。\n\n图形学&&管线:  \n1.渲染管线说一下，前向渲染&&延迟渲染  \n应用阶段，几何阶段，光栅化阶段  \n顶点数据，顶点着色器，曲面细分着色器，几何着色器，剪裁，屏幕映射，三角形设置，三角形遍历，片元着色器，逐片元操作，屏幕图像  \n前向渲染：检测深度，如果可见就计算光照获取颜色信息，更新帧缓冲（在颜色缓冲中进行混合）  \n延迟渲染（deferred shading）：检测深度，如果可见就将片元信息（法线，位置，材质信息）保存到G-Buffer，最后用g-buffer中的信息进行光照计算（g-buffer中混合）  \n\n2.延迟渲染的缺点，分块延迟渲染知道吗？[为什么延迟渲染带宽会那么大](https://www.sohu.com/a/125709754_468740)?  \n延迟渲染主要的好处包括：  \n    1） 光照的开销与场景复杂度无关。  \n    2） Shader可以访问深度和其他像素信息。  \n    3） 每个象素对每个光源仅运行一次。也就是说，那些被遮挡的像素是不会被光照计算到的。  \n    4） 材质和光照的Shader完全分开。  \n延迟渲染还需要克服的主要障碍包括：  \n    1） 较高的显存带宽占用，因为gbuffer大  \n    2） G-buffer消耗较多的填充率，这个问题在游戏机上比较严重（像素填充率是指图形处理单元在每秒内所渲染的像素数量）  \n    3） 无硬件反锯齿的支持  \n    4） 对Alpha Blend支持较差  \n\n[TBDR分块延迟渲染](https://gameinstitute.qq.com/community/detail/123220)：带宽直接影响能耗，tile based rendering可以使用on-chip的memory，从而频繁访问从frame buffer到processor转移到了on-chip memory到processor  \n\n带宽占用高：因为G-Buffer的大小\n\n3.SSAO原理，除了SSAO还有哪些AO？  \nSSAO：屏幕环境光遮蔽，SSAO通过采样象素周围的信息，并进行简单的深度值对比来计算物体身上环境光照无法到达的范围，从而可以近似地表现出物体身上在环境光照下产生的轮廓阴影。  \n\n[其他AO](https://www.zhihu.com/topic/20712088/intro)  \n\n4.阴影贴图原理 PCF是什么 PCF的卷积核有什么？ CSM？  \n[阴影贴图](http://blog.sina.com.cn/s/blog_6ba3e8e50101eh8x.html)：光源位置，视点位置，还有物体高度可以计算出阴影的区域（阴影贴图）  \n\nPCF：软阴影算法，传统PCF的主要原理就是通过对周围像素取值进行高斯模糊，算定阴影像素点的权值，进行加权计算。  \n\n[CSM](https://blog.csdn.net/kuangfengwu/article/details/7946036?_t=t)：fft重新构建shadow map  \n\n卷积核有什么：\n\n5.PBR说一下，几何函数的意义,IBL主要是针对高光还是漫反射光？  \n几何函数：描述微平面自阴影和自遮挡的属性  \nIBL（image based lighting）\n{% asset_img 几何函数.png %}\n\n6.Lod是什么？除了通过摄像机和物体距离判断Lod等级，还有什么方法？  \nlevel of detail；\n\n7.DrawCall的开销体现哪里，就是你调用DrawCall,具体干了什么？  \n准备工作（最费时）->cpu发起drawcall->进入command buffer->GPU  \n准备工作：硬盘收集网格信息（顶点位置，法线，顶点颜色）和纹理信息，加载到内存，然后加载到显存；然后设置渲染状态（是否透明，lightmode，单双面）  \n小drawcall合并到大drawcall中，不能让cpu准备工作太久，导致gpu空闲\n\n8.Bloom效果怎么实现？  \n提取较亮的区域，保存到一张渲染纹理中，利用高斯模糊进行处理，模拟光扩散，最后与原图混合  \n\n9.描边算法说一下？怎么不用后处理的卷积算子做描边？卡通化渲染呢？  \n* 视角方向和表面法线方向，一个pass出结果，效果不好\n* 两个pass，一个渲染背面面片，一个正常正面面片，快速有效，不适用立方体这样平整模型\n* 基于图像处理的轮廓线渲染（卷积等边缘检测方法）\n* 混合上述方法\n\n卡通化：1.渲染轮廓线；2.添加高光  \n素描风格：TAM（tonal art map）的例子，用到了mipmap，不是简单的降采样，而是控制笔触间隔，模拟素描效果  \n\n使用一个噪声纹理得到的法线贴图可以实现一个包含菲涅尔反射的水面效果  \n\n边缘检测算子：roberts，prewitt，sobel\n\n10.DX12大概是怎么减少开销的，说一下  \n\n\n11.[mipmap说一下](https://www.zhihu.com/question/66993945)？它对带宽有什么影响？  \n多占用33%的内存，减少带宽使用，实际是增加缓存命中率，相当于离线计算好1个pixel覆盖多个texel的结果  \n\n12.压缩纹理有什么格式？  \nDXT RGBA32/16\n\n13.Unity外部调试工具有哪些？  \n内部profiler，framedebugger  \n安卓的有高通的adreon、英伟达的NVPerfHUD；IOS平台PowerVR有一个，XCode有一个  \n\n14.UE4渲染过程大概说一下，随便说几个Pass？  \n\n\n15.[为什么延迟渲染不能开MSAA](https://www.zhihu.com/question/366668747)？  \n[MSAA](https://blog.csdn.net/limanru14/article/details/104305514)：把每个pixel(或者说fragment)细分为多个sub-pixel，比如分为4个、8个、16个甚至32个sub-pixel  \n延迟渲染不能开不是技术上不行，是采用msaa每张图x4 （四张图采样）负载过大\n\n16.有什么方法能降低一个场景中的渲染开销吗？说的越多越好  \nmipmap：多级纹理，典型空间换时间，应该是可以缓解带宽的因为用了压缩后的贴图；  \n合并drawcall：drawcall主要的性能瓶颈在cpu准备阶段（收集信息，设置渲染状态）；  \nearly-z：将深度测试提前\n\n17.纹理数组知道吗？  \n\n18.实例化是怎么做的？说一下流程和好处  \n\n19.说一下常见的[遮挡剔除算法](https://www.jianshu.com/p/0a7a018c5539)？  \n* hidden line removal\n  * raycasting\n  * 画家算法（从后往前画）\n  * warnock算法：递归细分\n  * bsp tree二维空间分割树\n  * z-buffer\n* culling\n  * portal\n  * 视锥体剔除：如果某物体全部顶点都在视锥外面，则不显示\n  * 背面剔除：通过每个面的法线来判断是正面还是背面\n\n20.纹理在移动设备上存储在哪里？\n21.全局光照能说一下吗？SH也说一下?  \n[球谐光照](https://blog.csdn.net/leonwei/article/details/78269765)的优点是运行时的计算量与光源的数量无关，如果参数足够却可以较好的模拟实时的光照结果。球面函数的也有例如傅里叶展开一样的东西，叫做勒让德多项式（Legendre Polynomials），\n\n22.如果把近处平面去掉了会怎么样  \n视锥体剔除嘛，进平面去掉物体就可以贴到镜头前，近平面远就会提前看到剔除\n\n23.OpenGL的VAO和VBO\n24.GBuffer一般里面有什么，GBuffer要不要存储position信息，如果不存储，怎么用深度信息进行推导\n25.卷积知道吗？说一下，模糊呢，为什么需要模糊？  \n卷积核遍历图像像素进行计算得到新图像，根据卷积核不同作用不同，例如可以实现提取轮廓线的工作，我的理解是做特征提取。模糊可以实现bloom这种效果，具体来说选高光部分组成一张纹理，使用模糊处理后在于原图合并  \n\n26.次表面反射知道吗？  \nsss就是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程。  \n\n27.透明度测试和深度测试的关系？  \n透明度测试是透明度小于一个阈值就不显示，\n\n28.法线贴图说一下，切线空间呢？  \n法线纹理和高度纹理都属于bump map\n\n29.移动设备怎么减少DrawCall Overload?  \nearly-z，不透明物体从前往后画\n\n30.各向异性在光照模型中如何实现？  \n各向异性 (anisotropy ) 与 均向性 相反，是指在不同方向具有不同行为的性质，也就是其行为与方向有关。应用场景例如头发，晶体，这类材质不均匀，原子排列周期疏密不相同的物质  \nBank BRDF 属于经验模型，由于其计算简单，且效果良好，所以该模型在各向异性光照效果的模拟方面非常有用  \n\n各向异性滤波？：比如一个走廊，视点消失处的像素采样会变模糊，各向异性滤波可以使其便清楚  \n\n31.opengl中顶点数据被送入顶点缓冲区时api做了什么？\n32.phong和billn-phong区别是什么？  \nblinn不需要计算反射角度，取而代之的是视角与入射角度的均值  \n\n33.ray marching 知道吗？\n34.opengl和dx有什么数学上的差别？  \n坐标系零点\n\n35.Alpha Blend和Alpha Test在性能上有什么不同？  \n透明度测试没通过的就不渲染了，透明度混合的话需要都渲染然后进行叠加\n\n36.光源剔除怎么做？  \n？？\n\n37.遮挡剔除怎么做？知道Mesh Shader吗？  \nunity有个occlusion culling window可以对static的物体烘焙，不进行渲染；  \nnVidia推出的mesh shader\n\n38.CS知道吗？为什么有些pass放到cs而不是ps做？\n\n游戏数学&&算法：\n1.点沿任意轴旋转的矩阵怎么推导\n2.怎么判断一个物体是不是在你面前还是身后？\n3.[A*算法](https://blog.codingnow.com/2006/07/astar.html)说一下，它的最大缺点是什么？  \n该点到起点的距离，该点到终点的距离\n仅仅是一个启发式搜索算法，最大的缺点就是，空间需求太大\n\n4.八叉树算法说一下，它用在哪里居多，物体运动了咋办？  \n常用于离散化空间，数据划分存储，数据查找等。  \n八叉树四叉树一样的，要是找相交图元的话，比如说范围攻击，可以从根节点开始遍历，如果相交在跟子节点检测，直至叶子节点，这样可以省掉一部分比较次数  \n\n5.kd-tree和bsp说一下  \nk维树（每个节点为k维的二叉树，超平面把空间分成两部分），是特殊的二叉空间分割树\n\n6.推导View矩阵\n7.[如何判断射线和三角形相交](https://www.cnblogs.com/graphics/archive/2010/08/09/1795348.html)\n8.[如何判断两个立方体是否相交(AABB包围盒相交问题)](https://blog.csdn.net/u012419410/article/details/41911025)\n9.如何判断点是在多边形里面还是外面？\n10.如何判断三角形和三角形相交?\n11.说一下点积和乘积的几何意义？  \nb在a上的投影；叉乘模是四边形面积，方向是垂直ab平面\n12.矩阵左乘和右乘区别？  \n矩阵左乘变换矩阵是进行行变换；右乘是列变换\n\n游戏开发：\n1.帧同步中的帧是什么意思？  \n操作，动作\n\n2.常见的设计模式说一下\n3.Unity的awake,enable,start\n4.UE4的垃圾回收怎么实现？不会？那说说反射吧\n5.UE4蓝图和C++代码通信的几个方法？\n6.ECS框架有什么好处？\n\n\n[链接](https://www.nowcoder.com/discuss/438775?type=post&order=time&pos=&page=1&channel=666&source_id=search_post)\n1 腾讯-游戏客户端开发  \n一面  \nC++基础：  \nstl的vector和list的区别，增删分别的时间复杂度  \nvector底层数组，连续空间；list底层链表，离散空间；list善于增删O(1)，vector O(n)  \n\n虚函数机制  \n有虚函数的类会存在一个虚函数表，虚函数表的实际位置在静态存储区，每个实例化对象的最前边会有个虚表指针指向这个表，用父类指针指向一个子类实例来实现动态多态  \n\nC11的新特性  \nauto；三个智能指针；右值引用（延长右值寿命，移动语义一般是用在移动构造函数比如改进版的swap函数，避免使用拷贝构造函数；注意右值引用也是引用，函数不能返回局部变量的右值引用）\n\n计算机网络：  \n解释TCP3次握手  \n\n图形学：\n速度过快/体积过小导致物理引擎检测不到碰撞，如何解决  \n自己来检测的话：记录前一帧的位置，从前一帧的位置向当前帧的位置发一条射线，用过射线是否碰撞来判断是否碰撞  \n完全依赖引擎的话：Unity的rigidbody有[collision detection](https://blog.csdn.net/cangod/article/details/100524270)选项\n* discrete：default\n* continuous：防穿静态碰撞体 TOI（time of impact）算法，线性扫描所以无法检测旋转物体\n* continuous dynamic：防穿静态和同为c的刚体\n* continuous speculative：推测式（投机式）ccd，膨胀AABB碰撞盒，可能出现幽灵碰撞\n\n开放性问题：  \n如何优化内存，实际开发过程中用过什么优化内存的方法  \nmipmap关闭；模型/图片的write/read；内存池；\n\n如果有对象要频繁创建和删除，用什么减少开销。(对象池)  \n对象池的大小通常如何决定：太大占内存，太小没作用，结合数据分析来确定  \n\n\n二面\n二面面试官给我发了一个腾讯文档，考8道C++基础题，涉及到C++自定义类的大小如何决定(默认大对齐)、右值引用、模板类、STL的iterator使用等等，在面试官纠正下我勉勉强强做出了7道，感觉还是蛮难的。题就不公开放了，有小伙伴需要的话私信我单独发吧。\n\n三面\n三面给我印象不是很深，好像是问了问我简历里的项目，然后我叽里咕噜跟面试官说了一堆，说了啥我已经忘了，毕竟面试里说的那些高大上的话太羞耻了根本不敢回忆😂\n\n2 网易-游戏引擎研发\n手撕代码：是否是合法括号串\n手撕代码：最长合法括号串，上面一题的升级版，要求O(n)\n这是网易一面的两道题，做完之后开始问问题，被面试官怼飞了。能感觉得出来网易那会已经不招人了，就纯粹面你面着玩，岗位相关的问题就没问几道，逮着我简历里不相关的经历狂怼，最后话都没让我说完就让我回去等消息了。\n\n3 字节-游戏引擎研发\n一面\n\nC++基础：\n几个stl容器的底层实现\n右值引用和move构造\nconst、static关键字\nC++里的lambda函数\n指针和引用的区别\n\n软件工程：\n介绍几个设计模式\nC++里的面向对象\n\n图形学：\n介绍渲染管线\n解释纹理采样的两个模式  \nrepeat，clamp\n\n手撕代码：前序遍历\n\n二面\nC++基础：\n解释C++的多态如何实现  \n\n解释类模板和模板类的区别  \n类模板经实例化后生成了3个类型分别为a,b,c的模板类\n\n右值引用、move语义\n\n图形学：\n介绍顶点处理中涉及到的矩阵变换  \n旋转缩放，平移\n\n介绍一个光照渲染模型(我介绍的是冯氏光照)\n介绍一个消除隐藏面的算法(我介绍的是Z缓存)\n如何解决因为顶点过近和浮点数的精度不足带来的穿模问题  \n\n\n手撕代码：快排\n\n三面\n开放性问题：\n在特定场景如何选择stl容器，以什么为标准？你最近一个应用到这个容器的场景是什么？\n在N*N棋盘地图上放一个圆形技能，检测影响到的玩家对象，用什么数据结构实现？\n不关心顺序的数组如何实现O(1)的删除操作 \n\n\n**字节游戏引擎1/2面（2020.7提前批）**  \nAssetBundle是怎么在jit（虚拟机？）中加载prefab的：Unity的跨平台技术是通过一个Mono虚拟机实现的。而这个虚拟机更新太慢，不能很好地适应众多的平台。unity公司就自行研发了IL2cpp，把本来应该再mono的虚拟机上跑的中间代码转换成cpp代码，这样再把生成的cpp代码，利用c++的跨平台特性，在各个平台上通过对各平台都有良好优化的native c++编译器编译，以获得更高的效率和更好的兼容性。\n\nUnity项目中的[Library文件夹](https://blog.csdn.net/u012138730/article/details/81143413#2.Library%E6%96%87%E4%BB%B6%E5%A4%B9)：此放的是程序集和库的缓存文件。 \n\nUnity的Inspector面板中查看GO属性是怎么实现的：反射，运行时获取属性并进行修改  \n\n接着inspector，undo和redo怎么实现：记录一个操作队列，怎么设计这个队列  \n我这边说了unity的scene文件在版本控制工具中看就是文本记录的属性，可以记录下修改的值，比如加或减一个数，撤销就是减或加回来  \n正解应该是[命令模式](https://www.jianshu.com/p/7747f574d53b)\n\n各向异性过滤算法：是用来过滤、处理当视角变化导致3D物体表面倾斜时造成的纹理错误；传统的双线性和三线性过滤技术都是指“Isotropy”（各向同性）的，其各方向上矢量值是一致的，就像正方形和正方体  \n\n图形学中渲染阴影的方法：我说了shadowmap，追问能想象到哪些地方会比较糙吗，有限的分辨率下看起来品质尽可能高，bloom和blur搞混了，bloom是泛光的效果，blur是模糊效果；抗锯齿是通用的方法，跟这个问题没有关系；他的意思是远的地方，或者说斜射的地方会一个光照贴图的像素对应一大片场景区域，怎么处理；  \n\n[Cascaded shadow map](https://zhuanlan.zhihu.com/p/116731971)：级联阴影贴图，将平截头体分成若干份，由近到远使用分辨率有高到低的shadow map  \n\npbr理论，cook torrance光照模型的微表面理论：用来模拟不同材质的镜面反射效果；三部份组成——菲涅尔反射，微平面法线分布函数，几何项  \nphong光照的问题在于他不是能量守恒的  \n经验模型：Lambert、phong、blinn-phong\n\n抗锯齿，四倍或几倍细分的话显卡受得了吗：我说的是延迟渲染不能用aa就是不是因为技术上不行，就是因为显存遭不住  \n\n体渲染：雾，水体\n\n对于移动的物体如何计算光照：光照探针？球谐函数模拟全局光照  \n\n**3面负责人面**  \nshared_ptr实现：  \n引用计数增加的情况:  \n拷贝一个shared_ptr，其所指对象的引用计数会递增，如：\n1. 用一个shared_ptr初始化另一个shared_ptr\n2. 用一个shared_ptr给另一个shared_ptr赋值\n3. 将shared_ptr作为参数传递给一个函数\n4. shared_ptr作为函数的返回值\n \n引用计数减少的情况:\n1. 给shared_ptr赋予一个新值\n2. shared_ptr被销毁（如离开作用域）\n\n什么情况用vector什么情况用list；使用list的应用场景，怎么找到删除节点的位置（靠遍历吗？需要O(N)时间，），实现erase方法；boost中的signal或者C#中的delegate/event怎么实现的  \n\n**上海无双一面引擎**\n[为什么图形学中要用4*4的矩阵](https://www.zhihu.com/question/36296104/answer/1398427077)\n\n\n\n\n**字节TA**  \n\n\n1. 自我介绍\n\n2. 渲染管线的流程\n\n3. 用glsl语言写过完整的shader吗\n\n4. 三维向量位移、旋转、放缩的矩阵、三个的排序\n   缩放，旋转，位移\n\n5. [异面向量距离计算](https://baike.baidu.com/item/%E5%BC%82%E9%9D%A2%E7%9B%B4%E7%BA%BF%E7%9A%84%E8%B7%9D%E7%A6%BB/2074683?fr=aladdin)\n   求ab公共法向量，也就是公垂线的方向向量n，ab上任取AB点，求AB线段在向量n上的射影d\n\n6. 万向节死锁的解决方式、具体说一下原理\n   用xyz欧拉角表示才会万向节死锁，用四元数就不会了\n\n7. 高斯模糊的shader代码\n\n8. 卡通效果的shader代码\n\n9.  半兰伯特光照、phong高光、blin-phong高光shader代码\n\n10. Alphablend为什么不能depth write、为什么要depth test\n    但对于半透明的 fragment，每一个都会影响最终的结果，需要从远至近地渲染。由于深度缓冲不能用于排序多个 fragment，所以只能用于保存最接近视点的不透明 fragment 深度，远于该深度的透明 fragment 不用渲染，所以仍需要深度测试（depth test）。\n\n11. Renderqueue的作用\n    background 1000，geometry 2000，alphatest 2450，transparent 3000，overlay 4000\n\n12.  透明模型前后面冲突的解决方法\n    分两个pass，第一个开启深度写入，不输出颜色；第二个正常的透明度混合\n\n13.  模型放大的方法，方法越多越好\n\n14. Z冲突的解决方法，方法越多越好\n    搜索z-fighting  \n    第一点：当然，从这里公式里面，我们也能看到，想要让深度值更加精确，那么适当的见效近平面与远平面的绝对距离，也是可以做到的。当然在不影响渲染质量的前提下。\n\n    第二点：根据物体距离视点的距离，在渲染的时候，进行一个计算，避免距离视点比较远的物体相距太近。\n\n    第三点：可以使用OpenGL ES内部提供的API，多边形偏移，但是会造成性能的浪费，可结合CPU空间划分与LOD算法使用。\n\n    第四点：提高深度缓冲区的精度，这样，其在深度缓冲区测试的时候会更加的准确。\n\n15.  锯齿的原因 抗锯齿的方法\n    纹理分辨率低于屏幕分辨率，aa的方法4x8x\n    msaa经典，英伟达txaa\n\n16. Pbr材质需要什么要素、有没有做过\n\n17.  有没有用lua写过脚本，写过什么脚本\n\n18.  抖音视频;如果让用户写的字显示在屏幕上，说几个有意思的创意，越多越好。\n\n19.  抖音视频：如果能对用户的图片进行断裂处理，说几个有意思的创意，越多越好\n\n\n### 游戏客户端8.16开始\n\n[网易雷火](https://www.nowcoder.com/discuss/476842)：  \n大小端首字节\n\n### 自我介绍\n\n1. 游戏研发：本科有Unity课程，对建模（PBR模型制作）到游戏引擎，甚至是剧本策划都有一定的了解。\n个人之前的实习经历都是偏前端，有尝试mirror（unet），skynet，这些服务器框架，还在逐步学习。\n对游戏引擎，准确说是渲染引擎比较感兴趣，本科课程中完成了简单的webgl渲染引擎，现在在学DX12 win32API的渲染引擎开发。\n因为实验室课题缘故，掌握了一些深度学习相关的技能，linux系统用过，conda，pytorch，AI+GAME是很好的方向。\n\n1. 后端研发：本科读的数字媒体技术，偏重于技术，同时也学习了ps，音视频剪辑，建模等一些课程。除了语言，还有oop这种基础课程，我大二下开始学习使用unity为主以C#作为脚本语言，游戏研发课程。游戏引擎开发，是做webgl的网页渲染引擎，白鹭实习。学习node react electron技术栈，做的工作还是比较简单的，然后选择读研，就是想多三年学点自己想学的东西。三维人体重建。跟本科时学的东西有关联。在做课题的同时也在回过头来看基础知识，查缺补漏，围绕着C/C++，更接近底层。这么做呢一方面是找工作需要，一方面也是为职业生涯考虑，我是希望可以做全栈工程师。\n计网还有linux环境上的C++开发，没有经验是我的劣势，但是我认为我的学习能力还是可以的，不是说有多快，就是愿意深入了解它，学习的更透彻。\n\n1. 图形研发/引擎：遇到的困难\n1 能用别人的轮子就别自己造； 2 确实是具体问题，但是可以找到解决问题的模板，主要是一些设计模式上的困难，比如如何在更好的使用组合而非继承，观察者模式（比如说一个怪物死掉了，一方面要给任务系统完成任务，一方面人物要加经验，一方面怪物自身的ragdoll要开始生效，C#中的委托） 3 也就是网上找不到答案，比如说写论文做实验用的开源项目，提issue，捋逻辑。  \n最近再跟着utube上的教程做d3d+winapi的渲染引擎\n\n传统软件公司和互联网公司在企业文化，工作内容，工作状态上的差别，需要实际体会；实习是为了投资自己，学习知识；图形开发这个岗位，个人感兴趣，综合之前的学习经历，对画面渲染、几何结构、动画\n\n### 提问环节\n\n团队规模？游戏类型？工作内容？主观上全栈好还是图形ta方向好还是客户端+AI还是做好客户端就行了更新速度已经很快了？其他问题有机会跟hr聊\n测开能转开发吗？测开设计引擎开发的工作吗比如渲染性能、物理性能、画面表现测试，总的来说能学到引擎相关的知识吗？\n\n部门\n加班情况\n是否开展内部技术分享 频率\n\nue项目还是unity项目\nunity目前统治地位，近年开始会往ue倾斜同意吗\n\n# 秋招记录\n\n## 提前批\n\nvivo--软开后端--offer白菜\n广联达--图形开发--offer九月谈\n字节绿洲--引擎--三面负责人挂  \n字节飞书--客户端--一面挂\n字节无双--引擎--一面挂\nUnity--TA实习--面试挂\n猿辅导--客户端--笔试挂  8.22还有一次笔试--未投\n网易雷火--笔试完\n完美--已投\n网易有道--一面结束--部门差不考虑\n快手--已投\n\n\n## 正式批\n\n农行--总行软开--已投\n祖龙--等二面 面试官是程序五部 足球类型 万物觉醒 slg 有引擎中台  \n字节--游戏客户端--8.10已投--笔试完不好\n腾讯魔方--游戏客户端--8.10已投8.23笔试\n中行--五个志愿--已投\n快手--游戏客户端--8.5已投\n爱奇艺--游戏客户端--8.16已投\n百度--c++--8.16已投\n贝壳--ue4引擎开发--8.16已投要求dx11api\n网易互娱--游戏引擎游戏研发--8.17已投\n美团--测开--8.22笔试\n小米--Unity--8.20已投\n\n中国\n\n## offers\n\n秋招：\n* vivo软件工程师（后端）-深圳-白菜24-已拒  \n* 广联达图形开发-北京-往年29-等oc  \n\n# todolist\n\nprofiler使用  \nunity渲染线程 主线程 用户层面多线程以提升效率  \n编译优化  \nlinux C++开发  \n哪些是在构造函数里初始化的  \nrmsl  \n渲染管线，矩阵运算的源码\n\n# 企业列表\n\n[资源链接](https://www.nowcoder.com/discuss/364482)\n\n| 领域                   | 名称                               | 网址                                     | 备注                                            |\n| ---------------------- | ---------------------------------- | ---------------------------------------- | ----------------------------------------------- |\n| 监管机关               | 中国人民银行                       |                                          | 软件开发、信用卡中心                            |\n|                        | 银监会                             |                                          |\n|                        | 保监会                             |                                          |\n|                        | 证监会                             |                                          |\n| 政策性银行             | 国家开发银行                       |                                          |\n|                        | 进出口银行                         |                                          |\n|                        | 中国农业发展银行                   |                                          |\n| 国有银行和商业银行     | 中国银行                           |                                          |\n|                        | 中国农业银行                       |                                          |\n|                        | 中国工商银行                       |                                          |\n|                        | 中国建设银行                       |                                          |\n|                        | 中国邮政                           |                                          |\n|                        | 招商银行                           |                                          |\n|                        | 平安                               |                                          |\n|                        | 浦发                               |                                          |\n|                        | 广发                               |                                          |\n|                        | 中信                               |                                          |\n| 外资银行               | 汇丰银行                           |                                          |\n|                        | 渣打银行                           |                                          |\n| 金融结算，交易服务     | 中国银联总部                       |                                          |\n|                        | 中国网联                           |                                          |\n|                        | 银联商务                           |                                          |\n|                        | （上海、深圳）证券交易所           |                                          |\n|                        | 中国人民银行清算中心               |                                          |\n| 证券公司               | 华泰联合证券                       |                                          |\n|                        | 广发证券                           |                                          |\n| 电力                   | 国家电网                           |[link](https://zhaopin.sgcc.com.cn/unitInfo.html?obj_id=00994041&particulars=true) |提前批会很早 第一批在11月份 牛客为什么有人十月底就拿到offer了。。有考试大纲、刷题多长时间？\n|                        | 国家电网科学院（南瑞集团）         |                                          |\n|                        | 电网子公司                         |                                          |\n| 发电（四大集团）       | 大唐集团科学院                     |                                          |\n|                        | 华润集团                           |                                          |\n|                        | 神华集团                           |                                          |\n|                        | 中国核电                           |                                          |\n| 医院                   |                                    |                                          |\n| 铁路，航空公司         | 铁路局，中国铁道科学院，航空公司， |                                          |\n| 汽车                   |                                    |                                          |\n| 三大运营商及其通信公司 | 联通软件研究院                     |                                          |\n|                        | 中移互联网/中移在线                |                                          |\n|                        | 电信                               |                                          |\n| 外企/互联网公司        | Google                             |                                          |\n|                        | IBM                                |                                          |\n|                        | ORACLE                             |                                          |\n|                        | 微软                               |                                          |\n|                        | 红帽                               |                                          |\n|                        | 万革始                             |                                          |\n|                        | SAP                                |                                          |\n|                        | intel                              |                                          |\n|                        | ThoughtWorks                       |                                          |\n|                        | 三星                               |                                          |\n|                        | 华为                               |                                          |\n| 一线                   | 百度                              |                                          |\n|                        | 阿里                                |                                          |\n|                        | 腾讯                               |                                          |\n|                        | 字节                               |                                          |\n|                        | 快手                                |                                          |\n|                        | ...                                |                                          |\n| 二线                   | 去哪儿                             |                                          |\n|                        | 携程                               |                                          |\n|                        | 京东                                |                                          |\n|                        | 微博                                |                                          |\n|                        | ...                                |                                          |\n| 三线                   | 一个app撑一个公司                  |                                          |\n| 创业公司               | 画饼                               |                                          |\n| 独角兽                 | 商汤                               |                                          |\n| 传统/制造业            | 旷视科技                           |                                          |\n|                        | 深信服                             |                                          |\n|                        | 新华三等                           |                                          |\n|                        | 浪潮集团                           |                                          |\n|                        | 龙湖地产科技部                     |                                          |\n|                        | 顺丰科技                           |                                          |\n|                        | 大疆科技                           |                                          |\n|                        | 格力电器                           |                                          |\n| 事业单位               | 国家统计局                         | http://www.stats.gov.cn/zjtj/gjtjj/jgsz/ | 考生在规定的报名时间内(自公告发布之日至4月10日) |\n\n游戏公司：  \n字节、快手、畅游、祖龙、完美、光宇  \n外地：网易、腾讯、字节、米哈游、unity\n没听说过的：  \n聚力维度：ai+unity+vr/ar 创业公司\n\n\n","content":"<h1 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h1><h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><p><a href=\"https://github.com/huihut/interview#%EF%B8%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\" target=\"_blank\" rel=\"noopener\">资料</a><br>TCP创建连接：三次握手<br>释放连接：四次挥手  </p>\n<p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。  </p>\n<p>TLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。  </p>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><p><a href=\"https://blog.csdn.net/qq_43079376/article/details/93647335\" target=\"_blank\" rel=\"noopener\">BCNF（修正的第三范式3NF）</a></p>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><p><a href=\"https://taye310.github.io/2019/02/18/lang-notebook/\" target=\"_blank\" rel=\"noopener\">C++ &amp; C#/Unity notebook</a></p>\n<h2 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h2><p><a href=\"https://github.com/huihut/interview\" target=\"_blank\" rel=\"noopener\">github</a>  </p>\n<p><a href=\"https://leetcode-cn.com/problems/jump-game-ii/\" target=\"_blank\" rel=\"noopener\">贪心算法实例</a></p>\n<p><a href=\"https://www.zhihu.com/question/38206659/answer/763034261\" target=\"_blank\" rel=\"noopener\">位运算相关</a></p>\n<p>（重要）单调栈：<a href=\"https://blog.csdn.net/lucky52529/article/details/89155694\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<p>并查集：<a href=\"https://zhuanlan.zhihu.com/p/93647900\" target=\"_blank\" rel=\"noopener\">link1</a><br><a href=\"https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-/\" target=\"_blank\" rel=\"noopener\">leetcode 990 等式方程的可满足性</a><br>定义：根节点作为代表元，代表一类数据；每个数据都存一个自己的父节点；<br>优化：由于是树形结构，肯定绕不开树的高度这个问题（越高查询效率越慢）</p>\n<ol>\n<li>路径压缩：查询过程中，更改节点指向，降低树高——隔代压缩/完全压缩</li>\n<li>按秩合并：秩为树高或者节点个数（1、2两种方法选一即可）<div style=\"width:300px\">\n <img src=\"/2019/09/16/校招学习笔记/unionfind.png\">\n</div>\n\n</li>\n</ol>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/\" target=\"_blank\" rel=\"noopener\">线段树，有点谜</a></p>\n<p><strong>十大排序</strong></p>\n<p>冒泡：两层循环，两两比较<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"comment\">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(T arr[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; len - <span class=\"number\">1</span> - i; j++)</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">                                swap(arr[j], arr[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>选择：未排序序列里找最小（大）的放到最前边<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"comment\">//整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（&gt;）的運算子功能</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">selection_sort</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; arr.size(); j++)</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (arr[j] &lt; arr[min])</span><br><span class=\"line\">                                min = j;</span><br><span class=\"line\">                <span class=\"built_in\">std</span>::swap(arr[i], arr[min]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>插入：未排序序列的第一个，插入到已排序序列中的合适位置，已排序序列从后往前遍历arr[j+1] = arr[j]<br>插排的问题在于：如果在后面来了一个特别小的元素，需要全部移动，那么排序的效率特别低。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insertion_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> key=arr[i];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j=i<span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>((j&gt;=<span class=\"number\">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;</span><br><span class=\"line\">                        arr[j+<span class=\"number\">1</span>]=arr[j];</span><br><span class=\"line\">                        j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>]=key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>希尔（插入排序改进）：n个数先分n/2组(gap = n/2)，分组进行插入排序（n=10，也就是1st数和6th数一组进行插入排序，2-7，3-8，4-9，5-10），然后gap = n/4…<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shell_sort</span><span class=\"params\">(T <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (h &lt; length / <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        h = <span class=\"number\">3</span> * h + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (h &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= h &amp;&amp; <span class=\"built_in\">array</span>[j] &lt; <span class=\"built_in\">array</span>[j - h]; j -= h) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">std</span>::swap(<span class=\"built_in\">array</span>[j], <span class=\"built_in\">array</span>[j - h]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h = h / <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>快排：第一个做pivot，小于大于放左右，在迭代<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//严蔚敏《数据结构》标准分割函数</span></span><br><span class=\"line\"> Paritition1(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> pivot = A[low];</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class=\"line\">       --high;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     A[low] = A[high];</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class=\"line\">       ++low;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     A[high] = A[low];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   A[low] = pivot;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> low;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> <span class=\"comment\">//快排母函数</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (low &lt; high) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> pivot = Paritition1(A, low, high);</span><br><span class=\"line\">     QuickSort(A, low, pivot - <span class=\"number\">1</span>);</span><br><span class=\"line\">     QuickSort(A, pivot + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>归并：分两半，分不到不能分，在一层一层合并回来；合并的时候保证每层有序<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Array, <span class=\"keyword\">int</span> front, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// preconditions:</span></span><br><span class=\"line\">    <span class=\"comment\">// Array[front...mid] is sorted</span></span><br><span class=\"line\">    <span class=\"comment\">// Array[mid+1 ... end] is sorted</span></span><br><span class=\"line\">    <span class=\"comment\">// Copy Array[front ... mid] to LeftSubArray</span></span><br><span class=\"line\">    <span class=\"comment\">// Copy Array[mid+1 ... end] to RightSubArray</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; LeftSubArray(Array.begin() + front, Array.begin() + mid + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; RightSubArray(Array.begin() + mid + <span class=\"number\">1</span>, Array.begin() + end + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idxLeft = <span class=\"number\">0</span>, idxRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LeftSubArray.insert(LeftSubArray.end(), numeric_limits&lt;<span class=\"keyword\">int</span>&gt;::max());</span><br><span class=\"line\">    RightSubArray.insert(RightSubArray.end(), numeric_limits&lt;<span class=\"keyword\">int</span>&gt;::max());</span><br><span class=\"line\">    <span class=\"comment\">// Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = front; i &lt;= end; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) &#123;</span><br><span class=\"line\">            Array[i] = LeftSubArray[idxLeft];</span><br><span class=\"line\">            idxLeft++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Array[i] = RightSubArray[idxRight];</span><br><span class=\"line\">            idxRight++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Array, <span class=\"keyword\">int</span> front, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (front &gt;= end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (front + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    MergeSort(Array, front, mid);</span><br><span class=\"line\">    MergeSort(Array, mid + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">    Merge(Array, front, mid, end);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>堆排序，构建最大/最小堆时：</p>\n<ol>\n<li>父结点索引：(i-1)/2（这里计算机中的除以2，省略掉小数）</li>\n<li>左孩子索引：2*i+1</li>\n<li>右孩子索引：2*i+2  </li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">max_heapify</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 建立父節點指標和子節點指標</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dad = start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> son = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (son &lt;= end) &#123; <span class=\"comment\">// 若子節點指標在範圍內才做比較</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (son + <span class=\"number\">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class=\"number\">1</span>]) <span class=\"comment\">// 先比較兩個子節點大小，選擇最大的</span></span><br><span class=\"line\">            son++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[dad] &gt; arr[son]) <span class=\"comment\">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 否則交換父子內容再繼續子節點和孫節點比較</span></span><br><span class=\"line\">            swap(arr[dad], arr[son]);</span><br><span class=\"line\">            dad = son;</span><br><span class=\"line\">            son = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">heap_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化，i從最後一個父節點開始調整</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        max_heapify(arr, i, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        swap(arr[<span class=\"number\">0</span>], arr[i]);</span><br><span class=\"line\">        max_heapify(arr, <span class=\"number\">0</span>, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>计数/桶排序  </p>\n<p>基数排序</p>\n<p>稳定性：稳定性是一个特别重要的评估标准。稳定的算法在排序的过程中不会改变元素彼此的位置的相对次序,反之不稳定的排序算法经常会改变这个次序,这是我们不愿意看到的。</p>\n<p><strong>查找算法</strong></p>\n<p><strong>动态规划</strong><br><a href=\"https://mp.weixin.qq.com/s/yEfrTK7UhRN0XX0_FVLyGA\" target=\"_blank\" rel=\"noopener\">详解</a></p>\n<p><strong>时间复杂度计算：</strong><br><a href=\"https://blog.csdn.net/kun1280437633/article/details/80770296\" target=\"_blank\" rel=\"noopener\">参考资料</a>  </p>\n<p>对数阶怎么来的：循环的时候i不是+常数来的，是i=i*2这样乘来的就是对数阶复杂度了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i&lt;100) i=i*2;</span><br></pre></td></tr></table></figure></p>\n<p>$i^2=100$ -&gt; $O(log_{2}100)$ </p>\n<p><strong>二叉树计算公式总结：</strong>  </p>\n<ol>\n<li>n个节点的二叉树一共有((2n)!)/(n! * (n+1)!)种 <a href=\"https://blog.csdn.net/iG_xdd/article/details/79808519\" target=\"_blank\" rel=\"noopener\">catalan数</a></li>\n<li>n层二叉树的第n层最多为2^(n-1)个</li>\n<li>二叉树节点计算公式 N = n0+n1+n2，度为0的叶子节点比度为2的节点数多一个。N=1<em>n1+2</em>n2+1</li>\n<li>对任何一棵二叉树T，如果其终端节点数为n0，度为2的节点数为n2，则n0=n2+1</li>\n<li>具有n个节点的完全二叉树的深度为log2(n + 1)</li>\n</ol>\n<p><strong>图计算公式总结：</strong><br>N个点的无向完全图边数为：N*（N-1）/2；<br>先手获胜必须总数为奇数；<br>N=1,2,3,……,9,10代入公式，为奇数的只有N=2,3,6,7,10这5个。  </p>\n<blockquote>\n<p><strong>无向图：</strong><br>遍历：DFS用栈 / BFS用队列<br>邻接矩阵法存图 占用空间与什么有关<br>在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图，则其中的极大连通子图称为连通分量，这里所谓的极大是指子图中包含的顶点个数极大。<br>A,边的条数为C（n,2）=n(n-1)/2<br>B,G是完全图，必定是连通图。所以连通分量只有其自身<br>C，G是完全图，必定是连通图<br>D，每个顶点都与其余n-1个顶点相连，则n个顶点度的和为n(n-1)  </p>\n<p><strong>无向带权图的最小生成树算法——Prim及Kruskal算法思路</strong><br> 带权图分为有向和无向，无向图的最短路径又叫做最小生成树，有prime算法和kruskal算法；有向图的最短路径算法有dijkstra算法和floyd算法。<br> <a href=\"https://www.cnblogs.com/aiyelinglong/archive/2012/03/26/2418707.html\" target=\"_blank\" rel=\"noopener\">最小生成树（prime算法、kruskal算法） 和 最短路径算法（floyd、dijkstra）</a>  </p>\n<p><strong>广义表：</strong><br>head() 返回列表的第一个元素；<br>tail() 返回列表的删去第一个元素之后的剩余列表；  </p>\n<p><strong>hash：</strong><br>装填因子：对5个对象进行hash,而内存中，准备了20个位置，那么还有15个空位，最后装填因子就是5/20 = 0.25，所以装填因子越小，产生冲突的可能越小。<br>1、hash索引仅满足“=”、“IN”和“&lt;=&gt;”查询，不能使用范围查询<br>因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。<br>2、hash索引无法被用来进行数据的排序操作<br>由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样，所以数据库无法利用hash索引中的值进行排序操作。<br>3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。<br>4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。<br>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。  </p>\n<p><strong>循环队列：</strong><br>front=rear意味着队空或者队满，再入队或者出队就要上溢或者下溢了  </p>\n<p><strong>杂项：</strong><br>KMP算法：一种不舍弃之前匹配信息的字符串匹配算法，时间复杂度O(m+n) 其中<em>next[j]就是第j个元素前j-1个元素首尾重合部分个数加一</em><br>输出受限的双端队列,即删除限制在一端进行,而插入仍允许在两端进行.  </p>\n</blockquote>\n<h2 id=\"其他知识点\"><a href=\"#其他知识点\" class=\"headerlink\" title=\"其他知识点\"></a>其他知识点</h2><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。  </p>\n<p>正则表达式：</p>\n<h2 id=\"leetcode刷题\"><a href=\"#leetcode刷题\" class=\"headerlink\" title=\"leetcode刷题\"></a>leetcode刷题</h2><p>109 有序链表转换二叉搜索树<br>    快慢指针加递归 每次递归，都是把链表分成两段；前面的那个链表末尾必须要加上nullptr，才算是分成了两个链表。</p>\n<p>56  合并区间<br>    push_back 和 emplace_back的区别，e更好 因为少一个构造函数<br>    <a href=\"https://blog.csdn.net/Kprogram/article/details/82055673\" target=\"_blank\" rel=\"noopener\">emplace可以直接传入构造对象需要的元素，然后自己调用其构造函数！</a>  </p>\n<p>712 两个字符串的最小ascii删除和<br>    DP LCS 最长公共子序列（Longest Common Sequence）<br>    最优子结构/重叠子问题（用dp就是查表得到的不用重新计算）</p>\n<p>407 接雨水2</p>\n<p>208 实现前缀树  </p>\n<p>207 课程表<br>有向无权图是否存在环，用拓扑排序（记入度、还有邻接表，然后从入度为1的点开始删边就可以了，看最后入度是否都为0）判断，还可以使用DFS</p>\n<p>面试题41. 数据流中的中位数<br>二分查找插入用到了模板函数lower_bound/upper_bound(store.begin(), store.end(), num)<br>时间复杂度 $O(logN) + O(N)$ 约等于$O(N)$<br>（重要）<a href=\"https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/solution/xiang-jie-you-xian-dui-lie-tan-xin-suan-fa-by-z1m/\" target=\"_blank\" rel=\"noopener\">优先队列priority_queue</a> 时间复杂度$O(logN)$ 本质上是个堆，一棵完全二叉树<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对于基础类型 默认是大顶堆</span></span><br><span class=\"line\">    priority_queue&lt;<span class=\"keyword\">int</span>&gt; a; </span><br><span class=\"line\">    <span class=\"comment\">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">//      这里一定要有空格，不然成了右移运算符↓↓</span></span><br><span class=\"line\">    priority_queue&lt;<span class=\"keyword\">int</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;, greater&lt;<span class=\"keyword\">int</span>&gt; &gt; c;  <span class=\"comment\">//这样就是小顶堆</span></span><br></pre></td></tr></table></figure></p>\n<p>820 <a href=\"https://leetcode-cn.com/problems/short-encoding-of-words/\" target=\"_blank\" rel=\"noopener\">单词的压缩编码</a>：字典树  </p>\n<p><a href=\"https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/\" target=\"_blank\" rel=\"noopener\">面试题62</a>. 圆圈中最后剩下的数字：约瑟夫环<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = f(n - <span class=\"number\">1</span>, m);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (m + x) % n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lastRemaining</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(n, m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lastRemaining</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i != n + <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">            f = (m + f) % i;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>135 <a href=\"https://leetcode-cn.com/problems/candy/\" target=\"_blank\" rel=\"noopener\">分发糖果（头条笔试题）</a>  </p>\n<p>887 <a href=\"https://leetcode-cn.com/problems/super-egg-drop/\" target=\"_blank\" rel=\"noopener\">鸡蛋掉落</a>，vivo笔试题<br>第一种方法： 问题转换成dp[i][j]表示有i个鸡蛋、j次扔鸡蛋次数时可以测的最多楼层，扔鸡蛋次数最多不会超过N次（线性扫描）；所以当dp[i][j]等于N的时候j的值就是我们想要的答案  </p>\n<script type=\"math/tex; mode=display\">dp[j][m] = dp[j - 1][m - 1] + dp[j][m-1] + 1</script><p>第二中状态定义和转移公式： 按着题意来dp[k][n]表示k个鸡蛋，n层楼的最少测试次数，<script type=\"math/tex\">dp[K,N] = 1+min_{1<=X<=N}(max(dp(K-1,X-1),dp(K,N-X)))</script>  </p>\n<p><strong>剑指offer系列：</strong><br>size_t: 与int固定四个字节不同有所不同,size_t的取值range是目标平台下最大可能的数组尺寸,一些平台下size_t的范围小于int的正数范围,又或者大于unsigned int. 使用Int既有可能浪费，又有可能范围不够大。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">replaceSpace</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> pos;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        pos = s.find(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos&lt;<span class=\"built_in\">string</span>::npos)&#123;</span><br><span class=\"line\">            s.replace(pos,<span class=\"number\">1</span>,<span class=\"string\">\"%20\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>面试题16. 数值的整数次方： 可以用位运算，$3^5 = 3^{101_{2}} = 3^{2^2+2^0} = 9^2*3^1$  </p>\n<p>vector的insert方法使用迭代器参数可以用来合并vector  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(!s.empty()&amp;&amp;pos&lt;popped.size()&amp;&amp;popped[pos] == s.top())&#123;<span class=\"comment\">//三个条件的顺序很重要</span></span><br></pre></td></tr></table></figure>\n<p>中序遍历用 栈  </p>\n<p>837.新21点和 983 旅行票价 动态规划+从后遍历经典题；看起来很麻烦，代码很简单  </p>\n<p>63.不同路径II；动态规划求解而非递归，用到了滚动数组来优化dp，滚动数组应该多看一下  </p>\n<h2 id=\"牛客刷题\"><a href=\"#牛客刷题\" class=\"headerlink\" title=\"牛客刷题\"></a>牛客刷题</h2><p>union的大小取决于它所有的成员中，占用空间最大的一个成员的大小，并且需要内存对齐  </p>\n<p>c++的类体中，方法以外的区域不允许有初始化，简单类型是可以的，但是有构造函数的复杂对象则不行了，比如string对象！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error,expected identifier before numeric constant</span><br></pre></td></tr></table></figure>\n<h3 id=\"猿辅导真题\"><a href=\"#猿辅导真题\" class=\"headerlink\" title=\"猿辅导真题\"></a>猿辅导真题</h3><p><a href=\"https://www.nowcoder.com/test/question/done?tid=35339605&amp;qid=808488#summary\" target=\"_blank\" rel=\"noopener\">击鼓传花</a>，k个人传n次，最后一个人要是第一个人<br>dp可以70%，要用矩阵快速幂没用过  </p>\n<h1 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h1><p>项目经历的star原则 p6  </p>\n<h2 id=\"面试问题总结\"><a href=\"#面试问题总结\" class=\"headerlink\" title=\"面试问题总结\"></a>面试问题总结</h2><p>分别在什么时候使用引用和指针：指向的对象不为空的时候使用</p>\n<p>为什么要分栈和对，不能合并？：栈的好处是：方便、快、有效避免内存碎片化。栈的问题是：不利于管理大内存、数据的生命周期难于控制，所以栈不利于动态地管理并且有效地利用宝贵的内存资源。于是我们有了堆  </p>\n<p><a href=\"https://blog.csdn.net/w450468524/article/details/51649651\" target=\"_blank\" rel=\"noopener\">伽马校正（gamma correction）</a>：需要注意的是，像法线贴图，高光贴图等通常是在线性空间中生成的的，无需进行反伽马校正  </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/78769570\" target=\"_blank\" rel=\"noopener\">z-fighting</a>：模型闪烁的问题  </p>\n<p>setpass call &amp; batches：一次cpu把数据交给gpu处理叫一个drawcall。draw位于setpasscall 和batch中。使用相同材质信息draw call 才能放到一个batch中。一个材质球引用的shader可以有多个pass，因此携带这个材质球的物体会被渲染多次，”激活”一一个pass的过程就是set pass call。因此改变影响 pass的行为都会触发一次set pass call（比如游戏运行中开启阴影进而影响了渲染管线），因此把set pass call 作为影响drawcall的一个标准。  </p>\n<p>如何检测内存泄漏，怎么写代码可以尽可能避免内存泄漏：<br>判断内存是否泄漏的方法：</p>\n<ul>\n<li>检查资源的使用情况，特别是纹理、网格等资源的使用</li>\n<li>通过Profiler来检测WebStream或SerializedFile的使用情况</li>\n<li>通过Android PSS/iOS Instrument反馈的App线程内存来查看</li>\n</ul>\n<p>C#多线程<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span> <span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>C#attribute  </p>\n<p>哈希解决冲突：开放定址法，再哈希法，链地址法<br>这个方法的基本思想是：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止<br>链地址法解决冲突的做法是：如果哈希表空间为 0 ～ m - 1 ，设置一个由 m 个指针分量组成的一维数组 ST[ m ], 凡哈希地址为 i 的数据元素都插入到头指针为 ST[ i ] 的链表中。这种方法有点近似于邻接表的基本思想，且这种方法适合于冲突比较严重的情况  </p>\n<p>哈希索引和b+树索引：</p>\n<ul>\n<li>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</li>\n<li>从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li>\n<li>哈希索引也不支持多列联合索引的最左匹配规则；</li>\n<li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</li>\n</ul>\n<p>C#的虚函数的override和new：前者是重写（覆盖），后者只是隐藏了父类中的虚函数，如果用父类指针指向子类对象，调用new的函数，调用的还是父类的。总结通俗的讲：new：父类看不到子类的new的新方法，子类看不到父类被new的方法， 而override: 父类和子类看到的都是子类override后的方法。</p>\n<p>线程池的概念：避免频繁创建销毁线程，等待队列、线程管理</p>\n<p>Unity的生命周期：awake，update，fixedupdate，lateupdate</p>\n<p>为什么IP在网络层，TCP、UDP在传输层，它们是怎么工作的？<br>ip在网络层，负责路由；tcp/udp在传输层负责一有链接或者无连接的方式传送消息</p>\n<p>DrawCall的含义就是CPU调用图像编程接口，以命令GPU进行渲染的操作。</p>\n<p>lua元表：设置了元表的table，如果元表的index是个table，外层表索引的数据为nil就上元表的这个index里找</p>\n<p>fixedupdate\\update\\lateupdate：fixed物理相关的都放在里边，因为他是固定时间间隔（也是每帧update一次）；update是每帧一次，但是时间间隔不一定，看渲染效率；late在update之后。  </p>\n<p>模板和宏的区别：</p>\n<ol>\n<li>宏是在预处理阶段处理，模板是在编译阶段处理</li>\n<li>宏不会进行类型检查，只会单纯的进行文本替换，模板会进行类型检查。比如下面代码模板就会出错，而宏不会</li>\n<li>宏直接就可以产生代码，而编译器遇到模板定义时，并不产生代码，只有当模板实例化后时才会产生代码。</li>\n</ol>\n<p>协程底层实现：函数返回一个迭代器类型，函数中可以多次yield return就像数组下标一样</p>\n<p>如何做虚拟地址映射：虚拟地址是4g，user3，kernel1，结构是页表</p>\n<p>进程如何分配地址：堆栈、静态、常量、自由</p>\n<p><a href=\"https://blog.csdn.net/isunbin/article/details/99568217\" target=\"_blank\" rel=\"noopener\">C++如何保证类不被继承</a>：借助友元来实现，因为友元这个特性是不可以被继承的。如果一个类的构造函数要借助它的友元类，那么继承了这个类的类就无法构造自己的对象。从而杜绝了被继承<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BASE</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    BASE() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>;</span>    <span class=\"comment\">//设class C为class BASE的友元</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> BASE</span><br><span class=\"line\">&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> :</span> <span class=\"keyword\">public</span> C </span><br><span class=\"line\">&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    C c;</span><br><span class=\"line\">    <span class=\"comment\">//D d;   不可以实例化对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Matcap的原理并不复杂，就是使用一张中间为球面的图片作为不同法线方向的光照颜色，然后将这些颜色根据模型的法线信息渲染到相应位置。用于均一表面反射材质的着色器，在Zbrush/Mudbox等软件中被广泛运用。它借助一幅含有球面的图片作为视线空间的环境映射，计算成本非常低廉，当相机不转动时视觉效果极其出色。</p>\n<p>计算机中的流水线：每条指令分成多步，各指令间轮转顺序执行，实现并行效果（实际还是一条条执行的）；效率瓶颈，就让每一步更细分</p>\n<p><a href=\"https://blog.csdn.net/shaocize/article/details/89702151\" target=\"_blank\" rel=\"noopener\">帧同步与状态同步</a>：状态tcp，帧udp；同步每个单位的状态，单位数量增加数据量增加，帧同步同步操作，操作通过运算可以达到一致的状态（游戏逻辑执行在本地，所以不好防外挂，防的方法可以算状态hash对比，或者记录战斗数据分析），单位再多同步数据量也不会增加</p>\n<p>udp如何避免丢包：<br>原因：</p>\n<ol>\n<li>接收端处理时间过长导致丢包</li>\n<li>发送的包巨大丢包</li>\n<li>发送的包较大，超过接受者缓存导致丢包</li>\n<li>发送的包频率太快</li>\n</ol>\n<p>new和malloc的区别：<br>new/delete（C++运算符）会自动调用构造函数和析构函数，底层是malloc/free（标准库函数，编译器无权控制其调用构造/析构函数），比其更智能<br>失败后前者抛异常，后者返回NULL，成功返回的都是指针  </p>\n<p>进程线程的区别：已有  </p>\n<p>vector/set实现机制：<br>vector用数组,set用的时红黑树。Vector内存分配使用的是STL的allocator分配器，采用二层分配机制，申请内存大于128K时使用malloc，小于128K时使用内存池，接着讲了一下内存池的机制，维护16个空闲链表之类的<br>vector动态增加大小时，并不是在原空间之后持续新空间（因为根本无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间，因此，一旦引起空间重新配置，指向原vector的所有迭代器都失效了，这是程序员易犯的一个错误，务必小心<br>set 底层红黑树（平衡二叉树）目的是为了高效检索</p>\n<p>数据库索引作用，怎么实现的：<br>高效获取数据，BTree索引、哈希索引、全文索引等<br><a href=\"https://zhuanlan.zhihu.com/p/27700617\" target=\"_blank\" rel=\"noopener\">BST、BTree、B+Tree</a>  </p>\n<p>虚函数如何实现动态多态的：<br>动态多态与静态多态，静态多态就是在系统编译期间就可以确定程序执行到这里将要执行哪个函数，函数的重载，对象名加点操作符执行成员函数等；<br>多态的实现：分为两类，编译时的多态与运行时的多态。前者在编译的过程中确定了同名的具体操作对象，而后者是在程序运行过程中才多态地确定操作所指向的对象。这种确定操作具体对象的过程就是绑定。绑定工作在编译连接阶段完成的情况为静态绑定，在程序运行过程中完成的情况是动态绑定。<br>重载overload：函数名相同，但是函数参数不同。调用时根据参数的不同决定调用哪一个函数；<br>多态：函数名相同，函数形参也相同。调用时根据函数类型是虚函数还是普通成员函数决定调用哪一个。  </p>\n<p>纯虚函数的作用：向子类提供接口，定义纯虚函数的类为抽象类  </p>\n<p>结构体和类的区别：</p>\n<p>结构体为什么要字节对齐：</p>\n<p>LCA算法：</p>\n<h3 id=\"图形学\"><a href=\"#图形学\" class=\"headerlink\" title=\"图形学\"></a>图形学</h3><p>碰撞检测：</p>\n<ol>\n<li>两个立方体的碰撞检测：<ol>\n<li>AABB（axis-aligned bounding box，不可旋转，有向包围盒）：</li>\n<li>OBB（Oriented Bounding Box，可旋转）：</li>\n</ol>\n</li>\n<li>球体的碰撞检测：简单，圆心距离与半径相比较</li>\n<li>三角形是否相交：遍历A的每条边，看有没有穿过B的</li>\n</ol>\n<p>HDR到LDR：tonemapping（色调映射）</p>\n<h1 id=\"面经复盘\"><a href=\"#面经复盘\" class=\"headerlink\" title=\"面经复盘\"></a>面经复盘</h1><h2 id=\"字节跳动—游戏研发\"><a href=\"#字节跳动—游戏研发\" class=\"headerlink\" title=\"字节跳动—游戏研发\"></a>字节跳动—游戏研发</h2><div style=\"width:300px\">\n    <img src=\"/2019/09/16/校招学习笔记/jrtt1.jpg\">\n</div>\n\n<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">指针常量：int * const p</span><br><span class=\"line\">常量指针：const int * p</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断扇形区域内<br>算两点距离（半径） 算两向量夹角  </p>\n</li>\n<li><p>一万个球，知道圆心位置和半径，如何预处理/数据结构存储，新加球可以最少次数判断是否相交<br>八叉树  </p>\n</li>\n<li><p>4个人分100金币，第一个人怎么分半数以上人同意（智力题？）<br>给第三个人一个金币，不然他一个也拿不到  </p>\n</li>\n<li><p>无向图连通最小花费：最小生成树（prime，keruskal）//有向图最短路径（单源dijstra，多源floyd）<br>prime(加点法):每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。<br>kruskal(加边法):初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</p>\n</li>\n</ol>\n<p>dijkstra：类似prime  </p>\n<p>floyd多源最短路径：动态规划Dis(i,j) = Dis(i,k) + Dis(k,j)  </p>\n<ol>\n<li><p>字符串以词为单位反转<br>两个栈  </p>\n</li>\n<li><p>顶点着色器/片元着色器作用/什么是片元<br>顶点着色器：分为输入和输出两部分,负责的功能是把输入的数据进行矩阵变换位置,计算光照公式生成逐顶点颜⾊,⽣成/变换纹理坐标.并且把位置和纹理坐标这样的参数发送到片段着色器.<br>片元着色器：处理由光栅化阶段生成的每个片元，最终计算出每个像素的最终颜色。归根结底，实际上就是数据的集合。这个数据集合包含每一个像素的各个颜色分量和像素透明度的值。</p>\n</li>\n</ol>\n<p><em>光栅化</em>，就是计算出1920×1080这么长的RGB数组中，每一个RGB的值</p>\n<p>3D场景中将三角形作为基本<em>图元</em></p>\n<p>片元是光栅化过程的产物；光栅化是将一个图元转变为一个二维图象，二维图象上每个点都包含了颜色、深度和纹理数据，将该点和相关信息叫做一个片元  </p>\n<p>设计模式！工厂/观察者/策略模式？<br>工厂模式：调用工厂只管给个名字，工厂里根据名字实例化对应的对象（选对应接口）；解决了接口选择的问题，拓展方便。</p>\n<p>观察者模式：mvc，子类继承一个update方法，使用者在notify所有监听的子类时调用基类update</p>\n<p>策略模式：核心是有个context，根据构造函数实例化了strategy的具体一种子类作为context的成员，因此context.excuteStrategy()可以调用context里的特定的strategy实例的doStrategy方法</p>\n<p>stl里的trace？<br>trace()函数？调试用的</p>\n<p>工厂模式有几种？？<br>3：简单工厂/工厂模式/抽象工厂（工厂的工厂）</p>\n<p>光照模型公式<br>3D渲染中， 物体表面的光照计算公式为：  </p>\n<p>I = 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular);  </p>\n<p>其中，环境光(ambient)计算公式为：</p>\n<p>Iambient = Aintensity * Acolor ; (Aintensity表示环境光强度，Acolor表示环境光颜色)</p>\n<p>漫反射光(diffuse)计算公式为：</p>\n<p>Idiffuse = Dintensity<em>Dcolor</em>N·L ; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量) ps:点乘是投影</p>\n<p>镜面光照(specular)计算公式为：</p>\n<p>Ispecular = Sintensity<em>Scolor</em>(R·V)n ; (Sintensity表示镜面光照强度，Scolor表示镜面光颜色，R为光的反射向量，V为观察者向量)</p>\n<p>综上所得：整个光照公式为：</p>\n<p>I = Aintensity <em> Acolor + Dintensity</em>Dcolor<em>N.L + Sintensity</em>Scolor*(R.V)n ;</p>\n<p>将一些值合并，并使用白色作为光照颜色，则上述公式可简化为：</p>\n<p>I = A + D*N.L + (R.V)n</p>\n<p>类的内存结构<br><a href=\"https://blog.csdn.net/fenxinzi557/article/details/51995911\" target=\"_blank\" rel=\"noopener\">link</a><br>记得字节对齐  </p>\n<p>cpp文件属性命令行分页栏中加入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/d1 reportAllClassLayout</span><br></pre></td></tr></table></figure></p>\n<p>可以查看内存布局<br>包含虚函数的类头部有虚表指针，虚表真正的位置在静态存储区  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> c;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i; <span class=\"comment\">//是8字节 因为int之前的要对齐到int的4字节</span></span><br></pre></td></tr></table></figure>\n<p>类中有虚函数 要+4字节 因为有虚函数表  函数本身不占字节<br>继承的子类要先放父类的数据拷贝  </p>\n<ol>\n<li>对于基类，如果有虚函数，那么先存放虚函数表指针，然后存放自己的数据成员；如果没有虚函数，那么直接存放数据成员。 </li>\n<li>对于单一继承的类对象，先存放父类的数据拷贝(包括虚函数表指针)，然后是本类的数据。 </li>\n<li>虚函数表中，先存放父类的虚函数，再存放子类的虚函数 </li>\n<li>如果重载了父类的某些虚函数，那么新的虚函数将虚函数表中父类的这些虚函数覆盖。 </li>\n<li>对于多重继承，先存放第一个父类的数据拷贝，在存放第二个父类的数据拷贝，一次类推，最后存放自己的数据成员。其中每一个父类拷贝都包含一个虚函数表指针。如果子类重载了某个父类的某个虚函数，那么该将该父类虚函数表的函数覆盖。另外，子类自己的虚函数，存储于第一个父类的虚函数表后边部分。 </li>\n<li>当对象的虚函数被调用是，编译器去查询对象的虚函数表，找到该函数，然后调用。</li>\n</ol>\n<p>构造函数/析构函数/虚函数  </p>\n<p><strong>在构造/析构函数中调用虚函数：</strong> effective c++ 条款9：永远不要在构造函数或析构函数中调用虚函数</p>\n<div style=\"width:300px\">\n    <img src=\"/2019/09/16/校招学习笔记/jrtt3.jpg\">\n</div>\n\n<blockquote>\n<blockquote>\n<p>信号量<br>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。  </p>\n</blockquote>\n</blockquote>\n<p>互斥量和信号量的区别：  </p>\n<ol>\n<li><p>互斥量用于线程的互斥，信号量用于线程的同步。<br>这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源  </p>\n</li>\n<li><p>互斥量值只能为0/1，信号量值可以为非负整数。<br>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。  </p>\n</li>\n<li><p>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。  </p>\n</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/judgejames/article/details/87286397\" target=\"_blank\" rel=\"noopener\">互斥锁、自旋锁、读写锁</a>：读写锁，读可以多线程同时占有，写只能有一个线程占有，读写不同时，还有个不加锁状态；互斥锁，一次只能一个线程拥有互斥锁，其他线程只有等待；自旋锁，特殊的互斥锁，不睡眠，循环等待，好处是节省睡眠唤醒的资源  </p>\n<blockquote>\n<blockquote>\n<p>死锁  </p>\n<p>进程和线程的区别 PCB TCB</p>\n<ol>\n<li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）</li>\n<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。<br>而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li>\n<li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li>\n<li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li>\n</ol>\n</blockquote>\n</blockquote>\n<p><div style=\"width:300px\">\n    <img src=\"/2019/09/16/校招学习笔记/jrtt2.jpg\">\n</div></p>\n<blockquote>\n<blockquote>\n<p>80个球找轻的  </p>\n<p>64个人，提前准备名单卡片来确认是哪个人  </p>\n<p>九宫格密码解锁的所有可能，大于等于四位数</p>\n</blockquote>\n</blockquote>\n<h2 id=\"网易雷火—牛客网\"><a href=\"#网易雷火—牛客网\" class=\"headerlink\" title=\"网易雷火—牛客网\"></a>网易雷火—牛客网</h2><p>问简历内容<br>游戏内AI如何实现：有限状态机，行为树<br>一个UI被点击后发生了什么：  </p>\n<p><strong>基础相关：</strong><br>C++虚函数机制，虚表，虚指针：<br>虚函数实在派生类可以覆写的函数，虚表存在于类内存中，记录了所有虚函数，每个虚表对应一个虚指针指向它，这个指针在类的每个实例化对象中都有。  </p>\n<p>c++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此，在子类从新声明该虚函数时，可以加，也可以不加，但习惯上每一层声明函数时都加virtual,使程序更加清晰。</p>\n<p>构造函数可以是虚函数吗？<br>不可以，虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。  </p>\n<blockquote>\n<blockquote>\n<p>C# 内存模型 堆和栈<br><a href=\"https://www.cnblogs.com/omg24/p/4202992.html\" target=\"_blank\" rel=\"noopener\">link</a>  </p>\n<p><div style=\"width:400px\">\n    <img src=\"/2019/09/16/校招学习笔记/valueandref.png\">\n</div><br><a href=\"https://www.cnblogs.com/xiaodongy/p/7989711.html\" target=\"_blank\" rel=\"noopener\">link2</a></p>\n</blockquote>\n</blockquote>\n<p>C# gc 值类型与引用类型<br>注：Ref和Out的区别在于Ref在传递前需要初始化。<br>值类型在栈上，引用类型在堆上；前者不需要gc，后者需要<br>close()可以再open，dispose()后资源被标记为无用，等待gc回收<br>非托管资源需要在程序中显式释放<br>对象间相互引用导致了gc丧失实时性，变为不确定的方式，否则可以用引用计数这种方法判断对象是否无用<br>GC清理垃圾实际上就是调用析构函数<br>String对象是不可变的（只读），一旦创建不可改变，看似修改其实是返回了一个新对象  </p>\n<p><a href=\"https://blog.csdn.net/zmazon/article/details/8547278\" target=\"_blank\" rel=\"noopener\">随机在圆上生成n个点，这n个点在同一半圆的概率是多少？</a></p>\n<p>lua闭包<br>内部（子）函数可以使用外部（父）函数的局部变量<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> i=<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"comment\">--尾调用</span></span><br><span class=\"line\">        i+=<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">c1=test()</span><br><span class=\"line\">c2=test() <span class=\"comment\">--c1,c2是建立在同一个函数，同一个局部变量的不同实例上面的两个不同的闭包</span></span><br><span class=\"line\">          <span class=\"comment\">--闭包中的upvalue各自独立，调用一次test（）就会产生一个新的闭包</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(c1()) <span class=\"comment\">--&gt;1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(c1()) <span class=\"comment\">--&gt;2//重复调用时每一个调用都会记住上一次调用后的值，就是说i=1了已经</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(c2())    <span class=\"comment\">--&gt;1//闭包不同所以upvalue不同    </span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(c2()) <span class=\"comment\">--&gt;2</span></span><br></pre></td></tr></table></figure></p>\n<p>lua怎么实现面向对象<br><a href=\"http://www.lua.org/pil/16.html\" target=\"_blank\" rel=\"noopener\">lua作者的方法</a><br>object：用table做<br>    table后边也可以用冒号（是个语法糖，省了传self/this<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.deposit(a,100) == a:deposit(100)</span><br></pre></td></tr></table></figure></p>\n<pre><code>）  \n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account:withdraw</span> <span class=\"params\">(v)</span></span></span><br><span class=\"line\">    self.balance = self.balance - v</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n</code></pre><p>class：setmetatable<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setmetatable</span>(a, &#123;<span class=\"built_in\">__index</span> = b&#125;) <span class=\"comment\">--b是object a的class</span></span><br></pre></td></tr></table></figure></p>\n<p>实现继承和重载<br><a href=\"https://blog.codingnow.com/2006/06/oo_lua.html\" target=\"_blank\" rel=\"noopener\">风云的方法</a><br>只定义一个class函数<br>table <a href=\"https://www.cnblogs.com/msxh/p/8469340.html\" target=\"_blank\" rel=\"noopener\">参考资料</a>  </p>\n<blockquote>\n<blockquote>\n<p>算法：最长公共子字符串（动态规划）<br>状态转移方程$dp[i,j] = dp[i+1,j+1] + 1$ 用滚动数组可以省内存，优化</p>\n<p>算法：n叉树子节点值的和最大，规则不能同时取相邻的节点  </p>\n<p>渲染管线  </p>\n<ol>\n<li>Input Assembler Stage<br>这个阶段的主要目的是根据用户提供的顶点及索引信息，构建多边形，主要有点、线段、三角形。给定顶点和索引，构建多边形的方法取决于所使用的基本图元的拓扑类型（Primitive Topology）。</li>\n</ol>\n</blockquote>\n</blockquote>\n<ol>\n<li><p>Vertex Shader Stage<br>这是一个完全可编程的阶段，即完全由程序员自己来实现。该阶段的核心为模型顶点的各种空间变化；<br>用户指定的所有顶点都是基于模型空间的，在Vertex Shader阶段，每个顶点要依次经历所有这些空间，最终转换为屏幕上对应的二维坐标，不同空间之间的切换称为“空间变换”，实现空间变换的基本工作即矩阵。</p>\n</li>\n<li><p>Hull Shader Stage、Tessellation Stage、Domain Shader Stage<br>这三个阶段其实共属于Tessellation Stage，即曲面细分阶段，可选阶段。这个是D3D11中刚加入的一个高级特性，主要用于如LOD（Level of Detail）技术中。</p>\n</li>\n<li><p>Geometry Shader Stage<br>这个也是D3D11中加入的新特性，为可选阶段。在这个阶段中，输入为一个完整的多边形，点、线段或三角形。这个阶段直接对输入的多边形进行操作，可以把其消灭，不再往下一个阶段传输；也可以衍生出新的多边形出来。总之，该阶段操作的对象是完整的多边形，相比于顶点着色阶段，其操作的对象是单个的顶点。</p>\n</li>\n<li><p>Rasterizer Stage<br>这个阶段属于不可编程阶段，即完全由硬件实现，主要包括：</p>\n<ol>\n<li>视口变换</li>\n<li>隐藏面消除（Backface Culling）</li>\n<li>顶点属性的插值计算<br>说白了就是，三维空间的物体，放到二维屏幕上</li>\n</ol>\n</li>\n<li><p>Pixel Shader Stage（fragment shader片元着色器）<br>这个阶段也是完全可编程的一个阶段，也是跟顶点着色器阶段一样十分重要的阶段。因为在D3D11中，顶点着色器和像素着色器是程序员实现的两个最基本的阶段。<br>像素着色器，从名字上也很容易看出，是在像素级别上进行的计算。对于三维空间中投影到屏幕上的每一个多边形，针对其在屏幕上所覆盖的每一个像素，逐个进行像素着色计算。这一阶段接受的数据是经过插值计算后的顶点属性。输出的是颜色值，以提供给下一阶段处理。<br>像素着色器给程序员提供了相当多的灵活性和自由度，通过各种不同的算法来计算片段颜色以实现各种特效。</p>\n</li>\n<li><p>Output Merger Stage<br>这个阶段即输出片段的混合阶段。该阶段不可编程，但是高度可调节。程序员可以灵活地调整管线的状态来实现不同的特效。比如针对深度缓冲区、模板缓冲区，混合等可以有各种不同的状态。利用它们来实现各种特效后面也有特别详细的介绍。</p>\n</li>\n</ol>\n<p><strong>二面：</strong><br>实习经历相关  </p>\n<p>游戏框架、设计模式  </p>\n<p>值类型与引用类型 引用类型创建慢的原因，具体到内存  </p>\n<p>博客上的文章 提了问题  </p>\n<p>手写二分查找  </p>\n<p>斐波那契数列递归与非递归写法 怎么优化  </p>\n<p>有什么要问的  </p>\n<h2 id=\"面经——牛客\"><a href=\"#面经——牛客\" class=\"headerlink\" title=\"面经——牛客\"></a>面经——牛客</h2><h3 id=\"游戏研发\"><a href=\"#游戏研发\" class=\"headerlink\" title=\"游戏研发\"></a>游戏研发</h3><p><a href=\"https://www.nowcoder.com/discuss/386400\" target=\"_blank\" rel=\"noopener\">字节1</a>  </p>\n<p><a href=\"https://www.nowcoder.com/discuss/388667\" target=\"_blank\" rel=\"noopener\">字节2</a><br>介绍const，const修饰成员函数放哪儿？<br>修饰变量，说明该变量不可以被改变；<br>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；<br>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；<br>修饰成员函数（放在最后），说明该成员函数内不能修改成员变量（修饰的实际上是this，this是成员函数的调用对象）。<br>const int<em> p是p这个指针指向的值是个常量；<br>int</em> const p是p这个指针是个常量，但是*p何以变；  </p>\n<p>vector内存？<a href=\"http://c.biancheng.net/view/7397.html\" target=\"_blank\" rel=\"noopener\">如何避免vector扩容</a>？<br>vector对象在栈上，内容在堆上； reserve(n)强制容量为n  </p>\n<p>函数可以返回引用吗？<br>可以，函数返回值时会产生一个临时变量作为函数返回值的副本，返回引用直接返回内存  </p>\n<p>如何进行字符串拷贝？<br>strcpy <code>char   *strcpy(char   *dest,char   *src);</code><br>功能：把src所指由NULL结束的字符串复制到dest所指的数组中。<br>说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。  </p>\n<p>进程和线程？<br>进程包含线程，一个线程挂了整个进程挂，进程与进程之间不影响，进程是资源分配的最小单位，线程是资源调度的最小单位  </p>\n<p>多线程同步？如何避免两个线程争一个资源？<br>互斥锁和信号量  </p>\n<p><a href=\"https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html\" target=\"_blank\" rel=\"noopener\">TCP UDP</a>？<br>传输层协议，tcp可靠，有链接，upd延迟低，无连接  </p>\n<p>TCP四次挥手？（我说了个四次握手 感觉面试官楞了一下）<br>断开连接，四次挥手，全双工 两次FIN（关闭连接）两次ACK（响应）  </p>\n<p>Unity如何改变一个物体的位置 旋转？  </p>\n<p>Unity本地坐标和世界坐标？  </p>\n<p>Unity调整旋转需要传什么参数？参数在数学上叫做什么？（我潜意识说的欧拉角 看他点了点头）还能怎么修改？<br><a href=\"https://blog.csdn.net/candycat1992/article/details/41254799\" target=\"_blank\" rel=\"noopener\">四元数</a>：可以跟欧拉角互相转换，四维空间向量  </p>\n<p>了解图形学？（说只知道一点渲染管线就没问）  </p>\n<p>如何使用协程？协程和线程区别？<br>协程 IEnumerator startcoroutine<br>区别在于所有协程在一个线程内完成，是比线程更轻量的异步方法，在程序层面，而线程和进程在操作系统层面  </p>\n<p>C#拆装箱<br>装拆箱其实就是值类型和引用类型两者之间的类型转换操作，引用类型（object）都是在栈上放个地址，地址指向堆上的内存<br>装箱：值类型到引用类型（int-&gt;object）隐式转换<br>拆箱：反之，显式  </p>\n<p><a href=\"https://www.nowcoder.com/discuss/366357\" target=\"_blank\" rel=\"noopener\">字节3</a>  </p>\n<p><a href=\"https://www.nowcoder.com/discuss/259699\" target=\"_blank\" rel=\"noopener\">网易1</a>  </p>\n<p><a href=\"https://www.nowcoder.com/discuss/405621\" target=\"_blank\" rel=\"noopener\">天美，字节创新业务，雷火</a></p>\n<p><a href=\"https://www.nowcoder.com/discuss/384810\" target=\"_blank\" rel=\"noopener\">字节，雷火，b站</a></p>\n<p><a href=\"https://www.nowcoder.com/discuss/233959\" target=\"_blank\" rel=\"noopener\">字节引擎</a>  </p>\n<p><a href=\"https://www.nowcoder.com/discuss/390823\" target=\"_blank\" rel=\"noopener\">字节游戏测试</a><br>自我介绍<br>tcp与udp的区别<br>tcp是面向连接的，提供可靠的服务，保证数据完整性、没有重复、按顺序到达，udp无连接延迟低</p>\n<p><a href=\"https://blog.csdn.net/xiaoming100001/article/details/81109617\" target=\"_blank\" rel=\"noopener\">http与https的区别，https的劣势</a><br>前者明文传输，后者可进行加密传输、身份认证<br>后者降低了用户的访问速度，加重服务端压力；ca证书年费花销  </p>\n<p>进程与线程的区别<br>资源分配最小单位和资源调度最小单位，线程挂整个进程挂，进程挂对其他的没影响；线程间通讯代价小  </p>\n<p>多态，gc<br>C++在语言层面是没有gc的，但是可以通过智能指针实现；C#有</p>\n<p>set与hashset的区别  </p>\n<p>map与hashmap的区别  </p>\n<p>快排的原理  </p>\n<p>归并的原理  </p>\n<p>多线程  </p>\n<p>Linux的shell编程  </p>\n<p>hashmap的查找，删除，添加的时间复杂度  </p>\n<p>算法题：一个数组中有正数有负数（没有0），请将它排成正负相间的数组（多余的全部放后面），时间复杂度不超过O（n）;</p>\n<p><a href=\"https://www.nowcoder.com/discuss/241040\" target=\"_blank\" rel=\"noopener\">网易游戏后端</a><br>8.20 一面 1h</p>\n<p>1.介绍实习和项目</p>\n<p>2.static变量的作用？你能想到的所有的都讲出来</p>\n<p>3.a文件里面定义一个static b文件include a  c文件也include a 编译链接有什么问题？<br>会导致每个文件都有一个专属的static变量  </p>\n<p>4.a文件定义了一个static函数，b文件想用这个函数 该怎么做？你能想到几种方法？<br>套在一个普通函数里  </p>\n<p>5.C++面向对象三大特性？虚表你怎样理解？<br>封装继承多态，包含虚函数的类对象最开始会有个虚表指针，目的是父类指针指向子类对象的时候找到正确的方法进行调用</p>\n<p>6.<a href=\"https://www.cnblogs.com/zzdbullet/p/10563075.html\" target=\"_blank\" rel=\"noopener\">如何用C实现C++这三大特性？</a><br>struct做数据结构，函数的话传一个struct类型指针进去做this<br>继承就在struct里放父类一个对象<br>多态需要自己写个struct作为虚表，放到父类的struct中</p>\n<p>7.tcp三握四挥</p>\n<p>8.linux进程管理，介绍一下过程</p>\n<p>二面是两个人一起面的，难度的话感觉还好 等三面了~</p>\n<p>8.30 二面 50min</p>\n<p>1.介绍实习和项目</p>\n<p>2.linux内存管理，虚拟内存机制</p>\n<p>3.lock-free的理解？cas为什么能够原子性？</p>\n<p>4.如果很多个线程 都在并发cas 但是一直不成功，怎么办？（这个我没明白他的意思</p>\n<p>5.内存屏障怎么理解？</p>\n<p>6.互斥锁和自旋锁的区别？</p>\n<p>7.互斥锁的底层原理？它不是busy-loop如何通知线程</p>\n<p>8.自旋锁什么时候用？和cas有什么区别？</p>\n<p>9.cas实现自旋锁</p>\n<p>10.timewait状态</p>\n<p>11.tcp的拥塞控制？非常详细的介绍四个算法，包括门限值怎样修改，什么时候触发快重传等这些</p>\n<p>12.智力题 在数轴上有n个点，从中找一个点，使得该点到其他所有点的距离之和最短？并证明</p>\n<p>13.查看一块共享内存被哪些进程持有，用什么命令？查看一个进程持有了哪些共享内存呢？</p>\n<h3 id=\"C-后端\"><a href=\"#C-后端\" class=\"headerlink\" title=\"C++后端\"></a>C++后端</h3><p><a href=\"https://www.nowcoder.com/discuss/399967\" target=\"_blank\" rel=\"noopener\">腾讯字节后台开发</a>  </p>\n<p><a href=\"https://www.nowcoder.com/discuss/415859\" target=\"_blank\" rel=\"noopener\">字节后端</a>  </p>\n<p>项目为什么选用flask这个框架，对这个框架了解多少，有哪些并发模型。<br>生产者消费者模型怎么实现的。<br>中间有个阻塞队列作为“仓库”<br>共享内存的原理和实现。<br><a href=\"https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78591330\" target=\"_blank\" rel=\"noopener\">进程间如何同步。</a><br>临界区，互斥量，信号量，事件</p>\n<p>负载均衡的算法你了解哪些？项目中的负载均衡是怎么实现的。<br>一致性哈希有了解过吗？<br>主键索引是什么，B+树有什么好处，主键索引和普通索引有什么区别。<br>查询慢怎么优化。<br>父子进程间共享哪些资源。<br>多线程之间共享哪些资源。<br>TCP有哪些机制保证可靠传输。<br>接收方，窗口缓存满了会怎么样，怎么知道又有空间了，通知发送的包再丢了怎么办。<br>思路题：20000个高考生，分布0-750的成绩，内存足够大，怎么排序最快。<br>代码题：aabbcsdaddabsds一个字符串，删除所有的ab。注意：aabb-&gt;ab-&gt;null。<br>二面<br>项目介绍。<br>FFmpeg介绍一下。<br>项目的进展现在怎么样？遇到了哪些问题，系统稳定性怎么优化。<br>负载均衡怎么做的？怎么判断服务忙不忙。<br>代码题：单链表判断是否有环？若有环如何判断环的入口。<br>死锁的概念，避免死锁的具体方法。<br>缓存机制有了解吗？缓存的替换策略有哪些，说一下。<br>思考题：如何判断恶意刷接口的情况？记录了10T的请求记录，找出前100个高频访问用户。  </p>\n<p><a href=\"https://www.jianshu.com/p/735a3d4789fc\" target=\"_blank\" rel=\"noopener\">一致性哈希</a>和普通哈希有什么区别？<br>一致性哈希主要就是解决当机器减少或增加的时候，大面积的数据重新哈希的问题<br>都是多个数据库服务器的情况下，普通hash增加机器时要重新哈希  </p>\n<p>三面<br>项目介绍<br>你们数据交互主要是内存是吧，怎么设计的？<br>怎么监控内存有没有泄漏，服务挂了数据会丢吗？<br>服务之间的负载均衡是怎么做的？有哪些负载均衡算法？<br>CPU调度算法有哪些。<br>系统调用了解吗？有哪些类型。<br>http状态码有哪些。<br>http和https的区别是什么。<br>代码题一：判断一棵二叉树是不是以根节点为镜像的。<br>代码题二：实现一个队列的类，有取最大值的接口，且时间复杂度为O（1）。<br>家在哪儿？看你实验室做了很多算法的东西，你自己的就业方向是怎么打算的？<br>实习可以来北京吗？什么时候可以开始，能实习多久。  </p>\n<p><a href=\"https://www.nowcoder.com/discuss/415504\" target=\"_blank\" rel=\"noopener\">字节后端</a>  </p>\n<p>自我介绍+聊实习项目</p>\n<p>手撕代码：排课表，有依赖，拓扑排序</p>\n<p>数学题：两个人抛硬币，谁先抛到正面谁赢，公平吗？不公平的话先手胜率多少？怎么改规则变的公平？</p>\n<p>数据库为什么用B+树，为什么选择一个扁平的树而不是类似二叉树，B+树的度选取有什么讲究？最后一问没想出来，面试官说和磁盘的基本单位簇的大小有关。</p>\n<p>线程是不是越多越好？和CPU的核心数量是什么关系？线程状态？为什么会阻塞？<br>不是 占用内存，切换线程也浪费cpu资源；新建、就绪、运行、阻塞（回到就绪）、死亡</p>\n<p>还有一些基础记不起来了。。。</p>\n<p>五分钟后二面</p>\n<p>二面<br>聊项目</p>\n<p>Java并发，哪些集合线程安全，原理。。。这里问了很多，差不多线程有关的都过了一遍。。。</p>\n<p>输入url后的过程，浏览器是怎么渲染页面的？</p>\n<p>数据库为什么需要，联合索引，MVCC</p>\n<p>智力题：1000个人，10个试管，测新冠。讲了两个方法，一个是2进制表示，一个二分。</p>\n<p>代码：下一个字典序</p>\n<p>二面面了将近1个半，好多内容记不清楚了。。。</p>\n<p>4.20三面<br>自我介绍+项目</p>\n<p>单例各种写法</p>\n<p>双线程交替输出，要现场跑</p>\n<p>设计短网址（之前了解过，但答的不算好）</p>\n<p>平常咋学习</p>\n<h3 id=\"银行面经\"><a href=\"#银行面经\" class=\"headerlink\" title=\"银行面经\"></a>银行面经</h3><p><a href=\"https://www.nowcoder.com/discuss/426131\" target=\"_blank\" rel=\"noopener\">招商信用卡中心后台开发实习</a><br>作者：alanpeng<br>链接：<a href=\"https://www.nowcoder.com/discuss/426131?type=post&amp;order=time&amp;pos=&amp;page=0&amp;channel=&amp;source_id=1_post\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/discuss/426131?type=post&amp;order=time&amp;pos=&amp;page=0&amp;channel=&amp;source_id=1_post</a><br>来源：牛客网</p>\n<p>4.21 招行信用卡中心 一面 牛客视频 17:00 30min</p>\n<p>自我介绍<br>项目介绍，问项目<br>转java可以吗<br>进程间通信的方式<br>管道，信号量，共享内存，socket套接字，消息队列  </p>\n<p>线程同步的方式<br>临界区、信号量、事件、互斥量  </p>\n<p>死锁的四个条件<br>原因：1.系统资源不足 2.进程运行推进顺序不合适 3.资源分配不当<br>必要条件：1.互斥条件 2.请求与保持条件 3.不剥夺条件 4.循环等待条件  </p>\n<p><a href=\"https://www.cnblogs.com/gizing/p/10925286.html\" target=\"_blank\" rel=\"noopener\">内核线程与用户线程的区别</a><br>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的<br>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。  </p>\n<p>内核线程：线程切换由内核控制，切换的时候来，要从源用户态进入内核态，切换完毕要从内核态返回用户态；可以很好的利用百smp，即利用多核cpu。windows线程就是这样的。<br>用户级线程：用户态程序自己调度线度程切换问，不需要内核干涉，少了进出内核态的消耗，但不能很好的利用smp。答目前linux pthread大体是这么做的。  </p>\n<p><a href=\"https://blog.csdn.net/a314774167/article/details/81292981\" target=\"_blank\" rel=\"noopener\">线程的具体执行过程</a><br>新建-&gt;就绪-&gt;运行-&gt;阻塞（等待阻塞、同步阻塞、其他阻塞）-&gt;死亡  </p>\n<p><a href=\"https://blog.csdn.net/Ciellee/article/details/88783635\" target=\"_blank\" rel=\"noopener\">cpu调度算法</a><br>先来先服务调度（First Come First Serve）、短作业优先调度 （Short Job First）、响应比高者优先调度算法、优先数调度算法、循环轮转调度法（Round-Robin）  </p>\n<p><a href=\"https://blog.csdn.net/u011028345/article/details/73351070\" target=\"_blank\" rel=\"noopener\">线程sleep和wait方法作用和区别</a><br>是否占用cpu，sleep是占着cpu睡觉</p>\n<p>页面置换算法、LRU的底层实现（哈希表和双向链表）<br>内存管理的算法。</p>\n<p>TCP三次握手过程<br>长连接的保活机制、心跳包<br>怎么处理已经失效的连接<br>http的几种请求方式、GET/POST/PUT的区别<br>开放题：12306为什么不买很多服务器，但是抢票的时候还是不卡？（扯CAP，最后面试官说其实不买很多服务器的原因是一年抢票也就那么几次，考虑投入使用比）<br>高可用性的秒杀系统是怎么样的、使用情景（CAP舍弃C）<br>还投了哪些公司？拿到了哪些offer？怎么看互联网和银行、怎么选择？<br>反问<br>4.24 招行信用卡中心 二面 qq视频 11:00 30min</p>\n<p>自我介绍<br>项目介绍、问项目<br>TCP三次握手四次挥手过程<br>最大堆、创建过程、堆排序<br>文件系统的索引用的什么数据结构<br>讲一下B+树，为什么效率高，为什么不用哈希表<br>java的(…)你知道吗（不知道）<br>日常生活问题<br>当班长怎么组织活动、具体步骤、有问题怎么解决<br>语言选择、城市选择<br>反问</p>\n<h3 id=\"其他研发\"><a href=\"#其他研发\" class=\"headerlink\" title=\"其他研发\"></a>其他研发</h3><p><a href=\"https://www.nowcoder.com/discuss/183215\" target=\"_blank\" rel=\"noopener\">趋势科技广联达后台</a>  </p>\n<ol>\n<li><p>笔试题第二题思路</p>\n</li>\n<li><p>c 面向对象说一下<br>封装：数据和逻辑绑定；继承：对象产生父子关系，共用属性和方法；多态，静态多态（相同函数不同的参数）和动态多态（虚函数）</p>\n</li>\n<li><p>虚函数怎么实现的<br>有虚函数的表会在最前边放个虚函数表，每个实例会根据虚函数表调用正确的方法</p>\n</li>\n<li><p>如果不用指针和引用，子类赋值给父类，会不会引发动态绑定，为什么？<br>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；<br>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；<br>不会，因为对象的类型是确定，在<strong>编译期</strong>就确定了，指针或引用是在<strong>运行期</strong>根据他们绑定的具体对象确定  </p>\n</li>\n<li><p>vector底层工作原理<br>数组，每次容量到上线就翻倍增加（开辟新空间再复制）  </p>\n</li>\n<li><p>讲项目</p>\n</li>\n<li><p>讲讲最小二乘<br>它的主要思想就是选择未知参数，使得理论值与观测值之差的平方和达到最小  </p>\n</li>\n<li><p>为什么采用最小二乘法而不用你一开始说的三次样条</p>\n</li>\n<li><p>近处用一次函数拟合，远处用高次函数拟合，你怎么判决这个边界的</p>\n</li>\n<li><p>算法了解哪些</p>\n</li>\n<li><p>动态规划和贪心算法有啥区别，分别举个栗子</p>\n</li>\n<li><p>贪心算法有什么缺点</p>\n</li>\n<li><p>说一下机器学习吧</p>\n</li>\n<li><p>数据结构了解哪些</p>\n</li>\n<li><p>树和图有啥区别<br>能否成环，树有个根节点</p>\n</li>\n<li><p>什么地方会用到树</p>\n</li>\n</ol>\n<p><a href=\"https://www.nowcoder.com/discuss/267138\" target=\"_blank\" rel=\"noopener\">广联达远程面试</a>  </p>\n<ol>\n<li><p>自我介绍，重点介绍下项目</p>\n</li>\n<li><p>详细讲解项目是怎么实现的？（口才不好，描述半天……）</p>\n</li>\n<li><p>了解哪些常用数据结构？（数组、栈、树….）</p>\n</li>\n<li><p>那说一下B+树的原理，有什么优势？<br>单一节点存储更多元素，减少IO<br>所有查询都要找到叶子节点，查询稳定<br>所有叶子节点形成有序链表，方便范围查询</p>\n</li>\n<li><p>介绍一下索引<br>索引是对数据库表中一个或多个列（例如，employee 表的姓名 (name) 列）的值进行排序的结构。  </p>\n</li>\n<li><p>mysql为什么用B+树索引，不用其他索引？（忘了，只说了下hash索引的一个缺点）<br>B+-树特点是每层节点多，层数少，这样可以减少磁盘io次数，B+相比较B-因为数据都在叶子节点所以可以用链表将数据串起来，进行区间访问<br>AVL 数和红黑树基本都是存储在内存中才会使用的数据结构</p>\n</li>\n<li><p>情景题：实现一个栈，具有max方法，并且所有时间复杂度为O(1)</p>\n</li>\n<li>说一个常见的排序算法，除了冒泡排序（说了归并排序）</li>\n<li>那写一下归并排序的实现</li>\n<li>谈谈jvm（数据运行区、GC，这个了解比较多，扯得有点多，后来被打断了…）</li>\n<li>反问环节</li>\n</ol>\n<p><a href=\"https://www.nowcoder.com/discuss/427484\" target=\"_blank\" rel=\"noopener\">广联达C++实习</a><br>十分钟介绍项目<br>unity UI/游戏机制/shader/winapi+d3d/前端经历  </p>\n<p>除了C++还用过什么语言  </p>\n<p>指针与引用的区别<br>指针分配空间，引用只是别名<br>指针可以为空，引用不可以  </p>\n<p>面向对象的几个特点<br>封装，继承，多态  </p>\n<p><a href=\"https://www.cnblogs.com/evenleee/p/10382335.html\" target=\"_blank\" rel=\"noopener\">c++几种类型转化</a><br>const_cast：去const和volatile（所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取）<br>volatile关键字的作用：防止编译器优化，也就是上边的操作<br>static_cast：无条件转换，静态类型转换，无运行时类型检查<br>dynamic_cast：有条件转换，动态类型转换，运行时检查类型安全<br>reinterpret_cast：仅重新解释类型，但没有进行二进制的转换</p>\n<p>stl的几个模块<br>vector,map,set,unordered_map,unordered_set</p>\n<p>泛型编程了解么?<br>函数模板、类模板<br>STL就是很好的例子（pair等）</p>\n<p>说下你了解的排序算法  </p>\n<p>说下快排  </p>\n<p><a href=\"https://blog.csdn.net/liang3720/article/details/81700748\" target=\"_blank\" rel=\"noopener\">红黑树和AVL数树区别?  </a><br>平衡二叉搜索树：红黑树只要大致的平衡，高度平衡树（avl）高度差最大为1；<br>红黑树的复杂度O(logn)，是平衡二叉树，是二叉搜索树<br>b树是平衡多路查找树，b+树只在叶子节点存数据，其他都是索引，应用是文件系统  </p>\n<p>说下斐波那契数列<br>最近在看什么书  </p>\n<p><a href=\"https://www.nowcoder.com/discuss/230890\" target=\"_blank\" rel=\"noopener\">广联达开发</a><br>笔试：</p>\n<ol>\n<li>填空题 ，快速排序找到第k小的数，再递归</li>\n<li><p>A，B 2个数组，交换其中一个元素使2个数组和相等</p>\n</li>\n<li><p>回文数<br>先转到数组里，然后前后双指针遍历，比较。</p>\n</li>\n<li><p>给定圆的半径，求圆内包含的小正方形的最大的面积？（这题求解答）</p>\n</li>\n</ol>\n<p>一面下午4点  </p>\n<ol>\n<li>讲一讲一面第二题的思路，<br>答：暴力法O（n*n）<br>给你几分钟 ，能不能优化一下<br>答：2数组元素之和 /2为期待结果，在A里面哪个换掉能得到期望值，而B中正好有该元素 则输出该元素</li>\n<li>讲一讲第三题的思路</li>\n<li>给一个数组，找出3个数的和为N</li>\n<li>求a^b, a很长很大，b为2-9；<br>面试管诱导我到正确的思路上，先算a b，a，b很大，再想a*a；最后想a^b；</li>\n<li>朱元璋有很多后代，在一次会上，2个朱氏后代富商，想知道他们最近的共同祖先是谁？每个朱氏后代只能向上寻找其父亲是谁。答：转换为相交双链表求交点的问题</li>\n<li>讲一讲项目，项目中遇到的困难，怎么解决的<br>二面下午6点<br>自我介绍<br>人生中做的最对的事情是什么？映像深刻的挫折<br>未来几年的职业规划<br>未来几年的生活计划<br>对广联达了解多少</li>\n</ol>\n<p><a href=\"https://www.nowcoder.com/discuss/242943\" target=\"_blank\" rel=\"noopener\">广联达人工智能</a><br><a href=\"https://www.nowcoder.com/discuss/322691\" target=\"_blank\" rel=\"noopener\">面经合集</a></p>\n<p><a href=\"https://www.nowcoder.com/discuss/431828\" target=\"_blank\" rel=\"noopener\">腾讯测开</a><br>C++对象的大小是由哪些确定的<br>成员变量的大小，内存对齐，是否有虚函数，是否有虚继承</p>\n<p>C++虚函数和纯虚函数有什么不同<br>纯虚函数没有实现，不可以实例化</p>\n<p>C++的多态是怎么实现的<br>虚函数</p>\n<p>C++对象的内存布局<br>单继承、多继承、菱形继承（分是否虚继承）</p>\n<p>计算机网络<br>tcp为什么要三次握手和四次挥手<br>数据库<br>redis是什么<br>redis是用来做什么用的<br>redis跟mysql有什么不同<br>编程题<br>用Rand6实现Rand10<br>判断链表是否有环，找出环的头部<br>经典赛马问题<br>二面 2020-05-26<br>编程题<br>后序遍历<br><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/\" target=\"_blank\" rel=\"noopener\">无递归后序遍历</a><br>C++<br>宏定义结构体<br>memcpy可能会出的锅<br>C++如何实现多态<br>虚表是如何实现的  </p>\n<p><a href=\"https://blog.csdn.net/qq_40840459/article/details/81268252\" target=\"_blank\" rel=\"noopener\">new/malloc</a>的内存分配在哪<br>malloc从堆上分配内存，new从自由存储区（是更高级更抽象的概念，一般由堆组成，程序可以通过重载new指定其他内存实现自由存储区）分配内存？？<br>“堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。”  </p>\n<p>malloc的原理是通过系统调用实现的（在linux下是通过sbrk()系统调用实现）  </p>\n<p>编译原理<br>函数调用的过程<br>数据库<br>mysql索引<br>b+tree<br>计算机网络<br>time_close是什么状态</p>\n<p><a href=\"https://www.nowcoder.com/discuss/388960\" target=\"_blank\" rel=\"noopener\">腾讯测开实习</a><br>字母压缩  </p>\n<p>最小公倍数 = m*n/gcd(m,n)<br>最大公约数（gcd）: gcd(m,n) = gcd(n,m%n)</p>\n<p>vivo提前批后端<br>tcp四次挥手的time_wait等的是2msl（MSL是Maximum Segment Lifetime）  </p>\n<p>几十g的文件，字符串的出现次数  </p>\n<p>预防内存泄漏的方法，如何检测内存泄漏  </p>\n<p>http的get post等方法的细节  </p>\n<p>gdb调试工具  </p>\n<p>unique_ptr怎么声明  </p>\n<p>生产者消费者模型，怎么实际线程结构  </p>\n<p>两个链表求交点<br>方法一：哈希表存一个，遍历一个；方法二，快慢指针找相等  </p>\n<p>unordered_map具体用的什么解决冲突的<br>链地址法  </p>\n<p>vivohr面：  </p>\n<p>为什么想做这个职位  </p>\n<p>你认为这个职位需要哪些能力  </p>\n<p>对于求职公司看重哪些因素  </p>\n<p>独生子，父母工作，女朋友  </p>\n<p>工作城市  </p>\n<p>对该公司了解多少  </p>\n<p>提问</p>\n<p><a href=\"https://www.nowcoder.com/discuss/402956\" target=\"_blank\" rel=\"noopener\">游戏引擎面经</a><br>C++：<br>1.new和malloc区别：new/delete会调用构造和析构函数，是C++的关键字；malloc和free是c的库函数  </p>\n<p>2.STL中map的实现原理，怎么解决hash冲突<br>map底层是红黑树，unordered_map是哈希表，解决冲突的方法是链地址法  </p>\n<p>3.STL迭代器失效的情况  </p>\n<ul>\n<li>由于插入元素，使得容器元素整体“迁移”导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效。</li>\n<li>由于删除元素使得某些元素次序发生变化使得原本指向某元素的迭代器不再指向希望指向的元素。</li>\n</ul>\n<p>4.右值引用的作用？std::move怎么实现的？<br>延长右值的生存时间，避免不必要的拷贝；move底层就是一个static_cast类型转换  </p>\n<p>5.三个智能指针说一下，weak_ptr如何判断是否失效？sizeof(shared_ptr)多少？<br>Unique，share，weak<br>weak_ptr是否失效三种方法：1.expired()方法返回true；2.use_count()返回0；3.weak_ptr转化为shared_ptr看是否有bad_weak_ptr exception<br>64位机器是16，32位是8，也就是两个指针的大小，shared_ptr管理的普通指针所指向的对象必须为new出来的  </p>\n<p>6.如何将C++类设置为不可继承<br>简单的：将构造析构函数设为私有，然后提供静态方法构造和析构<br><a href=\"https://www.cnblogs.com/wxquare/p/7280025.html\" target=\"_blank\" rel=\"noopener\">最佳的</a>：写个基类，构造析构私有，模板类型是友元；不可继承的类<strong>虚继承</strong>这个基类；其他类便不可继承该类  </p>\n<p>7.能否将构造函数设为虚函数<br>不可</p>\n<p>8.继承下虚表的变化情况？<br>数组一样的线性结构，按照基类的顺序，子类有就覆盖掉  </p>\n<p>9.sizeof空结构体<br>1</p>\n<p>10.register变量可以取地址吗？<br>可以</p>\n<p>11.指针和引用的区别<br>分配内存/只是别名；可以为空/必须初始化；可以任意改变/初始化后不能改变指向地址</p>\n<p>12.深拷贝和浅拷贝<br>复制出新空间/只是拿引用  </p>\n<p>13.函数如何返回多个值（引用或者std::pair,std::tuple)<br>14.C++  UB说几个<br>未定义行为：除零，访问越界，访问空指针，未初始化</p>\n<p>15.带有虚继承的子类内存分布<br>先放自己的，再放基类的属性，最开始有vbptr，存着成员变量的偏移量，用来找到公共基类的成员变量  </p>\n<p>16.C99变长数组是堆还是栈实现的？<br>变长数组分配在栈中</p>\n<p>操作系统&amp;&amp;计算机网络&amp;&amp;多线程:<br>1.线程和进程的区别<br>2.多发射了解吗  </p>\n<p>3.C++中多线程库实现PV操作用什么？<br>4.TCP/IP三次握手，拥塞处理，滑动窗口<br>5.指令重排发生在编译阶段还是运行阶段？<br>6.智能指针是线程安全的吗？  </p>\n<p>(这部分感觉问的比较少，也没啥印象了，也都是基础了)</p>\n<p>Lua：<br>1.lua的<strong>index和</strong>newindex是什么？<br><strong>index是table进行索引时如果没有值，就调用</strong>index（可以是function可以是table，是table就在table里索引）；<br><strong>newindex是给table不存在索引进行赋值时，调用</strong>newindex（可以是function可以是table，如果是table就在这个table里赋值而不是原来外层的table）  </p>\n<p>2.lua的垃圾回收机制？是否存在互相引用现象？<br>语言级别的垃圾回收</p>\n<p>3.lua的元表怎么重载运算符？<br>用metatable</p>\n<p>4.lua怎么实现面向对象的机制？<br>table做object，元表实现继承</p>\n<p>5.lua的table底层是怎么存储的？<br>为了提高table的插入查找效率，在table的设计上，采用了array数组和hashtable(哈希表)两种数据的结合。</p>\n<p>6.lua对栈的操作比较麻烦，有优化方法吗？  </p>\n<p>7.lua和C++怎么绑定，有什么库？<br>8.lua的pairs和ipairs有什么区别?  </p>\n<ul>\n<li>pairs遍历表中全部key，value</li>\n<li>ipairs从下标为1开始遍历，然后下标累加1，如果某个下标元素不存在就终止遍历。这就导致如果下标不连续或者不是从1开始的表就会中断或者遍历不到元素。</li>\n</ul>\n<p>图形学&amp;&amp;管线:<br>1.渲染管线说一下，前向渲染&amp;&amp;延迟渲染<br>应用阶段，几何阶段，光栅化阶段<br>顶点数据，顶点着色器，曲面细分着色器，几何着色器，剪裁，屏幕映射，三角形设置，三角形遍历，片元着色器，逐片元操作，屏幕图像<br>前向渲染：检测深度，如果可见就计算光照获取颜色信息，更新帧缓冲（在颜色缓冲中进行混合）<br>延迟渲染（deferred shading）：检测深度，如果可见就将片元信息（法线，位置，材质信息）保存到G-Buffer，最后用g-buffer中的信息进行光照计算（g-buffer中混合）  </p>\n<p>2.延迟渲染的缺点，分块延迟渲染知道吗？<a href=\"https://www.sohu.com/a/125709754_468740\" target=\"_blank\" rel=\"noopener\">为什么延迟渲染带宽会那么大</a>?<br>延迟渲染主要的好处包括：<br>    1） 光照的开销与场景复杂度无关。<br>    2） Shader可以访问深度和其他像素信息。<br>    3） 每个象素对每个光源仅运行一次。也就是说，那些被遮挡的像素是不会被光照计算到的。<br>    4） 材质和光照的Shader完全分开。<br>延迟渲染还需要克服的主要障碍包括：<br>    1） 较高的显存带宽占用，因为gbuffer大<br>    2） G-buffer消耗较多的填充率，这个问题在游戏机上比较严重（像素填充率是指图形处理单元在每秒内所渲染的像素数量）<br>    3） 无硬件反锯齿的支持<br>    4） 对Alpha Blend支持较差  </p>\n<p><a href=\"https://gameinstitute.qq.com/community/detail/123220\" target=\"_blank\" rel=\"noopener\">TBDR分块延迟渲染</a>：带宽直接影响能耗，tile based rendering可以使用on-chip的memory，从而频繁访问从frame buffer到processor转移到了on-chip memory到processor  </p>\n<p>带宽占用高：因为G-Buffer的大小</p>\n<p>3.SSAO原理，除了SSAO还有哪些AO？<br>SSAO：屏幕环境光遮蔽，SSAO通过采样象素周围的信息，并进行简单的深度值对比来计算物体身上环境光照无法到达的范围，从而可以近似地表现出物体身上在环境光照下产生的轮廓阴影。  </p>\n<p><a href=\"https://www.zhihu.com/topic/20712088/intro\" target=\"_blank\" rel=\"noopener\">其他AO</a>  </p>\n<p>4.阴影贴图原理 PCF是什么 PCF的卷积核有什么？ CSM？<br><a href=\"http://blog.sina.com.cn/s/blog_6ba3e8e50101eh8x.html\" target=\"_blank\" rel=\"noopener\">阴影贴图</a>：光源位置，视点位置，还有物体高度可以计算出阴影的区域（阴影贴图）  </p>\n<p>PCF：软阴影算法，传统PCF的主要原理就是通过对周围像素取值进行高斯模糊，算定阴影像素点的权值，进行加权计算。  </p>\n<p><a href=\"https://blog.csdn.net/kuangfengwu/article/details/7946036?_t=t\" target=\"_blank\" rel=\"noopener\">CSM</a>：fft重新构建shadow map  </p>\n<p>卷积核有什么：</p>\n<p>5.PBR说一下，几何函数的意义,IBL主要是针对高光还是漫反射光？<br>几何函数：描述微平面自阴影和自遮挡的属性<br>IBL（image based lighting）<br><img src=\"/2019/09/16/校招学习笔记/几何函数.png\"></p>\n<p>6.Lod是什么？除了通过摄像机和物体距离判断Lod等级，还有什么方法？<br>level of detail；</p>\n<p>7.DrawCall的开销体现哪里，就是你调用DrawCall,具体干了什么？<br>准备工作（最费时）-&gt;cpu发起drawcall-&gt;进入command buffer-&gt;GPU<br>准备工作：硬盘收集网格信息（顶点位置，法线，顶点颜色）和纹理信息，加载到内存，然后加载到显存；然后设置渲染状态（是否透明，lightmode，单双面）<br>小drawcall合并到大drawcall中，不能让cpu准备工作太久，导致gpu空闲</p>\n<p>8.Bloom效果怎么实现？<br>提取较亮的区域，保存到一张渲染纹理中，利用高斯模糊进行处理，模拟光扩散，最后与原图混合  </p>\n<p>9.描边算法说一下？怎么不用后处理的卷积算子做描边？卡通化渲染呢？  </p>\n<ul>\n<li>视角方向和表面法线方向，一个pass出结果，效果不好</li>\n<li>两个pass，一个渲染背面面片，一个正常正面面片，快速有效，不适用立方体这样平整模型</li>\n<li>基于图像处理的轮廓线渲染（卷积等边缘检测方法）</li>\n<li>混合上述方法</li>\n</ul>\n<p>卡通化：1.渲染轮廓线；2.添加高光<br>素描风格：TAM（tonal art map）的例子，用到了mipmap，不是简单的降采样，而是控制笔触间隔，模拟素描效果  </p>\n<p>使用一个噪声纹理得到的法线贴图可以实现一个包含菲涅尔反射的水面效果  </p>\n<p>边缘检测算子：roberts，prewitt，sobel</p>\n<p>10.DX12大概是怎么减少开销的，说一下  </p>\n<p>11.<a href=\"https://www.zhihu.com/question/66993945\" target=\"_blank\" rel=\"noopener\">mipmap说一下</a>？它对带宽有什么影响？<br>多占用33%的内存，减少带宽使用，实际是增加缓存命中率，相当于离线计算好1个pixel覆盖多个texel的结果  </p>\n<p>12.压缩纹理有什么格式？<br>DXT RGBA32/16</p>\n<p>13.Unity外部调试工具有哪些？<br>内部profiler，framedebugger<br>安卓的有高通的adreon、英伟达的NVPerfHUD；IOS平台PowerVR有一个，XCode有一个  </p>\n<p>14.UE4渲染过程大概说一下，随便说几个Pass？  </p>\n<p>15.<a href=\"https://www.zhihu.com/question/366668747\" target=\"_blank\" rel=\"noopener\">为什么延迟渲染不能开MSAA</a>？<br><a href=\"https://blog.csdn.net/limanru14/article/details/104305514\" target=\"_blank\" rel=\"noopener\">MSAA</a>：把每个pixel(或者说fragment)细分为多个sub-pixel，比如分为4个、8个、16个甚至32个sub-pixel<br>延迟渲染不能开不是技术上不行，是采用msaa每张图x4 （四张图采样）负载过大</p>\n<p>16.有什么方法能降低一个场景中的渲染开销吗？说的越多越好<br>mipmap：多级纹理，典型空间换时间，应该是可以缓解带宽的因为用了压缩后的贴图；<br>合并drawcall：drawcall主要的性能瓶颈在cpu准备阶段（收集信息，设置渲染状态）；<br>early-z：将深度测试提前</p>\n<p>17.纹理数组知道吗？  </p>\n<p>18.实例化是怎么做的？说一下流程和好处  </p>\n<p>19.说一下常见的<a href=\"https://www.jianshu.com/p/0a7a018c5539\" target=\"_blank\" rel=\"noopener\">遮挡剔除算法</a>？  </p>\n<ul>\n<li>hidden line removal<ul>\n<li>raycasting</li>\n<li>画家算法（从后往前画）</li>\n<li>warnock算法：递归细分</li>\n<li>bsp tree二维空间分割树</li>\n<li>z-buffer</li>\n</ul>\n</li>\n<li>culling<ul>\n<li>portal</li>\n<li>视锥体剔除：如果某物体全部顶点都在视锥外面，则不显示</li>\n<li>背面剔除：通过每个面的法线来判断是正面还是背面</li>\n</ul>\n</li>\n</ul>\n<p>20.纹理在移动设备上存储在哪里？<br>21.全局光照能说一下吗？SH也说一下?<br><a href=\"https://blog.csdn.net/leonwei/article/details/78269765\" target=\"_blank\" rel=\"noopener\">球谐光照</a>的优点是运行时的计算量与光源的数量无关，如果参数足够却可以较好的模拟实时的光照结果。球面函数的也有例如傅里叶展开一样的东西，叫做勒让德多项式（Legendre Polynomials），</p>\n<p>22.如果把近处平面去掉了会怎么样<br>视锥体剔除嘛，进平面去掉物体就可以贴到镜头前，近平面远就会提前看到剔除</p>\n<p>23.OpenGL的VAO和VBO<br>24.GBuffer一般里面有什么，GBuffer要不要存储position信息，如果不存储，怎么用深度信息进行推导<br>25.卷积知道吗？说一下，模糊呢，为什么需要模糊？<br>卷积核遍历图像像素进行计算得到新图像，根据卷积核不同作用不同，例如可以实现提取轮廓线的工作，我的理解是做特征提取。模糊可以实现bloom这种效果，具体来说选高光部分组成一张纹理，使用模糊处理后在于原图合并  </p>\n<p>26.次表面反射知道吗？<br>sss就是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程。  </p>\n<p>27.透明度测试和深度测试的关系？<br>透明度测试是透明度小于一个阈值就不显示，</p>\n<p>28.法线贴图说一下，切线空间呢？<br>法线纹理和高度纹理都属于bump map</p>\n<p>29.移动设备怎么减少DrawCall Overload?<br>early-z，不透明物体从前往后画</p>\n<p>30.各向异性在光照模型中如何实现？<br>各向异性 (anisotropy ) 与 均向性 相反，是指在不同方向具有不同行为的性质，也就是其行为与方向有关。应用场景例如头发，晶体，这类材质不均匀，原子排列周期疏密不相同的物质<br>Bank BRDF 属于经验模型，由于其计算简单，且效果良好，所以该模型在各向异性光照效果的模拟方面非常有用  </p>\n<p>各向异性滤波？：比如一个走廊，视点消失处的像素采样会变模糊，各向异性滤波可以使其便清楚  </p>\n<p>31.opengl中顶点数据被送入顶点缓冲区时api做了什么？<br>32.phong和billn-phong区别是什么？<br>blinn不需要计算反射角度，取而代之的是视角与入射角度的均值  </p>\n<p>33.ray marching 知道吗？<br>34.opengl和dx有什么数学上的差别？<br>坐标系零点</p>\n<p>35.Alpha Blend和Alpha Test在性能上有什么不同？<br>透明度测试没通过的就不渲染了，透明度混合的话需要都渲染然后进行叠加</p>\n<p>36.光源剔除怎么做？<br>？？</p>\n<p>37.遮挡剔除怎么做？知道Mesh Shader吗？<br>unity有个occlusion culling window可以对static的物体烘焙，不进行渲染；<br>nVidia推出的mesh shader</p>\n<p>38.CS知道吗？为什么有些pass放到cs而不是ps做？</p>\n<p>游戏数学&amp;&amp;算法：<br>1.点沿任意轴旋转的矩阵怎么推导<br>2.怎么判断一个物体是不是在你面前还是身后？<br>3.<a href=\"https://blog.codingnow.com/2006/07/astar.html\" target=\"_blank\" rel=\"noopener\">A*算法</a>说一下，它的最大缺点是什么？<br>该点到起点的距离，该点到终点的距离<br>仅仅是一个启发式搜索算法，最大的缺点就是，空间需求太大</p>\n<p>4.八叉树算法说一下，它用在哪里居多，物体运动了咋办？<br>常用于离散化空间，数据划分存储，数据查找等。<br>八叉树四叉树一样的，要是找相交图元的话，比如说范围攻击，可以从根节点开始遍历，如果相交在跟子节点检测，直至叶子节点，这样可以省掉一部分比较次数  </p>\n<p>5.kd-tree和bsp说一下<br>k维树（每个节点为k维的二叉树，超平面把空间分成两部分），是特殊的二叉空间分割树</p>\n<p>6.推导View矩阵<br>7.<a href=\"https://www.cnblogs.com/graphics/archive/2010/08/09/1795348.html\" target=\"_blank\" rel=\"noopener\">如何判断射线和三角形相交</a><br>8.<a href=\"https://blog.csdn.net/u012419410/article/details/41911025\" target=\"_blank\" rel=\"noopener\">如何判断两个立方体是否相交(AABB包围盒相交问题)</a><br>9.如何判断点是在多边形里面还是外面？<br>10.如何判断三角形和三角形相交?<br>11.说一下点积和乘积的几何意义？<br>b在a上的投影；叉乘模是四边形面积，方向是垂直ab平面<br>12.矩阵左乘和右乘区别？<br>矩阵左乘变换矩阵是进行行变换；右乘是列变换</p>\n<p>游戏开发：<br>1.帧同步中的帧是什么意思？<br>操作，动作</p>\n<p>2.常见的设计模式说一下<br>3.Unity的awake,enable,start<br>4.UE4的垃圾回收怎么实现？不会？那说说反射吧<br>5.UE4蓝图和C++代码通信的几个方法？<br>6.ECS框架有什么好处？</p>\n<p><a href=\"https://www.nowcoder.com/discuss/438775?type=post&amp;order=time&amp;pos=&amp;page=1&amp;channel=666&amp;source_id=search_post\" target=\"_blank\" rel=\"noopener\">链接</a><br>1 腾讯-游戏客户端开发<br>一面<br>C++基础：<br>stl的vector和list的区别，增删分别的时间复杂度<br>vector底层数组，连续空间；list底层链表，离散空间；list善于增删O(1)，vector O(n)  </p>\n<p>虚函数机制<br>有虚函数的类会存在一个虚函数表，虚函数表的实际位置在静态存储区，每个实例化对象的最前边会有个虚表指针指向这个表，用父类指针指向一个子类实例来实现动态多态  </p>\n<p>C11的新特性<br>auto；三个智能指针；右值引用（延长右值寿命，移动语义一般是用在移动构造函数比如改进版的swap函数，避免使用拷贝构造函数；注意右值引用也是引用，函数不能返回局部变量的右值引用）</p>\n<p>计算机网络：<br>解释TCP3次握手  </p>\n<p>图形学：<br>速度过快/体积过小导致物理引擎检测不到碰撞，如何解决<br>自己来检测的话：记录前一帧的位置，从前一帧的位置向当前帧的位置发一条射线，用过射线是否碰撞来判断是否碰撞<br>完全依赖引擎的话：Unity的rigidbody有<a href=\"https://blog.csdn.net/cangod/article/details/100524270\" target=\"_blank\" rel=\"noopener\">collision detection</a>选项</p>\n<ul>\n<li>discrete：default</li>\n<li>continuous：防穿静态碰撞体 TOI（time of impact）算法，线性扫描所以无法检测旋转物体</li>\n<li>continuous dynamic：防穿静态和同为c的刚体</li>\n<li>continuous speculative：推测式（投机式）ccd，膨胀AABB碰撞盒，可能出现幽灵碰撞</li>\n</ul>\n<p>开放性问题：<br>如何优化内存，实际开发过程中用过什么优化内存的方法<br>mipmap关闭；模型/图片的write/read；内存池；</p>\n<p>如果有对象要频繁创建和删除，用什么减少开销。(对象池)<br>对象池的大小通常如何决定：太大占内存，太小没作用，结合数据分析来确定  </p>\n<p>二面<br>二面面试官给我发了一个腾讯文档，考8道C++基础题，涉及到C++自定义类的大小如何决定(默认大对齐)、右值引用、模板类、STL的iterator使用等等，在面试官纠正下我勉勉强强做出了7道，感觉还是蛮难的。题就不公开放了，有小伙伴需要的话私信我单独发吧。</p>\n<p>三面<br>三面给我印象不是很深，好像是问了问我简历里的项目，然后我叽里咕噜跟面试官说了一堆，说了啥我已经忘了，毕竟面试里说的那些高大上的话太羞耻了根本不敢回忆😂</p>\n<p>2 网易-游戏引擎研发<br>手撕代码：是否是合法括号串<br>手撕代码：最长合法括号串，上面一题的升级版，要求O(n)<br>这是网易一面的两道题，做完之后开始问问题，被面试官怼飞了。能感觉得出来网易那会已经不招人了，就纯粹面你面着玩，岗位相关的问题就没问几道，逮着我简历里不相关的经历狂怼，最后话都没让我说完就让我回去等消息了。</p>\n<p>3 字节-游戏引擎研发<br>一面</p>\n<p>C++基础：<br>几个stl容器的底层实现<br>右值引用和move构造<br>const、static关键字<br>C++里的lambda函数<br>指针和引用的区别</p>\n<p>软件工程：<br>介绍几个设计模式<br>C++里的面向对象</p>\n<p>图形学：<br>介绍渲染管线<br>解释纹理采样的两个模式<br>repeat，clamp</p>\n<p>手撕代码：前序遍历</p>\n<p>二面<br>C++基础：<br>解释C++的多态如何实现  </p>\n<p>解释类模板和模板类的区别<br>类模板经实例化后生成了3个类型分别为a,b,c的模板类</p>\n<p>右值引用、move语义</p>\n<p>图形学：<br>介绍顶点处理中涉及到的矩阵变换<br>旋转缩放，平移</p>\n<p>介绍一个光照渲染模型(我介绍的是冯氏光照)<br>介绍一个消除隐藏面的算法(我介绍的是Z缓存)<br>如何解决因为顶点过近和浮点数的精度不足带来的穿模问题  </p>\n<p>手撕代码：快排</p>\n<p>三面<br>开放性问题：<br>在特定场景如何选择stl容器，以什么为标准？你最近一个应用到这个容器的场景是什么？<br>在N*N棋盘地图上放一个圆形技能，检测影响到的玩家对象，用什么数据结构实现？<br>不关心顺序的数组如何实现O(1)的删除操作 </p>\n<p><strong>字节游戏引擎1/2面（2020.7提前批）</strong><br>AssetBundle是怎么在jit（虚拟机？）中加载prefab的：Unity的跨平台技术是通过一个Mono虚拟机实现的。而这个虚拟机更新太慢，不能很好地适应众多的平台。unity公司就自行研发了IL2cpp，把本来应该再mono的虚拟机上跑的中间代码转换成cpp代码，这样再把生成的cpp代码，利用c++的跨平台特性，在各个平台上通过对各平台都有良好优化的native c++编译器编译，以获得更高的效率和更好的兼容性。</p>\n<p>Unity项目中的<a href=\"https://blog.csdn.net/u012138730/article/details/81143413#2.Library%E6%96%87%E4%BB%B6%E5%A4%B9\" target=\"_blank\" rel=\"noopener\">Library文件夹</a>：此放的是程序集和库的缓存文件。 </p>\n<p>Unity的Inspector面板中查看GO属性是怎么实现的：反射，运行时获取属性并进行修改  </p>\n<p>接着inspector，undo和redo怎么实现：记录一个操作队列，怎么设计这个队列<br>我这边说了unity的scene文件在版本控制工具中看就是文本记录的属性，可以记录下修改的值，比如加或减一个数，撤销就是减或加回来<br>正解应该是<a href=\"https://www.jianshu.com/p/7747f574d53b\" target=\"_blank\" rel=\"noopener\">命令模式</a></p>\n<p>各向异性过滤算法：是用来过滤、处理当视角变化导致3D物体表面倾斜时造成的纹理错误；传统的双线性和三线性过滤技术都是指“Isotropy”（各向同性）的，其各方向上矢量值是一致的，就像正方形和正方体  </p>\n<p>图形学中渲染阴影的方法：我说了shadowmap，追问能想象到哪些地方会比较糙吗，有限的分辨率下看起来品质尽可能高，bloom和blur搞混了，bloom是泛光的效果，blur是模糊效果；抗锯齿是通用的方法，跟这个问题没有关系；他的意思是远的地方，或者说斜射的地方会一个光照贴图的像素对应一大片场景区域，怎么处理；  </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/116731971\" target=\"_blank\" rel=\"noopener\">Cascaded shadow map</a>：级联阴影贴图，将平截头体分成若干份，由近到远使用分辨率有高到低的shadow map  </p>\n<p>pbr理论，cook torrance光照模型的微表面理论：用来模拟不同材质的镜面反射效果；三部份组成——菲涅尔反射，微平面法线分布函数，几何项<br>phong光照的问题在于他不是能量守恒的<br>经验模型：Lambert、phong、blinn-phong</p>\n<p>抗锯齿，四倍或几倍细分的话显卡受得了吗：我说的是延迟渲染不能用aa就是不是因为技术上不行，就是因为显存遭不住  </p>\n<p>体渲染：雾，水体</p>\n<p>对于移动的物体如何计算光照：光照探针？球谐函数模拟全局光照  </p>\n<p><strong>3面负责人面</strong><br>shared_ptr实现：<br>引用计数增加的情况:<br>拷贝一个shared_ptr，其所指对象的引用计数会递增，如：</p>\n<ol>\n<li>用一个shared_ptr初始化另一个shared_ptr</li>\n<li>用一个shared_ptr给另一个shared_ptr赋值</li>\n<li>将shared_ptr作为参数传递给一个函数</li>\n<li>shared_ptr作为函数的返回值</li>\n</ol>\n<p>引用计数减少的情况:</p>\n<ol>\n<li>给shared_ptr赋予一个新值</li>\n<li>shared_ptr被销毁（如离开作用域）</li>\n</ol>\n<p>什么情况用vector什么情况用list；使用list的应用场景，怎么找到删除节点的位置（靠遍历吗？需要O(N)时间，），实现erase方法；boost中的signal或者C#中的delegate/event怎么实现的  </p>\n<p><strong>上海无双一面引擎</strong><br><a href=\"https://www.zhihu.com/question/36296104/answer/1398427077\" target=\"_blank\" rel=\"noopener\">为什么图形学中要用4*4的矩阵</a></p>\n<p><strong>字节TA</strong>  </p>\n<ol>\n<li><p>自我介绍</p>\n</li>\n<li><p>渲染管线的流程</p>\n</li>\n<li><p>用glsl语言写过完整的shader吗</p>\n</li>\n<li><p>三维向量位移、旋转、放缩的矩阵、三个的排序<br>缩放，旋转，位移</p>\n</li>\n<li><p><a href=\"https://baike.baidu.com/item/%E5%BC%82%E9%9D%A2%E7%9B%B4%E7%BA%BF%E7%9A%84%E8%B7%9D%E7%A6%BB/2074683?fr=aladdin\" target=\"_blank\" rel=\"noopener\">异面向量距离计算</a><br>求ab公共法向量，也就是公垂线的方向向量n，ab上任取AB点，求AB线段在向量n上的射影d</p>\n</li>\n<li><p>万向节死锁的解决方式、具体说一下原理<br>用xyz欧拉角表示才会万向节死锁，用四元数就不会了</p>\n</li>\n<li><p>高斯模糊的shader代码</p>\n</li>\n<li><p>卡通效果的shader代码</p>\n</li>\n<li><p>半兰伯特光照、phong高光、blin-phong高光shader代码</p>\n</li>\n<li><p>Alphablend为什么不能depth write、为什么要depth test<br>但对于半透明的 fragment，每一个都会影响最终的结果，需要从远至近地渲染。由于深度缓冲不能用于排序多个 fragment，所以只能用于保存最接近视点的不透明 fragment 深度，远于该深度的透明 fragment 不用渲染，所以仍需要深度测试（depth test）。</p>\n</li>\n<li><p>Renderqueue的作用<br>background 1000，geometry 2000，alphatest 2450，transparent 3000，overlay 4000</p>\n</li>\n<li><p>透明模型前后面冲突的解决方法<br>分两个pass，第一个开启深度写入，不输出颜色；第二个正常的透明度混合</p>\n</li>\n<li><p>模型放大的方法，方法越多越好</p>\n</li>\n<li><p>Z冲突的解决方法，方法越多越好<br>搜索z-fighting<br>第一点：当然，从这里公式里面，我们也能看到，想要让深度值更加精确，那么适当的见效近平面与远平面的绝对距离，也是可以做到的。当然在不影响渲染质量的前提下。</p>\n<p>第二点：根据物体距离视点的距离，在渲染的时候，进行一个计算，避免距离视点比较远的物体相距太近。</p>\n<p>第三点：可以使用OpenGL ES内部提供的API，多边形偏移，但是会造成性能的浪费，可结合CPU空间划分与LOD算法使用。</p>\n<p>第四点：提高深度缓冲区的精度，这样，其在深度缓冲区测试的时候会更加的准确。</p>\n</li>\n<li><p>锯齿的原因 抗锯齿的方法<br>纹理分辨率低于屏幕分辨率，aa的方法4x8x<br>msaa经典，英伟达txaa</p>\n</li>\n<li><p>Pbr材质需要什么要素、有没有做过</p>\n</li>\n<li><p>有没有用lua写过脚本，写过什么脚本</p>\n</li>\n<li><p>抖音视频;如果让用户写的字显示在屏幕上，说几个有意思的创意，越多越好。</p>\n</li>\n<li><p>抖音视频：如果能对用户的图片进行断裂处理，说几个有意思的创意，越多越好</p>\n</li>\n</ol>\n<h3 id=\"游戏客户端8-16开始\"><a href=\"#游戏客户端8-16开始\" class=\"headerlink\" title=\"游戏客户端8.16开始\"></a>游戏客户端8.16开始</h3><p><a href=\"https://www.nowcoder.com/discuss/476842\" target=\"_blank\" rel=\"noopener\">网易雷火</a>：<br>大小端首字节</p>\n<h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><ol>\n<li><p>游戏研发：本科有Unity课程，对建模（PBR模型制作）到游戏引擎，甚至是剧本策划都有一定的了解。<br>个人之前的实习经历都是偏前端，有尝试mirror（unet），skynet，这些服务器框架，还在逐步学习。<br>对游戏引擎，准确说是渲染引擎比较感兴趣，本科课程中完成了简单的webgl渲染引擎，现在在学DX12 win32API的渲染引擎开发。<br>因为实验室课题缘故，掌握了一些深度学习相关的技能，linux系统用过，conda，pytorch，AI+GAME是很好的方向。</p>\n</li>\n<li><p>后端研发：本科读的数字媒体技术，偏重于技术，同时也学习了ps，音视频剪辑，建模等一些课程。除了语言，还有oop这种基础课程，我大二下开始学习使用unity为主以C#作为脚本语言，游戏研发课程。游戏引擎开发，是做webgl的网页渲染引擎，白鹭实习。学习node react electron技术栈，做的工作还是比较简单的，然后选择读研，就是想多三年学点自己想学的东西。三维人体重建。跟本科时学的东西有关联。在做课题的同时也在回过头来看基础知识，查缺补漏，围绕着C/C++，更接近底层。这么做呢一方面是找工作需要，一方面也是为职业生涯考虑，我是希望可以做全栈工程师。<br>计网还有linux环境上的C++开发，没有经验是我的劣势，但是我认为我的学习能力还是可以的，不是说有多快，就是愿意深入了解它，学习的更透彻。</p>\n</li>\n<li><p>图形研发/引擎：遇到的困难<br>1 能用别人的轮子就别自己造； 2 确实是具体问题，但是可以找到解决问题的模板，主要是一些设计模式上的困难，比如如何在更好的使用组合而非继承，观察者模式（比如说一个怪物死掉了，一方面要给任务系统完成任务，一方面人物要加经验，一方面怪物自身的ragdoll要开始生效，C#中的委托） 3 也就是网上找不到答案，比如说写论文做实验用的开源项目，提issue，捋逻辑。<br>最近再跟着utube上的教程做d3d+winapi的渲染引擎</p>\n</li>\n</ol>\n<p>传统软件公司和互联网公司在企业文化，工作内容，工作状态上的差别，需要实际体会；实习是为了投资自己，学习知识；图形开发这个岗位，个人感兴趣，综合之前的学习经历，对画面渲染、几何结构、动画</p>\n<h3 id=\"提问环节\"><a href=\"#提问环节\" class=\"headerlink\" title=\"提问环节\"></a>提问环节</h3><p>团队规模？游戏类型？工作内容？主观上全栈好还是图形ta方向好还是客户端+AI还是做好客户端就行了更新速度已经很快了？其他问题有机会跟hr聊<br>测开能转开发吗？测开设计引擎开发的工作吗比如渲染性能、物理性能、画面表现测试，总的来说能学到引擎相关的知识吗？</p>\n<p>部门<br>加班情况<br>是否开展内部技术分享 频率</p>\n<p>ue项目还是unity项目<br>unity目前统治地位，近年开始会往ue倾斜同意吗</p>\n<h1 id=\"秋招记录\"><a href=\"#秋招记录\" class=\"headerlink\" title=\"秋招记录\"></a>秋招记录</h1><h2 id=\"提前批\"><a href=\"#提前批\" class=\"headerlink\" title=\"提前批\"></a>提前批</h2><p>vivo—软开后端—offer白菜<br>广联达—图形开发—offer九月谈<br>字节绿洲—引擎—三面负责人挂<br>字节飞书—客户端—一面挂<br>字节无双—引擎—一面挂<br>Unity—TA实习—面试挂<br>猿辅导—客户端—笔试挂  8.22还有一次笔试—未投<br>网易雷火—笔试完<br>完美—已投<br>网易有道—一面结束—部门差不考虑<br>快手—已投</p>\n<h2 id=\"正式批\"><a href=\"#正式批\" class=\"headerlink\" title=\"正式批\"></a>正式批</h2><p>农行—总行软开—已投<br>祖龙—等二面 面试官是程序五部 足球类型 万物觉醒 slg 有引擎中台<br>字节—游戏客户端—8.10已投—笔试完不好<br>腾讯魔方—游戏客户端—8.10已投8.23笔试<br>中行—五个志愿—已投<br>快手—游戏客户端—8.5已投<br>爱奇艺—游戏客户端—8.16已投<br>百度—c++—8.16已投<br>贝壳—ue4引擎开发—8.16已投要求dx11api<br>网易互娱—游戏引擎游戏研发—8.17已投<br>美团—测开—8.22笔试<br>小米—Unity—8.20已投</p>\n<p>中国</p>\n<h2 id=\"offers\"><a href=\"#offers\" class=\"headerlink\" title=\"offers\"></a>offers</h2><p>秋招：</p>\n<ul>\n<li>vivo软件工程师（后端）-深圳-白菜24-已拒  </li>\n<li>广联达图形开发-北京-往年29-等oc  </li>\n</ul>\n<h1 id=\"todolist\"><a href=\"#todolist\" class=\"headerlink\" title=\"todolist\"></a>todolist</h1><p>profiler使用<br>unity渲染线程 主线程 用户层面多线程以提升效率<br>编译优化<br>linux C++开发<br>哪些是在构造函数里初始化的<br>rmsl<br>渲染管线，矩阵运算的源码</p>\n<h1 id=\"企业列表\"><a href=\"#企业列表\" class=\"headerlink\" title=\"企业列表\"></a>企业列表</h1><p><a href=\"https://www.nowcoder.com/discuss/364482\" target=\"_blank\" rel=\"noopener\">资源链接</a></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>领域</th>\n<th>名称</th>\n<th>网址</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>监管机关</td>\n<td>中国人民银行</td>\n<td></td>\n<td>软件开发、信用卡中心</td>\n</tr>\n<tr>\n<td></td>\n<td>银监会</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>保监会</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>证监会</td>\n<td></td>\n</tr>\n<tr>\n<td>政策性银行</td>\n<td>国家开发银行</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>进出口银行</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中国农业发展银行</td>\n<td></td>\n</tr>\n<tr>\n<td>国有银行和商业银行</td>\n<td>中国银行</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中国农业银行</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中国工商银行</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中国建设银行</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中国邮政</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>招商银行</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>平安</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>浦发</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>广发</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中信</td>\n<td></td>\n</tr>\n<tr>\n<td>外资银行</td>\n<td>汇丰银行</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>渣打银行</td>\n<td></td>\n</tr>\n<tr>\n<td>金融结算，交易服务</td>\n<td>中国银联总部</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中国网联</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>银联商务</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>（上海、深圳）证券交易所</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中国人民银行清算中心</td>\n<td></td>\n</tr>\n<tr>\n<td>证券公司</td>\n<td>华泰联合证券</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>广发证券</td>\n<td></td>\n</tr>\n<tr>\n<td>电力</td>\n<td>国家电网</td>\n<td><a href=\"https://zhaopin.sgcc.com.cn/unitInfo.html?obj_id=00994041&amp;particulars=true\" target=\"_blank\" rel=\"noopener\">link</a></td>\n<td>提前批会很早 第一批在11月份 牛客为什么有人十月底就拿到offer了。。有考试大纲、刷题多长时间？</td>\n</tr>\n<tr>\n<td></td>\n<td>国家电网科学院（南瑞集团）</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>电网子公司</td>\n<td></td>\n</tr>\n<tr>\n<td>发电（四大集团）</td>\n<td>大唐集团科学院</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>华润集团</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>神华集团</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中国核电</td>\n<td></td>\n</tr>\n<tr>\n<td>医院</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>铁路，航空公司</td>\n<td>铁路局，中国铁道科学院，航空公司，</td>\n<td></td>\n</tr>\n<tr>\n<td>汽车</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>三大运营商及其通信公司</td>\n<td>联通软件研究院</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>中移互联网/中移在线</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>电信</td>\n<td></td>\n</tr>\n<tr>\n<td>外企/互联网公司</td>\n<td>Google</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>IBM</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>ORACLE</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>微软</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>红帽</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>万革始</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>SAP</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>intel</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>ThoughtWorks</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>三星</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>华为</td>\n<td></td>\n</tr>\n<tr>\n<td>一线</td>\n<td>百度</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>阿里</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>腾讯</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>字节</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>快手</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>…</td>\n<td></td>\n</tr>\n<tr>\n<td>二线</td>\n<td>去哪儿</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>携程</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>京东</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>微博</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>…</td>\n<td></td>\n</tr>\n<tr>\n<td>三线</td>\n<td>一个app撑一个公司</td>\n<td></td>\n</tr>\n<tr>\n<td>创业公司</td>\n<td>画饼</td>\n<td></td>\n</tr>\n<tr>\n<td>独角兽</td>\n<td>商汤</td>\n<td></td>\n</tr>\n<tr>\n<td>传统/制造业</td>\n<td>旷视科技</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>深信服</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>新华三等</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>浪潮集团</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>龙湖地产科技部</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>顺丰科技</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>大疆科技</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>格力电器</td>\n<td></td>\n</tr>\n<tr>\n<td>事业单位</td>\n<td>国家统计局</td>\n<td><a href=\"http://www.stats.gov.cn/zjtj/gjtjj/jgsz/\" target=\"_blank\" rel=\"noopener\">http://www.stats.gov.cn/zjtj/gjtjj/jgsz/</a></td>\n<td>考生在规定的报名时间内(自公告发布之日至4月10日)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>游戏公司：<br>字节、快手、畅游、祖龙、完美、光宇<br>外地：网易、腾讯、字节、米哈游、unity<br>没听说过的：<br>聚力维度：ai+unity+vr/ar 创业公司</p>\n","slug":"校招学习笔记","updated":"2020-08-20T04:34:58.206Z","comments":true,"link":"","permalink":"/2019/09/16/校招学习笔记/","excerpt":"","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"/tags/刷题/"}]},{"title":"CYOU学习笔记","date":"2019-07-08T14:26:11.000Z","path":"2019/07/08/CYOU工作笔记/","text":"您好, 请在这里输入密码.6825f6a083f85570bdec124205b42d562a608361c1e800b895aaf4234d0124e548220ff85bb01031d1226bbdbf6eb6e46970542b42bd080ec4eab74b2897d0b2af805d52b4fd12d3024339c3e764cebf9d885a8b108d08d5992f6a831350da5d04665ee3ed4068f43e078bbb9898123650281661b78a39471c81e624fc3e12ae30a5edfb65ee8c29044b00885f631f8967f35139599c7fc0f91e11f7d6d2b61fb079c1a335ebda8946e59f3b77dc26896dc4a5434d2eba0762cc60d0d6a2bd4d9950cf13fb92b4c4faa59cddefba4d5becde6ef1a9637ee978fd6afd1735a9d37de7ff16f28b04a88d6bc2f7409d47955cd04b7fa85d8133b8899106085ac143c631982fa596d4d7c7f44dbefbdbd07d6f2f58016377c37ed35cf0fde923f93a436446257283b0049b3562f223e494c60d705668dbbe11303acaa5d95c8ded301a9fb3429575cd5dd7abd02e2d31b7b67ede107f4bb7078539601159ea2cfb185557b1b5e051f5fd373db228bdaac404fb78c58c64fefc341253ced94ecc0cd470ae4c9c0636359692014185eddb4d45545e824f04bc1960855bc473127d8ab2fd9fb26fec64e385f283d4498eb6ee765e560e4ae3d5493314d9f99560deed82be7b277ea6d5afce40f2ccbd9f70c58193611e5a6bae3cbe918aba6e7866c0c274fd2985cbbdd6bee1e0dcaab206c2792ef5c4401d7b764d0c6daeafb46a2441ede8cc35508f95cf0f83e20e5d1f1ec5caa13b7b87c865f3b39649da160a39d646cd6777211871139a7de583cb743b5ca92e1937a67e31582761a9ab9f1924d29738cf2f405c4e487b0696e01862a22ee63f98234d8dc5b5181c0a4b355965b3bb201b3594bedc0c2c0584c068dc30ac17b87c2e5d918f1a4d29d4f8e4defa6004c0e66a1725516293117756a1c0a7644d51641d4c901c0d12f5f45825322e4aa25e034a3e37706d5b8ad9980b1f410936b436280e1d1cf4187d17e8a68ca6995c9375602ee2ccc4af012500787888bd2035263bdc7953466642c01ecf1adaaafdc289fa1b8853904c463df595dc2f93827e549927c18c4e528e261e515044eed320e0caa1bffadd50acb669a405ac5a5dd6ecd2cd7afb6eb311e269d8933c1431ea250ec00bd4734105ae13e9d3699d9e7a007660e7fbfdb2ff07e45aa5c185ed5d61cfc75f72957ba83029235e8bdb119a217161e39c0d814f0f14606c9b21de5b234d21eb5812c31ac03f93a86e9028e665a5748cd5d036dd99522870ffd812183eb7c3bc43c997e759d8400b02e073964dfcff2858dcc4fc85158b6a276bc2b37cdd581e30b14bccfa9eb9ce2a265eedcb960bc9ac3c29991a458d0b7896dbfdc1d4f6ff9cb19328053c3927d1905db3f0a5fc1e9ebff627f24283264249fa45e9689cfea1efc1d1cf4377e388fa42d3653bb72caa28623c5fb54aa4b03179bd7690148535c8e615b6e28f0c1a8c1388599768343cf8ac0de90fa46699ae6ffbc58d9f6a6c6761222b31f88cb01fba60fd8d151a373c8a04a817063d14bbf9f1322febddaad0e5a3856673d50efe4d0ccd129c7ef066672ee37a079eebaef74967e4b193980a2ac10cdd883f4cfaf072c1134fe6819bd7757401a11ec7c7e47b3a3f765ccb0e7971c12b16f596bd1b182ff57711a8fa59b9587432ea255e97d45c3788cb223a3d648d4ed4d8b605c85527394305dd19f587e46e7c35a0b48d1d35119bbdfb938f11e287dc9a8fdeaccec4a553276458fc1735bcf4d4a34540248afd18ac1f4d17aa23a36d2bd73f9c9ed4e54b53724eacd51f83cbf77f061b03892bb463a1efa469a96d8ff80cf869bb4c11b93c4fe3398fab2279ee57b50a1d33e539036b200c7fc1491e784360679e52743be7cee67cfb708e9e314b434c0ee8823da04753f23aa2d045a2e2ec312530ce52da530a7784ce71893a88b24525f60ceb65e668ac3545ffeb20e51a70f264dd937dd189be1ba118cdd3d8b186a8fb7d67043abf753357c2f5d3220782e0af6c88906140d12099a26790454c756243a8a94cf357276fa143764249d937739db55964aa8c9b644942f1c1ec093dd58d3d42ab88a4da12a818f86ea73fdef049a6ca5e5fca4e9412487ee95c148f22afd5aa1fe30e09ffd1cba51231883ecbd5c0ae7fa81aa8ace9ac96cbd9a2f75ab3661e7740862d8eaa5f3e50cd2899a37e86c793367419388d7a4211d527a0051351e4e07f3196dddab977d7aaaf8bbe974118aed9bfbc0324ef60876b87ab9a4445a405efe88ea6d39da8ccde14df1f2a0bad51023a700f9ccc03d72aeb8052aef2dc89d415040cde71d4e816fa588629b4b2e1d4399466d0973975171e557e6a02786b7467c1a109fddb71521f122e7d45f69f9b8cadde4b2ddc068e997a76566b27a0060c5efcea1a4260971f1c11398836ce913c747215c65cf7e3ffd77ea0036e969ca50b32138bb821b21bfd623f5b1ddc20304f2dc4edd1bddbe6d5e8ea11a4adb24b2053d7eaafca4a7d34f7c1802dcfe19924661357be440716366bda09e78c11f4fa90d67ecb62c19235743ff8b2cc01631ca9bade44254cde2a757a9dd47b9a101c25b27b471276b72fe73221a5bb916a308294f941a45f18be080143b510e69b50b87c8026a298e277e4ef1bf4aefb4e008adb859d7a34128aa28916ba85263a557dece574c39978393e5578b295527192a1c8051d534b9e57093bcf4d7196c54f3a7012474ce527b87a1b8c4980e55a5631d1a4eb36e42e1d2a88bb4d85d0cfd8a90f201f9209d01839e37d75b5aed3d018b4c6b78f6ed1d74a3e14fcd2c67faf186655d8bb88f4c0c1fb56824cafd34a7dcd1bb5ae164557c4e80e72b1051153f06155d51542de4fea2bca5b4504d710cc03f9335e624a3829adae7e8b74ff1f789dfecc4b791cba636b9cad25bd30ef862f40a5e487edb315de7e1f630baa8369baea809ff6e5b959b48fcb03a7c0fd064abb6ea74f95b52c92721709cc73362c648baae25431d999dae11363d5154538143720d0796461c998e50ed9fd42c892de3c55184b3d6fd825cf59eb7f09161233d5d21accc825ac02ed3e6383ebb9fb8446ea47afd10a8b2785df0740f881bd9655fe5167d13486440cfd6cf8adbd5efdb88a204060993b766a81c88543937939570f4eba4d4aa9fd5ff0157468d5f80fd4dcd9ab37070663f81213e2269b577ae00a1bcfc3d92e1ee9646446176ca5c2a150e6b6f5072936f6f7c9a9196268608961a5104f0f3ef143ded33fba8efc2e891c0334869d2f20ea6acd2b7e0133343db19d09daca59d95517b1c430bed5c6890d24c239aff7f76ea90678694a9b0b4e466cad9103fed80317b5adcc20c31ea6e3a899a6b05e4cb50e61a075462ec3478c461b81a52068ad61cd9987df331f3a64935f3f391a6f26570f0aad04f9d99d5da33add25775a5d2da382bf455e5b9347d190f8a4e3f532e03ea26fb564a9b7d771b7e1344b8ddc38a242e296a30d6971f1a822899b70048bfba6490e0c6161e439b0474f34420256aef3068eb1ecb053e2bef621cfae83937787b0e448e7e242cda34f2ea8ad6a462e71fae9b927fdef296e4071ae0ad5dbfc03cfe25e8cf69527c8b30930b031b4028b28fa3338e1b461083a9f9068e3ea2e7c75b3ae7fcfb74f30dc50ff2b6109ea3b44ba557a9ba6c83b56f8ddb31df09f40ff18efe9b4164db08811c85cd44de05f0c764fe370029c4f8d2926f54f78416005e24062074af965bd7b20254be1071b34c2306d7e5455f74ecc4ab93714a4ddee8e5f41759bbb298fd56576fc74892158b19e166563158dec2616fc7716e4b45bea043dcac7dbf8ea9a35fb30bdaf80c20fc4bba8f8248f219a0ea52b316e8b226eb246fe3c0b97ae8271cce21d288713f55079c8891416fa17414c80987c05d7f4a98f8a1d45cad4eda72d44de8ccd2d69918a05e2938c8ab8459b90b3d3e7c2303a58deabf55e5252b6d323fbcb3584919d4cbd4b46638a0daf5ae8814dca17774cfe9a8f0c3e0da59feb8ef170c72c554e498f794a710cded28184d075373d694f41ff6ed197302a95ad8f52daf4e3c8968ecc0a94294da02f58de74e78d11837b5bbc45470c96faa15e25aa811df97560791dad777e1e227386c1fc95d8d2137172d6b3e971df16d7aa96ae199ad8b1bb95481ba901cd962ffc5a9b56b0ee0c455a3155443fa7c6643bc92b252c1fe582afe6f5659a6fae2141c6a360912b5294b12bb625fb04428eb27c8a38b5300c45101bd3d796cef0e36b290b232e391636ae73063359060138ea74b52a48c20a81c66c420e2856360b3949c7691262b582017583aa60b617e70da42a73c2ded35d1f10d524ddfb8eb04d0a894d22adb4e3f19d2116dda86769e8f68042385d3ec16b6ed89e1bdaae0810f73682b23b66d1798b96331ed8a40640566740b739f807e8b7a7ae8e320d8141c9c5247f400faa91d1b1410e483ed16c3d5dfad308e06eed53601fcf08c4f0133d83c635ef6b734bb4d6e2c22ba897f3b9f82219956859644b39e80a2fa3e4786eed56fb54ab8b18988d93f2107ee5068a5e524da3025b8a7cb1663ded9424dac8e951f736121e98c1824c5c1b52ff979545dfc464200cb7d630dfc6344b9e5e1e02a6c9f6b354efe9ee8c672858c8c2e6a7e0fd27e13b8470a5e82736f811a19acf5508843a94be7f825b3e32928d42f81e59ccfd5b66ec359a1c07c4928696630f1f69bd4096948fe143460b2ffe464fd0df204cfad518d14edc9b8ee746f7346e443fe27074db458e263e8260d24c232c7288d7b5204defc4e5361c63d5ecc081a16b28ce30e016ff60ca133738ec86daba410c373f56169b192c63a6c06e00957006c656e54bcfd30902fa1282d36d0b53ef4a66366bf86969094fc18a045168af131f49103b71b5da0e2fe368eca4164f83b7916369e456e0a1f6cae5fe3660353fe928e89b2addd85fed0b113560c82879e2bc4e68b35dcc46143687c19316ac597b1d1f45acb3e6371d24dc3d3ac8bfb4adfa3763b84c02414f05e17b3f2f542fe1d31867468a3bb5d092b70c8d6f219c8403c4069d16b1c0eee50b450d0289b1bd8275e43e439ba29b9d3ea8ac08815c21d02b7ce69286a0f24ef8d950fe6cb390d76f8298a5a6194e9e3477de5509ec2bfbeab657489cc8cf8f1dba1beb670344c00127356f8d9fdd26f89865b9cfb7daf7ec6ac31e69cdf1168af4c229c0dc99e3e064732b09a82f44bcc52252099c451541f8fc1f70ee943c4e7bcca92c6bd1fcf7651a90f424f991ef31ab7f3b2a5e3c6853e886fdcd1fc1aed7a68f4126b38f2b2b2f8398c1da8f321a537c376f9ac04bc3be38e6bf5189d4bc8a83ed126e977c425a6a621f447f3b5125c75fef5484e3360d8b93ef9ff34b6f9ac17fe4ef1b0ab584d6e41784d209e9a196d88fc0be98f8b3ce87b27bf527bd73e115e95c25f77d4e016a50f2c483bd56a3f07ae599029f01951bd2a868e186f40d0e78de43d895dc9f4f450c1ebaec582237d41dc1fef209673f3f5ea8af2e8516a1529f945a9440789a9a9411f61d83f97bc1091e2017b57e5bbac26ea2e5b13fd0b0596fec5377d103db990d6034e65506b4bbaf95e7707a18724c3869c8efb00db587efd54155dcb62b88ed78fcc664d60dafd8d80f36e3b08b789ce2ba9148881d0489b226597450f2d66b978920ce63f83ab0bd063460f168aec31e551b8d3a902de534d86f966bd86d0011feba66d4eae755d974a04411d3bca8c58b3ea80cf96f3547b1fa38e8f5542d7284ac7c671f08c22613d947fe7f5f1cc211eb9b98994de33fa5d9ab7174afe86d688a43f2295c2a0a675a679afa1ba6e027c4f31a2d9938630c14fb57e682380a846070edb6284f16322ea591289a71d6a69b049d610ba2957ac6af4cea86151fae6a86f7f2ca09571cc02a16757da240deb4bfa01f1980d5df53c293522135f41419e405d1c795707bf5bf4139fd376da06008eb6ef3bb21b3e02a246c17faf62eaf7d07611f6fe1c6f9ebaac0932432af6d5e51fdd67205cdbb235d3821400d489ab2d703ebaca6a2e7816b9125dc158e1a4043bfcf8c6f1a0d2bbae77b197cbbd993ddc32b8e10e77f120d685c1fd7c6b7db91070c4a0c7e12d3474ef8532fe4b7444d1e9ca7263e82dd3e0d94c4ae3db0949d2681e2817cb5ed17c34223de13fe5013e49fee9ef8e3151c8253b82bfb1ba0a594af564acf88376e4824aecdd0f14d39be52ce129ac43f64148dfca717a7bb423afa022a77a0294f7748ab7ed0336a2490f0a8dbe7aceb4af2fd7e2105b589e1c43bc77982ba0253a3db807a293249d55489aaf112cef2549a3e4de168527746764d8301f54219207ee375d989a203b376778424018c658dc944ae651b510554f156525893caa4aa620052855776268ae0f76ba6f207880b37227c923a8fc9746bfdf9c2c3be3b93695f501d91a75babd3751c62d41c0deabcf54e813387cdd18ab285c221bb662a34f140197e8a2e764794022eda9199c58ed3068be881c54fc59e6d25d45f2a3299060d93b40cc617c96f4612a5b59fda4e8501e7068ab6312afe92332bcde1b78809c6452a222e54e2236e9d9eeb45be204a6ceffc083c5a2333dba31ca5adf725d2d38ef3c4a63b4d39ede553fc162b817c5f84aa095c357decaf84cbc732e87873f43e2af057981de081d36b84f96e7b7aa738cd1eb2b55850cb3ecc2be5e7d52f5d4dc1da54a0af4e2ab43d7ebb2a88ebc421fb4e0051d5f766a30e5b8dc71d0b24bc22ad8df3716212974b183b8b8da99b2b7fe7be032e5aabc5cef04486dfbb27f388181b7805235b33c64e7c71b2b0928516a6d29984576246ecc5862d20ad64d0ee27691d01651cc80a71f7cc692634f3474ccb292dd9f68af56c59fd489f4d2a3fb53f9a06ca1f9cb18b53d22c6f3ccf40c4d573d2f6e62db553abd194850d11882324fa12b49acfd5b4a688979b45847cbea96184964c5541b9815521ffd7bdd4f4d83c36b1dccbb3213a0ed0151d1415d26a5b68029e89c90482ab035304ff56d9d64a8d9f1884265261a70c6a3457a833fdc02efc479bcd872bee7c244b6743c6945fbb75bf0cb69cf45f6c99f0fbfb10bba8c3d074b2c48115cf69d1402d4db85eb7c3e5a069800ed7ef4b3644aa1c485b174307b5f53b6889b70da38fcd504a2d05f1141a770bb392b41b8b8d55c84096260378966b19e119ccf322cb5ded8a118cb9444e6c072549cb2a2f0ec3a28a9c02d53e067905fd5846fa4f425c7954912f03d0272c4b1b1e32149e305132f35b7b2fccc28f559bc5bdf929f0f8522047f1b022104978430faaa732c5f53e7fcae97352bf3e406261d6b188d10b7162147a677782e09582642dc1639778a826e2badc6b788e402fb317a12704c1f888097ca4c3be506d3091843c6cee4698dae72759e24335520befc3b07d91832ff8f933abd724f12844326cae915496c6b01c45bd4f635df67c7687510e8091707bb872cc676b3e4c1ae43f9738a2576835e756db051ae177d1ba4c8049081547f4c35163c4bf7b45b1a95ff7f43c9a0949c166085b4dac403a8ec5ef864f4836b9947985c811189ce0ae0ea2a32ebee6ef3914fd265cca96173bb41edb6e757eb7644bfeb3075b60a0764d160340b9ecea4a556b89752bd1e9ed08617edb644d104865fc0c8d011799a963652d622718010f46d2e500c4427060af535fac7d3a154ab827926f9acf0ad6d370b7ed9369801f3c618a209d8b2a5f30771227c4dc2f4522ed0244c6efab773996cd3fb89f6868ff8de8d50aa2d30977499e41fc8a4f32c54375631183e0aac992001fd7ce9382045791fa86aad7a5c64375b22fe894fd945ceeaa3170dfc474d70910fb1d358ffeb09b5db8e875517c8b685877f3fc81b622765deab874ce7a6942eb741bac5f19ba64ee6c4b2542d06c5a85e2972139c26a26834b6def57ee43de411828dc7f458dc5542d31a8f1ce04a76ea71864b45b9cb396642e207100ae7a65c558ab41402c0d7f8578d9164fea31f3f570076c25a994fbc20237f823d95f81db5676f2708cd48868093ef5cb680a0d9e1747074fdf3959fcd7f048f8d85e113367b547ec6f48a2888da2dced113f90e77554a329e8d8427410834f2d4681e3009ca53a430168e3c8da98ce8c0685700be9d175c4c4ef844e5aa02934e049c204bf92d6389c2ca3c4afbe24d38eb114c3f295e0fb9a30a1fde2fc90c8308f3a4fd540d7f3a82325410a93fb4904e85dab75913cdba7872340c6b7efa63b1c239f759d3d881d06097976f5ef48361df6f885950c7293983d9c43f453754c254f90de2b918e24cff959f75b2aa511f978f4f5b6e742a74cf0c534d6280d48575d01bdef04eda37b61be5085970708416f69a1ba60fa100b6a2862c051e2c14ba1183420c7bf5c9bd817980e7a59ee2806219e55e94ab1b79db52760f73196c1c03d842da523565e8e9e3996d47e0fbb575c6b26a9a5b92a084edc050f30c3bb1a77f5755add64a6f6ed22cd6308c3596cd89d38214bf73a2fad9a44895a0f31b1b4140f4ed7dedb3468e69fd4413d3b722451cec620117b64f662e28cd901de53344c7b685782201532ff4a1877319d90b213307fbb4881ce45176f78ed1f6d27be1de998a3a68c62d4fae661b8718612f34fd8c7aed27e53f35346820315b093126a99aec723cc1d2478f6d87593ff5f745025ecb35b59ebd7d0cc244cb6a32bf3c243c8f5160696aa4fad9333cd9c7e3ca10066e243538f467bc422ba9d0fc0093bb48220102372208d5704711ce89185142f0acc25f3f1203d58d0ff44bf9d339ceb449c721358c01c3d72863a8765eedcf0097da67ed27c5381a112a8b8c62442a5e383d59c41a4ba2121df1954fe3b8e47302dc58ac04e01a9c84ddd1f63d80190ceca8b8f51c4b5351343d9f4c04cf46643ef1c83e834f56d963c92f24cbefefbe5889a2c267de796ef91f493cf46381ba255b35a2ca2a7ef676731c36685a9577caaa7ca1153bf8e0a43c0ee69379d1b0add2d60328ad3577283edf3fc09ef748e6c954902f98bbaee8a2a348ffa6c1a73e9eabe2e2809b73c2993df4e41f525d1e4dfc935b9b365e200017e21a7519067164fb7d16c88ae3f7610bdbbafcfdae83c104edde4b2c684c38f688fcc26bf150186f80ecd9d228cd9b6e29a07d1039b8308dc75218cd2f0a23686d0a0d51b347fbfdcc092b731d5bc5e53e4375e0a38cffcd49bcfbeda6d3f9ed934b693d065e029ca9edf5396ad3ce0410832366c1ad4a56ed4e3c626ed3f1adc5c8814989a7c13c503d5b8efa6342da1a99534f576618bc21caf352638cff4f46254c859faac5b06f3f740e99e8913d6b0e294c833c06803560fd012f1e44511d75bffc3cafc0b6876ae94aaff5ab8c952eae30eeac6f4ce27ed24be591e9251b4e5f8180edc3e71760cca0931b54351ee234aecca1152486ebfcbf59a8ed325c66481fa94de5a9ca285156e80bce779f3e0361451face80cd3842ae57319f107984da3686052f5a4b1ac266ef395e4d6ea356002e4c1a109e63ca1a9a6664e16ee532be07a7e5662bc132c14102131d0a52993cbb99dbe82e3bc3020373dcf1d0b30f6ee25b4a1043d2541976409070f75d70b86df96d1b66e181bd82334ab1007466f7d963c058d8a11cd643e5ce16079498d6f1d58deef23af5aa5126f9572372c573230e3b47097d3cf22a815ec41282c2e39372a0b7580d3741570223bebca5f5b28839afe1ac59548fa348f46abd4aadd4ea425ca50a76610d1f28f8850e795de91d651ea83adb8475c8c7335d8f32bb6cad7043448a8a702c178b327c2520789f32adac2ff753a8cd0821c75c9f5897bee0ad61421277677ed64de473eb32852781c5064482fa71c86283fb8941c92c80d1a55712d4981ade92c78bb0e27beb3afd66c2e73a186e4e8af4c5a0f95d35ba83a938607692fb2c62863bf47e3b7e4c7479541b4b97c9a42d9ab1671d18937f3f8862ab16b97338b008d60a23135f021e084d14285001ca540c5506e8e13843f0dd674d6ba55b4ac6c1a85ba0a3f5e28694d414574c8d966c5340eb66c9e3c681eac362c152e73b613c677a289b5ee009ad10db920b57ee513ebe82d5399e182d45eb75c9fce8b6cc4bef3d419bd77d7baab1496589b35b32ceb36a7bc3e18bdb8af13334179950247a9fb77cca573429805f9601cffc3538623edaaff2214390a7b0e8a65d4e03463b4f543f79fbe87108b70a611b6e823dcb5dab79c78c7f9f55d486a81a32cd6fd448b6c2b204fee736c724a33a49ce4a38e7f696b81264c9bc83f9cb2a7afcbb509273298f696ec049d64e4798da28e2b6daaeab9222ac3bc92d27a97f0e87ed6503e9636fa8138a6f8fceed629c9c9df8b493a5add707388e47c05e919c5490eb37db3b4da449c4eea620254693ce8e70fd181b85b550cd8385de319f43a2a5eb9f496c28f97b037cecbfb9d7e6810472356d5f4a8c76d6852138dbb75ceac7f893fd7f3157466b570193b1da38252a165092ff4010fffe76802f7fc1b06a9f80788ecaf9387c1d1c4759b974d5eff373f7dc7900771c01e6a5d24740b80b827f00ab02731ba1b416a99748f89f2aa5470d8235397e9142f90a12745136c3bb25974b10ba848375c02ffdd77e252bb291e138e624f3c2558a6b8b8ef93563680fbb9ea18a4e023eec5ef3388479acb051a845d06256f2d8c46744aa60c584c66bc321612a7c852231457e0d605614e372462b6fde68ff07ff076eba030ae7e24a30315b9e4f9d6106cb88da664bd8ea3da804c5773ecc15b27c3220d0b4edfb135dbaa1f4fda8aa723cc257a55095cf50cb13762a38ef0a00514caaca009f55dce6bc008e246182b8087e98893b56bf07c1667598e86589c70935e2441e165b9df2ec4f7dd09cf87c24a4873d02a43c8437702632222ea32215ab81cb52c5698f07beffeed26844a9fe3860516b56d39871939bd49b9b70e6d665a5fcb400754fde69ff560d835ceb3cf60944d475a821594a2f8dad37ef608b70a497abf20a13f82ada21c44e0468a864dfb758c7449a8d4ae69cd87e2e72e7d21dcdb449a605e2543c9a9846e5a35d920fb99a7b332f07db3c774149c68924534017671d9799ac890d6535378cc1f581cf62f0666876a1b0cc3511ce10ff62d9980044e7c2ab409b68a2f833d54418883df9ec29fb434554a4242ef98e6f0429bc545fdb290fc8c82fa3683cbae5df45961e30d0a5f53e2438e1dd153f4f9bb28921484c8441fd1b55d4a5f60a34313ad8901d853b6fb46b2b48023969c5dae62d550bf620500017b241c20901636f36a5de5037ee580169416c37afa1f456874d8862e85015f3780b2e48f3bdb814c8c9584bdcf2ecc9c2202baac888b8336a74aae52b1e16e678ee8b5b089ec0b57b0f28d5b217cf011dafc66c10068d246deb4f8c9c74904af963f0d46bee4ab2950b8de608bc12eff1f8fa7ddc370ea367139e3cc820e19f6615a1eb980d50d23cfcdd6e2fe4f2f67e72556b5fb28ac75627d2c1f1b8a595f1673292bfd5d697e5576597f17856b230df883c149f4543eca6eab5d5fad2bc29eca1f72bbd7e7ab549bec5669bd83f61a0a4a54a83236a5c2127262dc350f04e1d2865b01c8aff0206bd20e8fc7222c557fdf4565fe24bbbd07da5c07f815fd476ece2ae90e16b69bfa963a15c389b184180e6cc9d29a99e2a51bb9bcfa845d2b759bc09df53b43b21f4ae75a7ed45f48b258b9d32efa9315dfd25fa8ea2db9a59d25d484d655b77229703f64fdf08393bcc7866991093f9ea39cdac5cadf629db696b3c7675d226def058c7c11d1da84f4cb6913580372ce46ce2f62dd8c76fb64331a34201fff7a83a63c1f72bf53acd3c5a2f6ceef4e4415904378b4e01ddfcea7a8aeb4d7f48b8593e4826ed32ea502d4b5a42d8efc5f51d0f09955e75b80db556cc7117cb8bad651ea6fda3ab3a5df1a4e7079ea6dc8b6aa323a75c66dc6e64317b10a9e12c55f1314468308dd0ef9638a4d2389005bb2a51c6bd6d2c4c9f0fcdd044cb0fd0f298251bac44500fa1ff05926ad363bd879261edc7ae45991350b0e4e4062b81d8b626537573024efcd88caa3687ed87f02c4ebc993dfb1780422540cc0950b6aedabdcb690e84696642170913b9f60518ed54ccc5450128764d318ca4c5bd7f7979369edd6a3efb8edecc77e33c26a2aa81ff55fc4969026110e35cb951e0e115cc103357711a09f37412baa11fc6288728d359a96f93fe39785d0f8fd55ff8fb1a65853d798b7d4f8d40a23248411004f745fd9a982acf16e599f742e0e9d217a0a597c90e9131d3a6f2018b5254f28330fee792703dd8df5ad47190515d66dee189e4177724d412310ba1bd23a9ee20976ee3aac9c025737c61bad02770e66c8e663ee82f6ec6ae3f19e229b2bf328a20856ad98cacc938cc6b6438c61e4de6a519eb8cd07ef65286401a74d1d97a3896943f771bfe69cf3ea43874e8df4bb5bd0ec22aeea1b41385fbf8cf0a83a8c91568e32b9c1c178ac1a56ffdc630fa1bc0a89acd10836eab3a2131ea402abe086135f282d5089afe4ad47e1d99106147c69c04b62d103ff9a09048aad2e8e690f5fc9c362f597ec3c7dcf80c28878d29b160cf66ccdf1bd0fe472aae8d1d35ad1019530174532fcff9d50c31491a91820c688a6af6e6af3337b236bc344e951d78281451c0fba7c2dab9d49c69923e0001a71632a881f18faa41893b297f5c7be21933aad88a51d81457bd43d2f45f5b2cd9f7b3495dde9707f2831000ac29a1162f5375ec957c846eb4aa46de3015891fa6be766e012723b44952eddf2919734903d041d5cfc0b7859646eb18d7a2513bf17904ffe0351484708d2402b9cbb5de980a6a914069a2cfa8ea263166dae25aa7f2b18c827c3edf31f369e658cfc1c9bb90f0550f0982e625a40867a2146294be2981006521f0fea70cf215e62be9b32e845461bc88bb30b948f0cb172b8d2fcaa0ea857bf60e85ecf7f5118de0613a3122f9b42b4e9c0ff8f928a36c626a691eef6ef3cf7dee27ffa3c1c627d8a3313034cf935fbdb1bca346b0fda8f38b9b4aaf9d46521ef1625f411f4fb450c25117a03eb3b6185867ba99fd0b46abbf5a288f496d3e1f172d1da30af143e13b8409448025dd193c7457b0a12118926f21e95f2b5d45bfdefe361e40f518aeb4b8fdbf11120c7dc265b63d30592749d2b6d46ba87742a6e85c681eb09d66cff66ec50fe02a5f9e042b0667a2eae93e885eb93a1089a9121789dabf1b6b24259f5f64926774aeab97f5830ca4c67d5824aa6cfc651293caa8d743d948505d56a18f5fbdc1921ddcef32a51142f4bac51ba036e1ab12d73f6e0361be009e0fd1bdc47a272d04bf673b795b6bb9bd886d3eb70df0dec8b75db5d9a61d87b8d2bd0544ed634b7a4a41feeddb5f19491dc609e95854fce844b3dd4cd3bbd33826d1c1dc78c1b449c22142f557d7827be597585c21cbeaddc274d0caa7d621fd7c67131b1c461034ea293187ae9bd9ad21b686513458598f907e57cf786d1bb1ce434fb9c161f7ebfb178cc489aeb0c0ae3786d3bb15244adfa6b8cf155c8e8bc15ce8c03e097ae7b731e79c20117026eec6941d0e7a347930637acf982838d733f10666e8074aac25dddf47cb809a0197ac53205f051972779a63c93a6fc5ab55221d6a4428d474c359ed790dcf84a25488efe59e4214e14377cf31e0a8067e66916a12dc967055d2ba8c02e803c0aa29ff984f860745b110a19d46bc7695e2dc39665484dc9470d8b20ffa5834ff5f9e76b9077edbc04f8f7633d220b751cadc188523130ec4ef4cf50e5a1e9152056d1599a023a8c325e433fb093927c53b8002ccf6632e9fda64747b4c50667e168325f76f3048676040d4d45a5a68da18933b869ad080f5663f7500de94c14ca5739e5b85b3c3bfd2bd5c738f6e67486ab42447335d7cae253b263585b9b14bc6e3444b35f28ff55eb6f704923d76ceaf8c040580aea65df2abac26ae157da33d196d99361d793f98a130dbba5e4d7b40129e9bcf211923759e7b9b80854824949b10009e3efd9404848c8f138c7c73f32e3adc62e728cf536ec922c0b2fe0f500e07c19977eb54d8c0a1e88f5eb1fc2713f41a2029a108c41d4d73ce53979572039f7ece08380e7d859399f97fcde7401456e8642fdfeeef65ddcf9ccfca5b3b293010763d5b21b2b7a4ee215f5de22b2408785415fee5785aa65167b962a518ba1b4bd8e79ec243866d1860ac36010347d0e7b1d5ad33722cab0b01a88882275a5d791625e0b9e7579150d72b84e2a9dc6b1077bf11cc2c1f6d6a66583c8f34e719d7cc243e1369d615972b49587f97ec0b5e9b780aada72ff5434e8b6c6d657768b0d11a48356f392387310eb73d483d0beda79faf1be1fa7e8fe673ed5a57b7cf81e0b636ef2904d709435e35a6010c17b61186dceb3f9f7e5618111007794472937c3c8b9305e24c7aa042c6494f278dadacae846b8f970e8f61fc00e0e95ecac75819f5f9507d7752f5f558bd56c1f14092349f0e5cdb713fee744eca44d85b4b4a5453fe5d1165125c86b3e8617a44955b7d39e67a80577f88702b0b417076da33a4cba128dfaa6547f465c05d89088b61ee9d2a6e7721e54cc5424b1aa71aa3c0fd42dd2261fea318eaf03534784bd522926eaf0790e9b093e06af698385a5cc9f63533add23ec88b909197014a810af375a8a84845079cba9c4faf876b1fa823f84716f51ea68f43441d1fc07bdd7b1c122d950dd6889b9c2a25f5f451ed3322aa9db4b293707cab18b2948f150d78ccea0af6b42888adf564c840d7163e8bd53a00bffec04c43d5fb62c00de88c7f4797c1bde5713da3661b791d335f4e23ad3557062b91fa6a8058a36aabe5b8e3c605bbf5e9154b2ed31aa3bb1279e41ea068e86b827e60284db64278df0e8c84ae9e0f042735a80df5b3d6055af2e74cff93fd28feac4956b49d7fb65f3fda70a5386ec7833e013d7a0843938146615273ed86d51a58ccc509fda1655398c9eb40d1c75f4324724e9178961ee2bda764b8b852f912dde1f486a480f008ec8c96fb36f5aa9e2ba31d87ca3f249b7c141b269857f6896531e5912953293049d84889df7cf6cc1824aa5fc056c6acc91864c4e5d9ae1daceddd90fe8dcb37af95eb6f7c4cfbd50b33d22a96d2fb2ad455bb361a1e570228f6f48cd0b8e2cf85b12a2e73387816e55c9a791ec762aa5336894e9d6b91321c0d37cfb2d8af20fc83a8a063eaf2ff676d2261d943f9bb48f5511916fdaf7754609cccbca5fcbbfed8d12e24038f9dd4c5613edebbb250369830e566b66254799898819bef0f0481803d26492c0c4a89ee35c6c757decd640253bdc8db1928f5860e7612d9dfc91d0d91e1d21bc3eb2bfeb13ce973a4a1d3e1399294c18039c705a908212bfb2e3e6437fe9c43d767187857678b1ae4655938dda036143946b323ad1c36888ff9f9ff2575fa9ec9cf0924d20cd73c2bbc56147b7ed44b803d5374b05228b943f65ac3ffc68e1f7cb8a0a96f4b18ebe0df114992d9e9a5671018daf28c9ff1ea73459da2574a4cdef7d2184538350f3d4eaf7dffeaaa8dbe3e0928801a2d1f99ababa578e12c97b50ae87f1a043636c380b3fcb9468948621d8bee00389424632e816878f25c1def87ac0e324ffea6bb638cb649dbba66ebf716bfb0c49ab32961c6c14a3efb818c81c326743973b52fa4b2aabc9124124b001ed55f28aaa9bc74d67a7c748b6270a9314090f119ce530d2a357e6de9c7a69a1686f6e3b2070b78592b4a5bab7c4e217c9e6db90add4791766877f9b0caa87d0e717625f33260686b8e0e0b68c626658e0b0f69bb5f1963228eef15d46cbc7e069eed69e7b61563c1d4bd82ea568e0c96cd1bd57b8ea3055d0169387d75e2f4ae29951ac012ee880e682fda34e79ee5892ff7503c5baa2a12d9ba3159a1230a56b5fc7b89df6affeafa0356e15fdd45f75ff1c8cdd48cb0e576720ccd5450b1444bd575108a3b3b30a13a742caad6bf6fb722617ab01d51b3f1a344b807018a2dc27504b91c00214ffb9b669e9876b31631a4900d76ebc1f4144d07b57f0b9bede1bbc0c5fca670fda0001ae38c795ab0a0b3c97fbdabbbba1afc141ef89a013d5ddf167d9690ca3c4455a2b064d2d050ba70f7dd94bf3dfcb47e1d4a39ebb59d6008af4a6d32e705b285956319854a9b58fe1ccde8adc165286424e8655e6a592b663101cf1fe843265c19eb2335155eb91a7ddff88e2090cb075256b7ddd757a51a6c0bcc7b0a0088400a8cb0f21897e23fc639191cf56d2c884af583e268854b71965548974ca44ae2c98746f1b8a4cda8e601c8284fe935d251e264a63aa1b2e7cf0411646e81d1486ddb4ce1279f58151c6fb9a3c2eed6f89166e7faf88296d40b9ee24fb366abcca5d37a673623f6c87466c7d02b5fd245b35ddca3ad731249a60511473ca5a858c06245ced12e6f99a1422acd93a0c4138707c3cbe1c44d1c895309f6913784ac6132198838a0a82b3d72d088cc5e77828f737af0fda05e91a82944c1c9a742f6e20ee7e8f3d68de40eb2fafd41321135a407ca74e61c1da1b1ee2cd408ff8a4d333a4baced8c90943c21e8a07a12c1e1bdb855b657dd4fff2b3f038edfed6224b38a3bfceb9edec2df92ded930d6dedca6fd70c7018a86bf24ec1653d3a88196505fae6b3a172f06276d1b6e3b428bf6b87381ff232a7ac61e621fec4bef670838b4d6dd2bbdf30246134a0c3e019a71312220384a73fd1d80e7fcd5bcdcb6e9c431a44b5958177332ecce8ad8cbbaf5e299a23ef5b6fd0581a1053578ea6476e68159939de0ca46c9d05c466d4b559c898226f4d8c1626aa52e73fe14b65c058438559ac78642f82c43ed98103beef1a9377bbc720380cd8217c02cb1293495fa5b4f4bb6f67cd0bcc0ff691ecaa0d3fc3071038bf9502e5d1e28e9f0cbbcd4c23bf344dea9a1c742f2c34cfa63be29a184f7008e574d2aa79a580f84f5c9bfe8f235d4bf13fba7778e7b7bdc50e52858d85733acc48bad8d4203b329ee8344b69dfd005e58be89960180c92e90979e58d654e0e9a60da6b12a006981b5546791dc306d81543d58b427fa919e75981d36ad8d44ea77e151c7c14a377157aa26a9903578a0a58ad8c82bff158e2e08dc594330b5dbf10b0e16e688ef75c1f4d1f3682d44b56d1cb853696e6038dbd3637eca48d4a3e1244f0c054fe62d96603669c66e62ca4d63dab63a1c43f3e2abe5fbb89cfc80710839ec0d2f6d36f4e70c3460c80357f9d3caed70ee8dbfd41ef5a46874955208ea498f6bd6aa545c7fa4b49a6092572cb33532935e4f54cd8d4e1cdce64167e15367933816f6a1f1c9da959eaae9115216c5349aba8e177825152904144213ffd0a01d66acc28be5e79058d156dc749e1c6a99ac82c66864216bcac3a0f1075d97241b7db99f169198483184c4367d07bbe6599e696dead4825824362c5de27112e1cabfb69561769ada311d3c70990b846b2da14cf1cccb94ebddbc8a0815aa12d3dc1a7015d24465c5fca946307b4e590b21ee7f4df54a3ea0b399aeb7d70099c020eeb77be9e7e7f92ade3bfd0b02175a0e8b7d6b73571f5df67d23e7a72ff4d8c2c15529b9fa2fa9e802ea131ca920290e3bc667546090f0ae5faf1d9c798b3eedb65e73037d34bb06598651e26d0ce0dc9dd034a870325337dbeebd5e8487f7b9ba9bdff9bf092ac5e962dc6516c2bc48cde4e23752ab18062bf4d43e8a7d66ddbe78e1800a6044acdcdead184f87cd8f95463edb10f54f4ecb3cfa49b4aa18da4022ebd5affb4cc6c4b80f489338fdadefbe9eb94e0616264d207c841867a485f2399990c1cf76b6545ead81e022421f1b812f93d27fdd974cc0dcf9c8837d389caae959c19aef4c06f7ed4211624709f3efd6c6ab46fce185c31674c1102fe1219082ec50e2cb627333e91c4836cb2ba070fe6b24d6909230fa7e105e2127d5dc7b0a01126abd663dfd9090ee42db0f5c1f86a99df40a1da705707c218b4880e0d7094216a0a3ba9cbc42652d8a8a9b984ae869669d3d76ea25e6f2e7a45d7c43ea210e552622359adbc27ffdf30220bcc33d1bdde7f12108b4151429cd9283f63894c4d5238b003a391a7c7b5b2c47e6961d53799bf9a5d5035996a33aa89a8c08e2541d609b7825719673abf855763f320c1d72e49b3d00d2fc2aaf7f371008dbda20f368c834f50365a4ccab0d124174e2701f488cb1ff8e2cacb41b285dff36e3582f98302580a4164259ea5071e81cce76f0986ba09a9e78c40a0b8f6bcb6fdbb4c6d7b588f7dd9d9b12be5f8ec329ba303f5a3e14d8ffc840a369bea6e4db138ab1832aa5646048530d9e2a7f947b10534c5e6ed42ec5249eb87328371674b84837b4093a02ad7676d1d8d17899c10a6ad31ff9331e3cb8aaf3a9a75e5aa36a704feef517cdfa900efde4cf8c7dd9af76394e7f968d9e67eafd3500654426f0056ef3243c2f1c715f09f9faa15501e59fa806bc83b4e407fd7e75d946f660e2ff08458277599850778aa5de07ac6b5eae9a1bcfaa4322507d63d37309468d66f70b48839b149ea908e56ab81ab308920eae0c9ca7b5fada48c4b1278eee4634006f5bb2f9318523b24e80189f7d89a640089c00c06dd26e80ca16fc9c1f34554cd00957beaae6ecf30dde6f307e1bb389c6bdd4c1e4f303bdd29f7ae1fd431a2008ed3cdae8dc34efc7305e063a266d283879499faac63f33c1962b8864f8957f16acf5a52d42be67d03b7cba3eb80944bf9f6c0550d1cb73d7d1650ec49a783bd340118ced8eaa30df5012de4a457367dd786be35f0d1a3b167bb2c60476899364d74c63bb6f8433c531ffd2017ecf32b6f062d6ca98410e8b410cd168fb0a2b4a7324daa2e4effe10fbdb872f444907357a891c3eefa8445f1944f64539d9da3dc70b83c1e8249dada6e1f514caba910bb7f25690b639986fdcb81485304e29e4ed88fc361d03686d938b6068e547a8652c2d52c556cbb9367d356470fec2e9e840677fef1e95ddf6282da885a52c00bdd11aaaa6bae1178bb75928ef92727d3d0e99d4c26cd279aa1cd8f4adb58bae94d4efccf64e8e46c985670201ad93fb5b28bbea3991bc55ef911063d57af52ba11e2ac9a39a398d664dd9661a1d5a11ef0485dfed2f5e4a6a927018ad311d1b8e189bf7b6c2513d8782e43873263d8187f84d77132322838723288347ac9fbedcc6b51a39f6608469bf2486ffc11e40abb9d5b5eda85a5a4443422c5b853eebfa47066d17bd7451d2f60a6fb57ff6e83d575043b6cbd0772237ba0088880c07b1913d0aa2803615de67a13e63f8508a00453d8572c12539571cba1239268775d44ff8a6b8ae727272af0e95c86807fcf2d01991747982bb60a99446e3e969150bf957e0cc60262e8bbf4b91fe2048fe13b7d11ceb02e7760f1125fc3faff6e0e866c5c11c9363c6848c4bcdf77fd12f459bad58e09ff09b55299917723146204a20dfcdbc475c630293da527b0a4380b5997cd2410280b839b1a5a76d830f44f424620d65ce73a4ef4c08fb2dc443a1fe9c9b3837a9e0f9fd7d10696ad16c16dea0101b19fcae4221fecb87f3b2cd38299c01a3e99c74b95ffc6ae816f296215b24c016a11c384706c687802742a0793f5af24ce0a9ddd0fe1272aef1027a8447617ed70cb66601b284187b07324ffa3165e319dd8131ed84b1e1b82c172f3890ae8b958dfd9ed04d59eee74e67f9a7743b9591feb3e4e88cb5075612e0e339092f5bd9f89e7644d1a7149e50214584b1381d952f7c52f49a58fdfbe303f7265ad96eef7caa30907d846acdadcf66e4ffaaf0a2d7f73fbcc5e4d69b64782f1af716bea4dfa38f07bca30f6985048f8999f7ede761a794d2ae557d9643c10c7eedbae639d57689b3a86328c9033c8898e1651f28150344afeb3dd5f3bd13c20e681641ba756f1d1baac73772022f22f42d41b1d8fd522b7c5bfd36f698aedc4696496389f47efc2038099500987bbab2b59112da96b4e3168f597a0186346708453ec4efb3cc122297bfb35dae844c5f31fc4256c5faac94c0c6c1414692feb157814d41eb5ccb780a9fb31733ebce5444b37cc0aa9f9e676966cc4d205458f5c047e043be85623986bf2c63a3db947a2454091b506faf5db2dd5507fcc415e0bc26ae4d77866c0bfae48a3e488c217ada1d5f4b1ae12e00b97ed208d48ce6183552f53b44a29aac38aa0ae1f10ad2f92d8e41826c80aa2a912d5fc527cc4818dfefda684aba6ed75711a32ceeba83fbcd7ffdd25099dfd52bec507546e940d07f1659a7a6e9c997624cdf4634941b6d3eb7a708e23e7326a9cbd57aa2e8bde42b40ccbe7308b351a984d6510abcb0a13ddd915b7cb1b653c9d691fae2f9ad11ece6c6a5d714f506d2a0509929ff7c22a2c8a0ca0f7a5d22e90b6e2dd4fe3cd40433c6c1439a365292ab28bacb924f4c769fc92bcf597be1e5eeaaad8974d2fa903f2d64f82053fa9f3cd8f29865a01d7e6581f1f72999d846ecbd02e1b47fefdd0f762d991c2edd05247a5c384096ee8d2f8736755e9a34cd6fa9bfb9a8530d929797b7e2c3e9d4a2456dfa1b43eed6aea7aab33533d9785eb6fd77cb4dadb2d4e09eb5d5be1b7473fe8f3d5338eb4a124918a80a9f62c90cf3cd629d818a0f5e5bd11d5c7163423015282e7620d1f7790d3437e66ec563369343db4f6ed489a2f07f1af436ab243f6ad52a8e15b25e732e501b31e7d1822cd6991cac7ac9e7f0e74b409dd1581af760dec64138c733a7f06b1e22205fcd203d6c5cc31ca70c68299745f1eaedb19f1648078cd70818e44b12584a88de2dc2641e771679f9ebd9586e3ff0df9bf56e4ce08e39c83e53044737a3e3799be33b4a2a64b66077a4a4ba6b27cc39c0173c49008c619556095842cd8bd8af25fb8a3a7d0d764b050db9cd3ff99147c370aeecea1e703de9a0a4c0c9d309360f60c5e78784cf57c08704093c7b1e717fda5a2c30c25539ca3936d791aa1175ae19078ada11d8df67ee6f6d81b111ffc1a8c8e8c827886a57c8745723ba503e4de3deb143855c52e68c54cd9b406e105eb7fb8b6411150b76c8560b00606cfacfe8406a561e229f04ff4d66a29779d062f17cdd60cba836eabac27ae7f06528cd3521bba1b2571526984e671eb1ff8b157734a4e07dfffc2ef454622ed5b20eeaa130f0227fe146fe8fd6fb7c71309d10625b04c5d508c2ae410af21be1e37889ddd58d8bbf0103a07c86fa34001c8bc6d4da2fef0df58eebf46aab4159f224c97584e70422c06ace9e593cc08301d61b105eb9285d18f58f4bab2b70167755aceba78011e9ff5d1e1809ee3b74968dede78b9ece2986210cb42118e0cdc1323cef3308220dc0262f1431c4e1fd014135700121d3784c459040d0ebd2d8a3efd052f4659bc68658a8fbbf32dbc134401729941a04e6eaa143747c20136585ddeb07e3dc0319f520bd89f1d7015da3b58b7643bf6ba25518bad33b8d2a00093401ce55a5974eed3ffa6e393667f82414341971964cfbe15ad1867d17bd5d10ba1f729a08020239872210a362b62b53f272edd3fcac8eddb350ba23ee8387bfc8822d487e5420f13b983e3b7f6fd58710ef5ed5b54ada92c95eca83475523225e516b4fe964a78985a8a92ce575be8cb176a52a2141ac6252749dacfd03dfdae9f3662a2e4455e45cf7835ef3ea99073109e326089c4d222dfbbbedcaab06e09f8e658a0c452e60f8ed08f8dfd01a3b7bfa0dbb3b893956cf6e765f3926d65630bf7ab421da074a2eefb4250cfa5dcd46a01dfbc019a33e85f4417b13acc74d064ca3b56e6ea8aec38cd63ccd8335628e104e3c71a92dafcd9efe6218efa24c3aa3f2b32c34220384ba676d2038e35811a1e7d242bf57332d802bfd5a866cef34bad8d53176c3f2145ecb0a8d67ed823b2e0a364ae38bf357381bef2d28854f7280f0d0725bfcf4baa8c3390efe0f40794d965b75bd7bd5336edea12f4f57b3b5d220fb01dcc2af33b51298e70b69a3d73068b7b6a7f361aabeb72a59c70230cdd8ac53240d25b471ce538d0afb91c6dc7abfd2e3703bc7dbb2dd74eee5713297794849d9288926a63ebb46b5af0bd4d18b9b25ffdd3049e51c80b6e2fef049c9c810dca20a9e3b4be9d861d0c0ac6739c47bb2eaf3cbe2b6d71c104843446e1889b1673817171fcbf2958d34521b433ed91258cf58db230777bab0138e9765af5ce3aad53bea9d202ed6aa905be6be775a497d6f3354d5549e34e062e92a3a7c7a7c0e9e9874811bf6c1411f7c2001bde7efa818b2e11ae7402edbdccaff59315a7707e5e325d5952d8bcf993c88a152617ee1d4ebfdac030d39c3dca09ee21b63995bf5eb5fd48ca13a141e5398b6fcc93073417cd22f11fdc379ffb498490c4d24d4d7c7403c66aaf3a5f92d6efd21deb7519887f6693c377c5a96ef7ba1350ed1ab1192a0186a3b7da9ff6a4c1528a55ae079f8f31f916ee0e55326a9ec825c479cf431a41e7ab1edbac9dc690666c62a3f501b543dc7573df46c761d11797fc522c0f58ac1838c3149d278a1ddeee2bd290fb5c46c5f3a9c917ec6a12267fabca21318be8a9fdb7113bfd3c68656e6cafd9c84d733ceb033780eb9c93791edc5626f88b3990b202bbd065e3123946daac3e3ffa2ddeb41581af667c67893f11662a5b5c041f51fc293d0bfbcf9fd9610f8707966709b7c8a032265fbed199125b27792e84efa8b76a1651e1ca1e59dbd4ca4484fe159a3fdbb96536b6001930eb1095cc8a461013d2e5cfece61f82ce7bf32885ddbed2d5188db035b90b141e1bb091f3d08980572cc0650cc83ffa32020d8bfeef3dba42d9015fca4024f07f192d6f530e3b9ef5f2bdc44c0cd391d2860652116ae633fcefe4f580df9abc09fa69df924e7bf78d4e917e52c1774d240d8afb8c0e43969dbb39a308a6668c579ac26fdf6789a172f9a8c326da770fbf171e14b0c18634ef31467c22f4243dd99e5e4f36ab11c00281c3750b52c85fe7c4fe95efc2b356de51d132c1746fd5ba927ab74411935330e0ecf340eea127d24875d656e6173b06aceaa5c37ab7e1b8f2b527ee7614d61e404bfd71d523ac8fac019c6c3bd12e3ce2d8b1e71bb2b51dd54532f45c568ec6ca669d9648fcf18fd28f4ea84a89c60e4395cf028ee5843857b44dc8f6c20fda05e38259987095a29640a51779a83854545f1994ea5630a8dd01b52947856fafa23e8196c3a40cc065bcb50a6a42a534be005c267f811bf4af6fb3787369065a9d64b13c926af7742b55940226782a752dce5ead79073b9ba8d90966aa3b6f35e47a74e34a47cdf73b14014579f27e54501280a46dd3767c402fd5e79552738aa405a8ab1e0c62ef9cc4a3c2da40a3efc633e733182e6b836b4b7ad067475ff410b20689cd20d976ff24cbbcd36f267dfdb1cedc718f984bd279df543d0285e958e72ef49a4554b1c2283a70aa131cf1ab6bd0a1071ba92afb0343614860cc6d2f4df8775273b68ce5b4c1f46e95e7d80f9c130723519272449e036b4852a159974ab40ba77de0d4e8c4877b98b4e7863ae8c4b0d6b94039996969b0707467f0383c7141091d4e90a7c724c77972dddf95708da78b6e6ac8028a274b7392c86c9b84ecdc67678d6e7119af8ba1db3a4f2c3c1b4fafd2475a6cdcd2fb2eec757640b2936252f1d7e7cef06a9aaeb9cb5013e6cdfdc75997c76cb164160fe55dcd8e72e5ef4e31dea4d9db4fec775ead8f590fb0eabefc9100921fc9135d5fae8a8f55fbd21662ace142e1548e53e036bbd21d74242655afc1c312fc4df39c5a478dc208917bdd80727cd9114238cf6d408b9585b2584ac1f9a837b72584a985f44525e560e47d8b38af0393f54d8c4d842e25d00e961f36cef2674bfb4b40221d24b043e2ecc155424be7626c33a474028534a9f2d2a4f39a0ce7b326cf5697a146b95765fdeb403070e7c307fff330d461ecac6b847d7ecc08c762bebc0bb4da73a1728481fa8b529222ee12af6af2a9b113c0089e8e1caf6e90bc9884a3ca59848da2e2cf5d1e7631abad60418d55a87b12a12a157cbad1ba69bb68a19b376c006151e70917d5c364c015ac8e329a11b6a214d7b404b1f380a458f1aff81ee3e027af6de449b2867fa32b8abe54abae61d76db5402443639ad825845cad56400d78b8b3838e84366dfe48c835f96f13b2e01866f0e339d8bc273113871dc7bfe8aef12dd80d6a390a1465af8fd6fd9c429fff6a8cbb91614f1222fcc5ccbd5ef53728e86afd78655542bc4b03b8a0763a39545ba3810ed5b94adcbd0e740862d26d790aec8fceab637c3af98dabe33bc6f6e73690d9e8256fa076984e0692e481f07108e8f431320143bb929a604a52203bbf15bb1e57d36f0bb117841e7a8bfdeabb6bf8c58bc2c32b49a0d736e2eae97ef62849359ada4d6a0438bc75c0a892e38546954283856405b5dd68ffd095744793b8824dc0c06ec50bcb2c8a7221d57b50af477c477d30dfdd824d28ba2e40799dcefd4184562eb836718e1bd9ee4e97be92cc34e9945f375fd2fec3f91d88a1fffab583338782d5e429e971c0cb96d6cada64cae960cd466c4fdab988713a129ca666dcf471a26a8d349216f261ba42a6f09333d5e54723a5a09b620033f9a4c60225046df6b6ac06a0f8f2795d39a5453da17a1d936ba785284d95d013c81048fcdc9300a1a65258fcbc1b6bc209542ce1eae11cec66bd3caa7a2ee71e11a141a16004fbcf4d91dc4788e89b7a1bef1895e77fccaaec51e3fb299ce73fac321293a2001d641ba4ee4481f0ff8540a20a24e56f0a7f43de9f24228c28906bbfc347a16543ac1ee7d25809b0c05e0bd2c91e8bf9f9217f7f933dd03ece0bb9c5a1507b1af6127b1ab125ca52c22bb75e43c6f99bf53330486bf896684cbf8c112823ee2fe2b3a508664052a3a129a04a19790a4b2f6deb8a9bbae993716deb766b01f57b3f7bf980ff406aca94dd6b4a26489fe3e94e9c8779adfb37dcf66712ffb3fab32420d81aaf1d655152d93253d2d27d0cca6d47a04d5a6fb34d73874b1f523bc8a3ee1a4bc1005877997a94bf7fd070aeff193234dce75351cf6c918e47c5d339648ac5b682a4ef49d6e149db2d84794bb1ca17c34ce23adb75de77a7ab154977a1d3ead3e05d962a03ef070afb5cdbaa4dbe1fc677ea1cfdb13e43e1dfb1bd083f261bc1eb9ab09cad0a4d868e73c6e5160cde19a57aee9e78122a32498eddc67604549b5c4e921602519633d988ddc205fbe6f64aa21186886d4947f9842ac46298039b0971eef306753dbe6bb8086f099955cc0660fdc6983d78b5943dab5631dd850551878e43b18008fbb53ef17d92cae21b4fb8d5650d262d98d03e5f76ca20e68dd1de10e16010f398cddff71a979d05580bb00a1a025b4518842e3866a4c38dff06ec8f94bd7ed9aa191d389d08b230537477768a586920f1c431375cf3bb2496ee3f1cc08efd6744a84397b412413d649283d2ba33816084b81ebfe2d9b0dda9957c659547ab5e8b75d019006bf6f717f44a3365b336b1e4f33a010316aece3dc1426e40a587b4dcb279efb1bfec511625a0609150d9bdca9721719014bd8ba8ac1feb85040bb6cceae21ec76bdf7573e11ea34f3666688825a29754b6fb91b8fd2d8466bbca8949c3aca76959c0ef6bff02bf2e3d7cfda5e666a0b838f3789dff18ca07efb754f8114b117a475025ecfc20d3a0adff1ff5750d78188b4b6b9444f06de5f10e306834f35e0f94c0f1f94002db3eaba71899fd19afce948689045215a1f6d148584bfa2e813c2c84bfdb51f8fa5d90fdeac6502e919183470ccd7c976eb0a7861ecffd2a704b50f4c728b98179be795692ea95baa3b651ec3b901b5111aea4a4acaf75d58ab0e8a5d5e9a267dde4da551b2be0047fe998c2b71dd63f12df5583798046e7ad7b83118ffade914984f60af1cdfc3353b257166100703aa8d69f292bb9b2eb6d67149ae7a871f21f7f5ec9c18a022c365d22c6c862526e0bfb641b08a5fa4b2f94687a3c57180fe6e1637e193b74310890692dfd4270aa4cb9dfcb0bb0ad4c04ce126021a27744dd7b548d817aac0250d7fb0e206cf07856113c8ecd1fc4460d79b04e88455a0d4016087c3fc481684ce9d3af5641007efd3084b8ff517605e8d0c15f9df12e7ec013be8185d39465313bc53de96353967a91b2b4c26442d1c69fa177a126f6abd88665a4952fc90918274b68317756ade4d52263df18b2012b5de7d180905b78526818bfa89d01e1a4e5df2a7a6e17593d7dfd624bbc7a7f6c9c5fa33862ba25458198ca287adf131beaf4435318243e9b00e5ac8e463b4885d531a78b703804ac2f4adcbe35bf6e42e58e234ac0b3bddd41f9ffc17940c75fbbf0b13367781c6c2719524d647450f4c35f7d8d2e4d47c5845e2e54da04c17bd071b32c3878938038943d2e8669118b55362ad62607b6a3f3547cbc044223c9599055b6ba4f2e9bfdea487815079989877beb45ba25a6521f5b5588227e2cd8e56765c9f635574054297e2420f81619ec4d773af6525555248240443a6701eb07d2f1c6d6879682e287151da1b9528edf3d39424b7f09c91f2ba793d8ca90e0abfb4110ef435066c96e2e82a86378b4777f85ffe7fc37e9c17a494b286ad0ed9c6c4422bcd2f37573f87865a333431d5380de1107acfa7cd83634cd73b4916293a978b495aa213409c0322ff9454755ae794d6011f3a948fa1986185bddb82db3099b6438a65efbff6128c0180eecb78293001ca3b9e0f0558ede3e151814d4cb6e39ae161d8107809ef74f47d4bfa420b890cbcfcd593d663046d62126862b0d153880c79da9d63f16b92c54f2721b1f90ef5c3abfc736130cc9385795fcd078022794d0665ee8e0d0670235878cef2d3db068a55ec647a6b4adc8dcf406959a5098f30ee80a2e7651fa1f9627352c27071b6a2f4daa52aaf3ec6fb1174c11042f4f35947558f6a31215c33a033220f88a30868152bd3d0f31ae0e2894916005e44525cdaec36eff4c43d680f01e7fca68180d83c1720e4f16750ea18b858eb95af2b2bb531c4aac1dda9daa8d03669e21a3126179d5ae36768d03add7de07d404616c5ebffdff5de75800819a6b49bd9ed2fb889e3340ac3d29c3623a4ebec37ccbc5b0b53388298b493cadf6ae808badee69a94eec9f6daf844f03783f8432d7a88c66ee0f3d697768e608b2c16562271cdd0fed793e43a49e2a08f5e774f7229a0e377afd89846be2a45c4729a262a41578308807292dbd9987bcb27e42c07fcf46da242229774393a1103be828ac7ee805c94fa9b1a5d9dd92f1576f341e8294c98895f72966fcc4f2adad5d72171ba8ff2ca18ab0b660e5b834112fd494d28c1c86d0d675bac35c28616aaf4a8e8a748e67a41aae343211e00261c59719b7beddfcd575baab47afca8ec298ffa2539a264bdbcc62154ad979165a99ec6f24c01b5ad3c6119afca8d328948e67baa1a6871d39f040df29e5809f0f71a9c107572e110279ee38cb79cf9c2070a494ff9249743a270f8c5ac98d5786ff3c4116745805c2a148e324d91acf09b86bcff1b25bb9ce757f12028c1ef0226af78712785ed17790fac67a252366583fc9eeea1ed05638f0c9e9606a29670cf83fd2e39362a2065c47a145f1344f9ccc746bc189420326a177c96bb2228bf0961f4407cb20ac051793eaf98561d5e84836607855f794c882901c62c854c1bf77a715aca1010aa31944a4fb9b84b4bf14d25aac11c66a841451821ffa689b0f4daa74a911a0c9a346f2211f141119bc046a355e81982a3b9451b12b544dea65c2c16ecf88a413c179e0da5aab08e417c8fe5c4412eb20cdfde65dfeae86e22316118848c99200c5835c65a9290e33c1494f085bba5adee9e7a714294cf65cdfa7f28abc395f576828b311c320a905e5ad3a0b5c9a9fc0fc2a541631c9da28121c002d6e8d57e2e462e11893aff1b554a7fc250c782b03e41ec0f7c22b23e2bdd4a47bf3745dbdd9dea342df93894ec0afa7911f90769a79ce27ecc961cd30b0a23b648b58165022c9109ca58f5066c01a63c0775ca7d972cdc1371dcb4f05b1377a492fb5483f6c1f154a32e6f77bc9d6b82d69aa9e3c5c3de776e8f839d5cce71179142a42b8a21008435148e212c2d8de0aa90d09ec2742c16bec51dce7d8925ae20af53627c540567f4096ddc767a485a6997ae1115646acb5da45a66828c3147de83d50f500ab13d02b80b43405452e03fd18c5ee7cf710dd1184d8f37ee9a71b1be526fb9bbc9a7a884ec166b2d64ba8d1a051c35901d0c1d47f50d3e2e8ef333a11656f140cd5dc8dc0aef0852767646f66f6031c8680bee6b3a894144c944e7a3e0e3cd065bcce82e7ca9059423cb2c7975865d8804ded058e33bbb074fd580cbd978d745fc50b92e4f5f457ba0fd9f13b50264667f5d8fda497c1d6c8ee1c3a9a342adce5dacd2955e7514cf4aff6a0ac73cb34f1725bef5d032add64a880cadef1a0fd3fcaf7e1700c7370fb7c616ce2e060736cedca4c127c508b478e194a6803db09b09fd7854428cdcc6e07ede368495361d8af37f8f9407edcd38770691194e2147f3cb33324a2f5d3c3d2e91a88fd2e3b0ac58c4b5d39ae8ce07eb41847a34e0ebe49c13e30397a4efc32a2f18e9c485728e7dc76587456694fab33f64371843c139a8702a86f2ed8217a61d5663f755c3baa0c3708f2e7fe47595627025ba3da8654b6d6aa84a174586dea820aebbac9e8ee18b997358f58dc20e042edc6aae4cb8c77a4ddcd3a83406f4800399201804ae656203257ad7739c2954bf15a619a64098e76f6ebf4fb6a83e2855c9176b5209d628a6591dffa27fdf0ea2cd5f54bef83df0a80d841525d6b8b8d3f63f778661d20d5f437b29aa4a7b2175464c5c149f34dfc7d53d0adc46a343d8753608370114135c916f432fa1325cef8036657be5c9384100c04d010d6696b1b5d6c47c77b01f405c49351a28c0a627e560b728287503455f682438580c091ac4de8c6d9165dab03497dda200c09dcddd03f106ebdd8bb0b34e9f396853b02b353e9b80790921140d3d138c377cdd2052edda203e92bda869b56c3d4a73f688dbfedf94aebe85eafcecdbfbfde38b0fe4e1650a42d6f40010f8ddf7b71b05e282f3aaf4e7c1f929a16b4ee284b39fa79d72c579b5f9831500668c94d9af533e3b46e6c3fa7e831292c782519c4353d44f39c0c5bc18ec8a2d31bb3619f6c7b7bfd1eaab1f0c9829581963692a5e49cd09af7eae3c1075a4453c9d8380fabab9cf0e2a56ed4e5a2bcfa0a779d096c96fec4beb5dfb6d9c7afd05c8242f4ac2c10b23fc1fc13bf805ac6240a296c7ea3d1f83d2d82d926a4ebd420442a9ac0cf6631bb18d2469ab6659e7fd68477452482750bf6286546778fcb706d03ac62b3cde2983c51dab26bede05aecd149009cf1ef0319fcd1d8768ddc9b1b80ff34f93789201b56b8e72375822e5fbacd2fe34b4a419509da4ee05891ca075b50c9ba285bfbd46c738c0e6e6ecedf8081d3789db8444134754e7a8a72ca709c70a5cec5b0952a8f3eb9ffdeb4f9c1d2634e40825c8d7c501f9ae31db9fdd35c7c52688155398365a58809edbe8ae727d0ea367418dd61fd504ecc250800939aedde59832624fe995dc55c3cd50156e0c6a46024bdb7dc106647ae1f80df2a796593a2fb83416818546772401fe84464e99d34efdaedccc06f9ba169c2586a4f01b55de01f732ebcd82876d00fcd5cb2df3adcf17ee8e836ded79fa314ad49767676ea4e4bcfa652697db17e2c6b2bc4dfa1054f31ae1b323fad2526e2e34ea98e519dbd8238cfac537b11e62379fdbbc3af399a01a7806b001d6220b07b9d6663d1590e10d4abb476fe585a115c73256b28347a5ca79dcd9d082aa39c54350f601fee284abbdce4a61f22dc3d7dcb9c09f533b5525cefccaa4e4d8a2175155d21eadd55b02c9ec332ed2dcda74040ac7a141b7c88e9d70928f103fa9fc38e6174a701c212d881294aebbcaa3d341b68548f9d6d53d9d0570b6697bda0ca6434d37560019d126c4c6c2a77cc4ad976d4f29bc859c5bc3b21b172d50414d49c282480332291935a001797d8b34da5db5d1220a7c42896f97bf5ad3279ee2fa507d678f8c9ee75bdf441f52c33500e74dcb5cbfd3d5a7adbe6a4f1af6c0953bd662fce274c9642fc006bb3486faa28cca7ff827c0b1d5414b8f34802550842798aa7d5bbbdb6f25e32e10b2e2e085059c43a87e77cb20cee18c5e6345b05c0393d2ecdd7176bf06142b3df3785590c75a16c7367547385f23db1c0842d422176fd7611f24f8582ef45c5c079385d740c553ba33fd67ebfe771ea88c1c39bfb277f4b5482230706152f9754bb5f5929ba63cf1bac03de34462c55886de12b2a62be4d55e56371d5bb93c66ab83b77a8acb879056ec8f310b982d13ac3a5f1acaf0df11de122947d6366b1a88dbd6c724216cbe8c231c6b555b7b4676c705472dec3a930f37c20940b58c37e56c50e3a84a0833bff1ab7adbcbeb217df6b6bbcee890fd2547590bd957c117247dca325377991a0a9f509a182c2d898888fa8a3125483177bf8312382b16b6dde357790cfaca7f605ac262d4df2eb0b50c8573d0075c13cf71024c06a872b4e00f1f3fb9df3d22ff47a9e9373a5fda813e160313d45b5e8d1a0f1249fb03a3f94f832e3ae2c7a7ee9f2c40dae733f63b661647b4cfeb625998d487a524df6915c102127cd40dccc662dd997a844c62cc8dac54aee4746d821d3a19f4eb2c28040c6c65d5c89ac65cbb87847eee2c78513950c5fab2e4d3f118a4c243556f675a19fb09e221bd510786ca3f6e602b338f5a1371e0d1ec44bc6d53bc2dc188401fa1ce268d6d1d663e3f80a11196cac99bfa01447dfc70ce47f77397f3084e58fa9b0e2c756147cea819d6de5a1c82ffc3a2640fa378be5292a448b9800050bb6dff6e8da6401db6f2869e735c7d4a4c24a58aef738f714e9a080054821ce4a7c875cce8102dd620e0ecb47be88febcf4ad71264765f946945ae61b168b37b680fbb952cfad0993252b23e647e9fce6be16cd3b06082483b8b9f8cea96e7709baea7b4625ef18673dcbb646156ad5e23bfa2c59c3e245efd804e9c9251574f54ce1fb9bcf59b1e6435d7bfd6f0c1e36beaf60eefe9d3a31a56502c525c387fe20dfec6907cfc6d66da738805b37d9b9300574fb1689161051e0eba91e0756c9e5d2a38af494705f881f1aa3f8abc92285c999d589e35c0d570da53d71bf5ed5e82d0b4227c9ef3ae4dbb433bc8cc8f9145649426ad05fe65bd27d52efaa5c2dafaa940cf86b59298f4dec5927b789dbfa7c1c17e58eceb0f947cc72a71d70ade5601933821ba09e6e2180da417475c54b8b48021625cee2d06e1ea9ade546289be1370cfcf684b50011ea40c287bf1427c2ede819833592297e7e4750511f9433a2652a06ae028cc51570015db7b820ffd891341f17541e052671db7e3bb4b5937d3f088f2040bc50cd4a00f6a28f357c04977b6bc48677819b1f3cb3e0dcb2edf60b50a5fd44c26c0f804318cd1460fe8c86fe096473a445cef6b2a797245cfeccfaac6f51814180ef52174e6ced7b69c038a628c109a90bd1ae85047c9ed406581c0419f02353a2c4551afadb1066a5a13b80d05da72556cc9be456b52ac3168568359cf14bb422fc43fd2a0283ac86057c8e6d04fae7da44a55defb7cf0021eb31401837c26cbb861697431afa014b0fb021f75b5b3b5d2378320f76a114f4495751e5d6713e64fac17af1bc5c5db9295506b007d54c0b02f3f0c7b73fde11127927b9d39c875e6b615fcd113af85a8765179df1b6a7c6e499279b45a33153a4acc8c9f9e0d5c4af3b8c6d172891a65a09b1b97794c254c69ae4031fe6d6f1160b40cb0c7bd3a9191afe5a73275cc068f91e5c31605964f8967609766b49694c0adedeeae105b8276f5d9dd4a8c2a464dca23249cd77298fed92e523ca0639078d28d1180eaa3d3c46742c1701863e1ec6dd4f6fdff4317c5ac8d30114683a08d27e51a2d79c90927a498476f55f6844e64b249f9025838fc478c3e82aa90f8c7b9b2226fa2553460ce503e960d443230ac7de437d811e4a4f355c6a2d87907ccc042abad124bca87feff64b357667e996393c0e2b5b01d3ccec3aa1141f27b5b4a1f37ffdb02fb04a2877cb13092c10775655763fc663f3f1a080f9003efb008dce6f85e3845c320c939a363c87e569e683154db45b8cdc9c732e67acafabe01fa582d1cf75011a0cf6059efc847dfa891839a2e0a3fa38a2d02ffdc8259a5c4036d7eec085170048548e0ea764aa349379bea75073433b28d0cafad7aad24e8dcc47bf27dfd1d00a99b0167c4954424df12f45b3439ce1f52a5b8a08c088538981d84d50a44bf2b2ba0deba71037cc7233d0924ea315893069d69819a655e3e86cc63f44073002e9b56a6701d8896172651fd210f62bd2240d83e11244f325c9cc0254ff747189dfb467d5ce0fdc8c25de56e3db61ec3af3232d56ed0b17dff6fd732707db966a09497345cbefc407f8031f666e6be9fdb4441bf94156da764b0b19d3c1803f72c90072c11c1b133836dd23be400667fe5ea1478659b5cbf996a234a103d0d2d6fca705289d29ba6daf99cbb182c7d45b0338f37b6fd67f21167843a56e5ad6e38e10ea35eb29b4b95f52cab8171deede3bd7b2833675cd4ec47f6a383786c32f005d9062a2e62ce916a780cd911394d934020289c2f068d7b25e4a90a18085c974ad232e45a8fd15ab7fdbafcecaab94952ac68727c057924e6c361acda2216a56581a7","raw":"---\ntitle: CYOU学习笔记\ndate: 2019-07-08 22:26:11\npassword: 456654\ntags:\n    - 工作笔记\n    - 游戏开发\n---\n\n# Note\n\n## 一. Unity\n\n### cache server\n\nIf you switch Unity from iOS to Standalone mode for example, the imported texture will get a different hash. When switching the platform Unity calculates the new hash of all textures and tries to download them from the cache server. If they are available they will be used, otherwise it will import the texture and upload the imported result to the cache server.  \n先算hash值，跟cache server上的比较，不一样就import，一样就download。节省时间\n\n### streamingAssets 流式加载资源\n\ntodo\n\n### 多个场景叠加，大场景处理\n\ntodo\n\n### profiler\n\ntodo\n\n### API\n\nScriptableObject的优点：\n* 把数据真正存储在了资源文件中，可以像其他资源那样管理它，例如退出运行也一样会保持修改\n* 可以在项目之间很好的复用，不用再制作Prefab那样导入导出\n\n看了下感觉有很多东西都可以用它。之前的做法一般都是[Serializable]一个class，然后在面板里配数据，做成prefab，但这种方法没有上面的优点。感觉今后如果有类似通过Serializable + Class + Prefab实现存储数据的想法的时候，都应该先考虑下能不能用ScriptableObject做成一个真正的资源文件。\n\n### Unity的各种意外\n\n杀毒软件的锅，卸载就好  \n\n场景贴图丢失（紫色），原因是svn导致的meta文件不一致，revert掉meta文件，让unity自动从cache server更新一遍就好\n\n## 二. 语法/规范\n\n### lua\n\n使用闭包，可以避免动态编译。\n**闭包/闭包组成**：外部函数+外部函数创建的upvalue+内部函数（闭包函数）  \n``` lua\n    function test()\n        local i=0\n        return function()//尾调用\n            i+=1\n            return i\n        end\n    end\n    c1=test()\n    c2=test()//c1,c2是建立在同一个函数，同一个局部变量的不同实例上面的两个不同的闭包\n            //闭包中的upvalue各自独立，调用一次test（）就会产生一个新的闭包\n    print(c1()) -->1\n    print(c1()) -->2//重复调用时每一个调用都会记住上一次调用后的值，就是说i=1了已经\n    print(c2())    -->1//闭包不同所以upvalue不同    \n    print(c2()) -->2\n```\n\n访问外层局部变量（也就是外一层函数的局部变量）并没有访问局部变量快，但是仍然比访问全局变量快。  \n除非需要真正动态地执行代码，比如代码是由用户输入的，其他情况则很少需要编译动态的代码。  \n\n'#'不是获取table长度,是获得一个table中最大的数字键值    \n\nlua中的面向对象:    \n\nmetatable:Lua 查找一个表元素时的规则，其实就是如下3个步骤:\n  1. 在表中查找，如果找到，返回该元素，找不到则继续\n  2. 判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。\n  3. 判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。\n\n__newindex:当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。   \n\n判断table是否为空的方法\n``` lua\na={}\nif next(a) ~=nil then dosomething end\n```   \n\n**:和.的区别** \":\"可以理解为作用域\n\n数组第0项是nil 从1开始\n\n### C++\n\ndo{ } while(false)的作用：\n* 是经典的安全资源释放方法？\n* return early 的一种写法, 多个 return 会使代码变得混乱, 通过 do while 进行流程控制可以 做到一个入口 一个出口. 而且可以避免 if else 嵌套 阻止箭头形代码的形成\n\n/#pragma\n* /#pragma 用于指示编译器完成一些特定的动作；\n* 它所定义的很多指示字是编译器特有的；\n* /#pragma message 用于 自定义编译消息、#pragma once 用于保证头文件只被编译一次、**#pragma pack 用于指示内存对齐方式**。  \n\n宏定义#define 一个应用场景是跨平台，根据不同平台给统一的接口分配不同的方法  \n\nint类型的与或运算 是二进制形式下的运算\n\n### C#\n\n位运算符：& | ^ ~ >> <<  \n应用：\n``` C#\nint average(int x, int y) //返回X,Y的平均值 \n{ \nreturn (x&y)+((x^y)>>1); \n} \n```\n\nmap hashmap pair\n\nuint和int区别在于正负，int64和int32区别在于范围\n\n## 三. PZ\n\n### 客户端资源管理\n\nassetbundle，axpfilesystem\n\n### 导航系统\n\n1. PA客户端（也就是我们的客户端）用了UNITY的一个叫A* pathfinding project的一个2013年插件\n2. 天龙服务器（我们的服务器），基于点阵的一个A* 2D导航算法\n3. Unity本身自带的Navigation，Unity把做Recast的那个人收编，基于Recast进行深度修改的一个导航系统\n4. Recast，一个开源的导航系统\n\n### CYDynamicSky\n\ntodo\n\n## 四. 功能\n\npanel prefab必须放panel文件夹下  \n逻辑脚本必须放同名文件夹下，文件夹、脚本命名都得和预制体一样  \n第一次点击头像不会clone出practicepanel，显示有**正在加载500，第二次可以，关闭之后就没有其他ui了  \n\n保释面板注册什么事件？\n事件是在luaevent里新加的 OpenPirateBailPanel  \nluaevent里字符串的前缀大写字母含义？  \n注意 \".\"和\":\" 的区别  \nUIModule下 modulename是创建panel _G.Pirate_BailPanel = BaseUI:new(\"Pirate_BailPanel\") 的脚本的名字 不是pirate module   \n\n问题：onevent的p_param怎么确定第几个是什么含义的，在哪儿约定的  \n\n[Lua]ProtectedCall Error:UI/Pirate_BailPanel/Pirate_BailPanel:37: attempt to index a nil value\nattempt to index local 'script' (a nil value)\n**原因/解决方法**：open之后panel不是同步打开的，也就是说open之后的逻辑执行时还没有panel，所以getUIModule是nil  \n调用start时，panel加载完了，所以把getUIModule放start里了\n\n看bagmodule 了解如何获取icon：self:SetTextureRes(uiModule.List_Texture:get_Item(0), BagModule:GetItemIconById(costItemID))\n\n打开tip用哪个TipsModule.EnumTipsOpenType  \nEventSender.SendEvent(LuaEvent.ShowPublicTip, lang(23010));  \n\n时间：需要xx小时xx分xx秒的，还有浮点数的，两种（抛给外边做了）  \npublic tip怎么显示两种以上的材料（策划决定，改成点击图标显示tip了）  \n\nself:InitItemPanel(ctrl, go) 需要gameobject符合UIModule的命名规范 之后就可以随意改了\n\n需要物品太多/或者没有 怎么处理？  \n\n**修改**：\n接口就一个time，内部转换时间，算所需物品数量，回调都不用了  \n弹出框读表得改，icontexture、qualitysprite、背包内物品剩余数量 有新街口  \n\n\n## 五. BUG\n\n21196\t【主干】【bug】【主线任务】潜入亚得里亚海id:1000107任务文字覆盖   \nbaseTaskAndTeamUI(Clone)  1000107 已解决  \n21235\t【主干】【bug】【主线任务】潜入亚得里亚海id：1000107  任务副本的大小和特效表现的不匹配\t游戏bug \t\n美术素材原因,已经让策划去向美术提需求(篮圈大小)  \n20881\t【主干】【BUG】【船只航海士系统】航行事件升级，提示的是给玩家增加经验\t游戏bug\t打开, assigned  \n客户端C#和lua搜不到strid 110129,在服务器代码上\n17521\t【主干】【BUG】【航行事件】航行事件图标消失问题\t游戏bug\t打开  \nsailingevent 预制 功能取消不用看了\n\n\n## 六. 热更\n\nSLua、Tolua、XLua和ILRuntime  \nbabelua生成lua脚本\n\n## 七. 服务器\n\n[游戏服务器开发所需知识点总结](https://cloud.tencent.com/developer/article/1349061)  \n[TCP socket心跳包实例程序](https://cloud.tencent.com/developer/article/1342680)  \n\n消息协议,共享内存和数据库   \n一般来说除去所有的显示相关的部分，比如技能特效，施法动作，伤害冒字，UI等等，剩下的做到服务器就可以了  \n\nselect 实现多路IO复用  \n\n消息驱动 再看看\n\n## 八. 压测（Locust）\n\nrun_master-->run_slave-->GameLocust()-->action-->消息包  \nI_sailing_battle.py-->ACFSailingForRobot.py-->PACKETS-->Defines  \nactions中的__init__.py中需要添加ACGNavigatorOperation  \n\ninit_context 什么时候需要？航海士测试中不需要  \n\n### 航海士流程：\n\n* 玩家角色升到50级\n* 造艘船\n* 拥有所有航海士\n* 高中低经验书\n* 一键任命/两种航海士升级方式/使用一个航海士经验道具/主舰航海士一键升级/万能碎片兑换/航海士碎片合成/航海士升星\n\n积分商店流程：  \n* GM30000银币（交子）-->买一个木材\n* 请求商店列表（ParentId，SubId）\n\npython 255用byte接收是-1？ chr(255)  \n\n不要在handle里（接受GC消息）直接跟action做交互，self会乱，无限递归？  \n\nFunctions.py里为什么是\n``` bash\nif packet.__class__.__name__ == packetname:\n```\npacket.__class__.__name__是str而不\n\ncovenantpropert 契约人信息  \nTroveSkillMain 发现物技能  \n\ntrovemain里有寻路坐标场景id\n\n### 发现物流程：\n\n* 激活（解锁）    满足前置条件\n* 线索           PACKET_CG_CLUE_COMPLETE    1\n* 技能等级        没法主动升\n* 签约           \n* 发现发现物？    PACKET_CG_TROVE_FIND\n* 待完成契约      \n* 发现物上报      PACKET_CG_TROVE_REPORT\n\nCGAskTroveData      --      PACKET_CG_TROVE_DATA      =   2453     请求发现物数据\nCGTroveComplete     --      PACKET_CG_TROVE_COMPLETE  =   2482     请求发现物数据（包含撕毁契约）\nCGClueComplete      --      PACKET_CG_CLUE_COMPLETE   =   2488     请求线索完成\nCGTroveFind         --      PACKET_CG_TROVE_FIND      =   2512     请求发现物发现条件是否满足\nCGAdvPointModify    --      PACKET_CG_ADVPOINT_MODIFY =   2527     请求发现物冒险点数更改\nCGTroveReport       --      PACKET_CG_TROVE_REPORT    =   2700     请求发现物上报\n\nGCAskTroveData      -- PACKET_GC_TROVE_DATA = 2454         返回请求发现物数据\nGCAdvPointModify    -- PACKET_GC_ADVPOINT_MODIFY = 2528    返回请求发现物冒险点数更改\nGCAdvSkillLevelUp   -- PACKET_GC_ADVSKILL_LEVELUP = 2485   返回请求冒险技能升级\nGCClueComplete      -- PACKET_GC_CLUE_COMPLETE = 2489      返回请求线索完成\nGCTroveComplete     -- PACKET_GC_TROVE_COMPLETE = 2483     返回请求发现物数据\nGCTroveFind         -- PACKET_GC_TROVE_FIND = 2513         返回请求发现物发现条件是否满足\nGCTroveLevelUp      -- PACKET_GC_TROVE_LEVELUP = 2487      返回请求冒险等级提升\nGCTroveReport       -- PACKET_GC_TROVE_REPORT = 2701       同步发现物上报\n\n问题 发现物状态m_TroveState在那个表\n已解锁和可发现什么区别  \n主动升级技能 签约\n\nsocket errno10053 别用waitforpacket_with_heartbeat 用waitforpacket  \n同一场景下（场景号相同）只输xz坐标是瞬移\n\n发现物上报需要npcid troveid还有trovestate符合要求  \nError! packet.filldatafromstream error  \n**原因是python的list不能直接用索引赋值，只能用append加值，或者理解为给第i项初始化**\n\nGM指令在游戏里能用 压测脚本用不了\nsharememory说trovedata保存失败\nUI\\Trove\\DiscoveryListUI.lua 194行有nil 估计时表错了 但是没更新突然出这错\n莫名其妙换了新号就好了 清库也没法测旧号了\n执行到后半段必定10053掉线，不知道为什么\n**因为前一个action消息包发错参数了**\ngoto 传不到港口了\n\n### 无尽航程流程\n\naction：\nACGAskHeroTrialsChallenge   请求进入挑战\nAGCReHeroTrialsInfo         玩家挑战信息\nACGAskGetFirstAward         首通奖励\nAGCFirstAwardListInfo       可领首通奖励列表\nACGAskHeroTrialsSeckill     扫荡\n\n前期准备：  \n  升级99  \n  造船两艘 指定副舰  \n  切职业 提升攻击力  \n  补给、船员、疲劳度 \n流程：\n  状态机：战斗状态和准备进入下一关状态间的转换条件\n    发请求进入挑战包 进入战斗状态  \n    计时\n\nwaitforpacket/withheartbeat//socket.error: [Errno 10053] \n这能都改成waitforpacket吗？？？  \n不用改成waitforpacket，问题出在\n``` bash\nself.person['nNextLevelId_current'] = self.person['nNextLevelId'] # 写反成\nself.person['nNextLevelId'] = self.person['nNextLevelId_current'] # 了\n```\nAGCFirstAwardListInfo 总是false  \n登陆时就会发一次\n\n### 世界boss流程\n\n系统时间需要在指定时间 开始时间是12:40跟21:40，5分钟后刷新BOSS，35分钟后活动结束  \n测试可以改系统时间触发活动  \n\n造船 带附舰\n35/45/55级\n选择职业\n根据等级传到指定场景坐标\n打\n\npip install pypiwin32（不改系统时间了改表）  \n改公共表只需重启服务器，服务器复制的是客户端转表前的表\n\n世界boss的倒计时要看服务器时间，什么时候同步时间？  \nhandle 在functions里加handlelist  \n\n### 好友流程\n\n一个client 五个otherperson  \n登陆-->搜索-->加好友-->查在线状态-->关注/取消关注-->拉黑/取消拉黑\n-->创建三个分组（最多三个）-->加人-->删分组-->删好友\n\nsendpacket出错是前一个发的包多传了参数\n\nACGChat_Friend直接用起来有点问题\n\n### 商会流程\n\nGC包怎么传参数进去？PACKET_GC_GUILD要一个self['m_PacketType']  \n0822 做禅让和通过的消息包\n\n## 九. TA相关\n\nhoudini制作HDA/开发HDA  \n反射探针（Reflection Probe） 合批 batch  \n\n\n## 十. BITool\n\n数据库相关  \nexcel-->sql/json-->建表/拷贝json到pattern文件夹-->C#代码添加json-->log文件放入path-->.net工具导入表  \n要给什么赋默认值 多半是json出错 数据没进去 所以需要默认值  \nfleettask有个数组越界 像是日志项数和json不匹配：json54项算上时间，日志里只有53  \n语法错误要看具体sql语句，fleettask这个最后是,) 就是excel里多了（红色的是没进服务器的） 服务器（实际的log日志里没有） 解决方法是先删掉excel的行  \n登陆点的log有错 开一去查了 先跳过这个  \nexcel里有cylog里没有的是测试没跑这功能，汇总给开一  \n替换旧的json/sql都得替换  \n\n不能为null的是因为策划表里能不能为空那项不对，手动改sql not null那项  \nC#脚本bug：log不能正好是十行  \n\nERROR 2003 (HY000): Can't connect to MySQL server on 'localhost' (10061)  百度有解决方法\n\n## 优化\n\n合批优化，GPUInstance优化  \n性能分析工具？帧数据  \n合批？  \n\n## billing\n\n# TODO\n\n框架层 线程模型 网络通信模型 跳转 线程安全","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"抱歉, 这个密码看着不太对, 请再试试.\" data-whm=\"抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.\"><div class=\"hbe-input-container\"><input type=\"password\" id=\"hbePass\" placeholder=\"您好, 请在这里输入密码.\" /><label>您好, 请在这里输入密码.</label><div class=\"bottom-line\"></div></div><script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"3215da396e98560e38f78dd93370db18f9ca1c87185fdecb59c484ff5131017d\">6825f6a083f85570bdec124205b42d562a608361c1e800b895aaf4234d0124e548220ff85bb01031d1226bbdbf6eb6e46970542b42bd080ec4eab74b2897d0b2af805d52b4fd12d3024339c3e764cebf9d885a8b108d08d5992f6a831350da5d04665ee3ed4068f43e078bbb9898123650281661b78a39471c81e624fc3e12ae30a5edfb65ee8c29044b00885f631f8967f35139599c7fc0f91e11f7d6d2b61fb079c1a335ebda8946e59f3b77dc26896dc4a5434d2eba0762cc60d0d6a2bd4d9950cf13fb92b4c4faa59cddefba4d5becde6ef1a9637ee978fd6afd1735a9d37de7ff16f28b04a88d6bc2f7409d47955cd04b7fa85d8133b8899106085ac143c631982fa596d4d7c7f44dbefbdbd07d6f2f58016377c37ed35cf0fde923f93a436446257283b0049b3562f223e494c60d705668dbbe11303acaa5d95c8ded301a9fb3429575cd5dd7abd02e2d31b7b67ede107f4bb7078539601159ea2cfb185557b1b5e051f5fd373db228bdaac404fb78c58c64fefc341253ced94ecc0cd470ae4c9c0636359692014185eddb4d45545e824f04bc1960855bc473127d8ab2fd9fb26fec64e385f283d4498eb6ee765e560e4ae3d5493314d9f99560deed82be7b277ea6d5afce40f2ccbd9f70c58193611e5a6bae3cbe918aba6e7866c0c274fd2985cbbdd6bee1e0dcaab206c2792ef5c4401d7b764d0c6daeafb46a2441ede8cc35508f95cf0f83e20e5d1f1ec5caa13b7b87c865f3b39649da160a39d646cd6777211871139a7de583cb743b5ca92e1937a67e31582761a9ab9f1924d29738cf2f405c4e487b0696e01862a22ee63f98234d8dc5b5181c0a4b355965b3bb201b3594bedc0c2c0584c068dc30ac17b87c2e5d918f1a4d29d4f8e4defa6004c0e66a1725516293117756a1c0a7644d51641d4c901c0d12f5f45825322e4aa25e034a3e37706d5b8ad9980b1f410936b436280e1d1cf4187d17e8a68ca6995c9375602ee2ccc4af012500787888bd2035263bdc7953466642c01ecf1adaaafdc289fa1b8853904c463df595dc2f93827e549927c18c4e528e261e515044eed320e0caa1bffadd50acb669a405ac5a5dd6ecd2cd7afb6eb311e269d8933c1431ea250ec00bd4734105ae13e9d3699d9e7a007660e7fbfdb2ff07e45aa5c185ed5d61cfc75f72957ba83029235e8bdb119a217161e39c0d814f0f14606c9b21de5b234d21eb5812c31ac03f93a86e9028e665a5748cd5d036dd99522870ffd812183eb7c3bc43c997e759d8400b02e073964dfcff2858dcc4fc85158b6a276bc2b37cdd581e30b14bccfa9eb9ce2a265eedcb960bc9ac3c29991a458d0b7896dbfdc1d4f6ff9cb19328053c3927d1905db3f0a5fc1e9ebff627f24283264249fa45e9689cfea1efc1d1cf4377e388fa42d3653bb72caa28623c5fb54aa4b03179bd7690148535c8e615b6e28f0c1a8c1388599768343cf8ac0de90fa46699ae6ffbc58d9f6a6c6761222b31f88cb01fba60fd8d151a373c8a04a817063d14bbf9f1322febddaad0e5a3856673d50efe4d0ccd129c7ef066672ee37a079eebaef74967e4b193980a2ac10cdd883f4cfaf072c1134fe6819bd7757401a11ec7c7e47b3a3f765ccb0e7971c12b16f596bd1b182ff57711a8fa59b9587432ea255e97d45c3788cb223a3d648d4ed4d8b605c85527394305dd19f587e46e7c35a0b48d1d35119bbdfb938f11e287dc9a8fdeaccec4a553276458fc1735bcf4d4a34540248afd18ac1f4d17aa23a36d2bd73f9c9ed4e54b53724eacd51f83cbf77f061b03892bb463a1efa469a96d8ff80cf869bb4c11b93c4fe3398fab2279ee57b50a1d33e539036b200c7fc1491e784360679e52743be7cee67cfb708e9e314b434c0ee8823da04753f23aa2d045a2e2ec312530ce52da530a7784ce71893a88b24525f60ceb65e668ac3545ffeb20e51a70f264dd937dd189be1ba118cdd3d8b186a8fb7d67043abf753357c2f5d3220782e0af6c88906140d12099a26790454c756243a8a94cf357276fa143764249d937739db55964aa8c9b644942f1c1ec093dd58d3d42ab88a4da12a818f86ea73fdef049a6ca5e5fca4e9412487ee95c148f22afd5aa1fe30e09ffd1cba51231883ecbd5c0ae7fa81aa8ace9ac96cbd9a2f75ab3661e7740862d8eaa5f3e50cd2899a37e86c793367419388d7a4211d527a0051351e4e07f3196dddab977d7aaaf8bbe974118aed9bfbc0324ef60876b87ab9a4445a405efe88ea6d39da8ccde14df1f2a0bad51023a700f9ccc03d72aeb8052aef2dc89d415040cde71d4e816fa588629b4b2e1d4399466d0973975171e557e6a02786b7467c1a109fddb71521f122e7d45f69f9b8cadde4b2ddc068e997a76566b27a0060c5efcea1a4260971f1c11398836ce913c747215c65cf7e3ffd77ea0036e969ca50b32138bb821b21bfd623f5b1ddc20304f2dc4edd1bddbe6d5e8ea11a4adb24b2053d7eaafca4a7d34f7c1802dcfe19924661357be440716366bda09e78c11f4fa90d67ecb62c19235743ff8b2cc01631ca9bade44254cde2a757a9dd47b9a101c25b27b471276b72fe73221a5bb916a308294f941a45f18be080143b510e69b50b87c8026a298e277e4ef1bf4aefb4e008adb859d7a34128aa28916ba85263a557dece574c39978393e5578b295527192a1c8051d534b9e57093bcf4d7196c54f3a7012474ce527b87a1b8c4980e55a5631d1a4eb36e42e1d2a88bb4d85d0cfd8a90f201f9209d01839e37d75b5aed3d018b4c6b78f6ed1d74a3e14fcd2c67faf186655d8bb88f4c0c1fb56824cafd34a7dcd1bb5ae164557c4e80e72b1051153f06155d51542de4fea2bca5b4504d710cc03f9335e624a3829adae7e8b74ff1f789dfecc4b791cba636b9cad25bd30ef862f40a5e487edb315de7e1f630baa8369baea809ff6e5b959b48fcb03a7c0fd064abb6ea74f95b52c92721709cc73362c648baae25431d999dae11363d5154538143720d0796461c998e50ed9fd42c892de3c55184b3d6fd825cf59eb7f09161233d5d21accc825ac02ed3e6383ebb9fb8446ea47afd10a8b2785df0740f881bd9655fe5167d13486440cfd6cf8adbd5efdb88a204060993b766a81c88543937939570f4eba4d4aa9fd5ff0157468d5f80fd4dcd9ab37070663f81213e2269b577ae00a1bcfc3d92e1ee9646446176ca5c2a150e6b6f5072936f6f7c9a9196268608961a5104f0f3ef143ded33fba8efc2e891c0334869d2f20ea6acd2b7e0133343db19d09daca59d95517b1c430bed5c6890d24c239aff7f76ea90678694a9b0b4e466cad9103fed80317b5adcc20c31ea6e3a899a6b05e4cb50e61a075462ec3478c461b81a52068ad61cd9987df331f3a64935f3f391a6f26570f0aad04f9d99d5da33add25775a5d2da382bf455e5b9347d190f8a4e3f532e03ea26fb564a9b7d771b7e1344b8ddc38a242e296a30d6971f1a822899b70048bfba6490e0c6161e439b0474f34420256aef3068eb1ecb053e2bef621cfae83937787b0e448e7e242cda34f2ea8ad6a462e71fae9b927fdef296e4071ae0ad5dbfc03cfe25e8cf69527c8b30930b031b4028b28fa3338e1b461083a9f9068e3ea2e7c75b3ae7fcfb74f30dc50ff2b6109ea3b44ba557a9ba6c83b56f8ddb31df09f40ff18efe9b4164db08811c85cd44de05f0c764fe370029c4f8d2926f54f78416005e24062074af965bd7b20254be1071b34c2306d7e5455f74ecc4ab93714a4ddee8e5f41759bbb298fd56576fc74892158b19e166563158dec2616fc7716e4b45bea043dcac7dbf8ea9a35fb30bdaf80c20fc4bba8f8248f219a0ea52b316e8b226eb246fe3c0b97ae8271cce21d288713f55079c8891416fa17414c80987c05d7f4a98f8a1d45cad4eda72d44de8ccd2d69918a05e2938c8ab8459b90b3d3e7c2303a58deabf55e5252b6d323fbcb3584919d4cbd4b46638a0daf5ae8814dca17774cfe9a8f0c3e0da59feb8ef170c72c554e498f794a710cded28184d075373d694f41ff6ed197302a95ad8f52daf4e3c8968ecc0a94294da02f58de74e78d11837b5bbc45470c96faa15e25aa811df97560791dad777e1e227386c1fc95d8d2137172d6b3e971df16d7aa96ae199ad8b1bb95481ba901cd962ffc5a9b56b0ee0c455a3155443fa7c6643bc92b252c1fe582afe6f5659a6fae2141c6a360912b5294b12bb625fb04428eb27c8a38b5300c45101bd3d796cef0e36b290b232e391636ae73063359060138ea74b52a48c20a81c66c420e2856360b3949c7691262b582017583aa60b617e70da42a73c2ded35d1f10d524ddfb8eb04d0a894d22adb4e3f19d2116dda86769e8f68042385d3ec16b6ed89e1bdaae0810f73682b23b66d1798b96331ed8a40640566740b739f807e8b7a7ae8e320d8141c9c5247f400faa91d1b1410e483ed16c3d5dfad308e06eed53601fcf08c4f0133d83c635ef6b734bb4d6e2c22ba897f3b9f82219956859644b39e80a2fa3e4786eed56fb54ab8b18988d93f2107ee5068a5e524da3025b8a7cb1663ded9424dac8e951f736121e98c1824c5c1b52ff979545dfc464200cb7d630dfc6344b9e5e1e02a6c9f6b354efe9ee8c672858c8c2e6a7e0fd27e13b8470a5e82736f811a19acf5508843a94be7f825b3e32928d42f81e59ccfd5b66ec359a1c07c4928696630f1f69bd4096948fe143460b2ffe464fd0df204cfad518d14edc9b8ee746f7346e443fe27074db458e263e8260d24c232c7288d7b5204defc4e5361c63d5ecc081a16b28ce30e016ff60ca133738ec86daba410c373f56169b192c63a6c06e00957006c656e54bcfd30902fa1282d36d0b53ef4a66366bf86969094fc18a045168af131f49103b71b5da0e2fe368eca4164f83b7916369e456e0a1f6cae5fe3660353fe928e89b2addd85fed0b113560c82879e2bc4e68b35dcc46143687c19316ac597b1d1f45acb3e6371d24dc3d3ac8bfb4adfa3763b84c02414f05e17b3f2f542fe1d31867468a3bb5d092b70c8d6f219c8403c4069d16b1c0eee50b450d0289b1bd8275e43e439ba29b9d3ea8ac08815c21d02b7ce69286a0f24ef8d950fe6cb390d76f8298a5a6194e9e3477de5509ec2bfbeab657489cc8cf8f1dba1beb670344c00127356f8d9fdd26f89865b9cfb7daf7ec6ac31e69cdf1168af4c229c0dc99e3e064732b09a82f44bcc52252099c451541f8fc1f70ee943c4e7bcca92c6bd1fcf7651a90f424f991ef31ab7f3b2a5e3c6853e886fdcd1fc1aed7a68f4126b38f2b2b2f8398c1da8f321a537c376f9ac04bc3be38e6bf5189d4bc8a83ed126e977c425a6a621f447f3b5125c75fef5484e3360d8b93ef9ff34b6f9ac17fe4ef1b0ab584d6e41784d209e9a196d88fc0be98f8b3ce87b27bf527bd73e115e95c25f77d4e016a50f2c483bd56a3f07ae599029f01951bd2a868e186f40d0e78de43d895dc9f4f450c1ebaec582237d41dc1fef209673f3f5ea8af2e8516a1529f945a9440789a9a9411f61d83f97bc1091e2017b57e5bbac26ea2e5b13fd0b0596fec5377d103db990d6034e65506b4bbaf95e7707a18724c3869c8efb00db587efd54155dcb62b88ed78fcc664d60dafd8d80f36e3b08b789ce2ba9148881d0489b226597450f2d66b978920ce63f83ab0bd063460f168aec31e551b8d3a902de534d86f966bd86d0011feba66d4eae755d974a04411d3bca8c58b3ea80cf96f3547b1fa38e8f5542d7284ac7c671f08c22613d947fe7f5f1cc211eb9b98994de33fa5d9ab7174afe86d688a43f2295c2a0a675a679afa1ba6e027c4f31a2d9938630c14fb57e682380a846070edb6284f16322ea591289a71d6a69b049d610ba2957ac6af4cea86151fae6a86f7f2ca09571cc02a16757da240deb4bfa01f1980d5df53c293522135f41419e405d1c795707bf5bf4139fd376da06008eb6ef3bb21b3e02a246c17faf62eaf7d07611f6fe1c6f9ebaac0932432af6d5e51fdd67205cdbb235d3821400d489ab2d703ebaca6a2e7816b9125dc158e1a4043bfcf8c6f1a0d2bbae77b197cbbd993ddc32b8e10e77f120d685c1fd7c6b7db91070c4a0c7e12d3474ef8532fe4b7444d1e9ca7263e82dd3e0d94c4ae3db0949d2681e2817cb5ed17c34223de13fe5013e49fee9ef8e3151c8253b82bfb1ba0a594af564acf88376e4824aecdd0f14d39be52ce129ac43f64148dfca717a7bb423afa022a77a0294f7748ab7ed0336a2490f0a8dbe7aceb4af2fd7e2105b589e1c43bc77982ba0253a3db807a293249d55489aaf112cef2549a3e4de168527746764d8301f54219207ee375d989a203b376778424018c658dc944ae651b510554f156525893caa4aa620052855776268ae0f76ba6f207880b37227c923a8fc9746bfdf9c2c3be3b93695f501d91a75babd3751c62d41c0deabcf54e813387cdd18ab285c221bb662a34f140197e8a2e764794022eda9199c58ed3068be881c54fc59e6d25d45f2a3299060d93b40cc617c96f4612a5b59fda4e8501e7068ab6312afe92332bcde1b78809c6452a222e54e2236e9d9eeb45be204a6ceffc083c5a2333dba31ca5adf725d2d38ef3c4a63b4d39ede553fc162b817c5f84aa095c357decaf84cbc732e87873f43e2af057981de081d36b84f96e7b7aa738cd1eb2b55850cb3ecc2be5e7d52f5d4dc1da54a0af4e2ab43d7ebb2a88ebc421fb4e0051d5f766a30e5b8dc71d0b24bc22ad8df3716212974b183b8b8da99b2b7fe7be032e5aabc5cef04486dfbb27f388181b7805235b33c64e7c71b2b0928516a6d29984576246ecc5862d20ad64d0ee27691d01651cc80a71f7cc692634f3474ccb292dd9f68af56c59fd489f4d2a3fb53f9a06ca1f9cb18b53d22c6f3ccf40c4d573d2f6e62db553abd194850d11882324fa12b49acfd5b4a688979b45847cbea96184964c5541b9815521ffd7bdd4f4d83c36b1dccbb3213a0ed0151d1415d26a5b68029e89c90482ab035304ff56d9d64a8d9f1884265261a70c6a3457a833fdc02efc479bcd872bee7c244b6743c6945fbb75bf0cb69cf45f6c99f0fbfb10bba8c3d074b2c48115cf69d1402d4db85eb7c3e5a069800ed7ef4b3644aa1c485b174307b5f53b6889b70da38fcd504a2d05f1141a770bb392b41b8b8d55c84096260378966b19e119ccf322cb5ded8a118cb9444e6c072549cb2a2f0ec3a28a9c02d53e067905fd5846fa4f425c7954912f03d0272c4b1b1e32149e305132f35b7b2fccc28f559bc5bdf929f0f8522047f1b022104978430faaa732c5f53e7fcae97352bf3e406261d6b188d10b7162147a677782e09582642dc1639778a826e2badc6b788e402fb317a12704c1f888097ca4c3be506d3091843c6cee4698dae72759e24335520befc3b07d91832ff8f933abd724f12844326cae915496c6b01c45bd4f635df67c7687510e8091707bb872cc676b3e4c1ae43f9738a2576835e756db051ae177d1ba4c8049081547f4c35163c4bf7b45b1a95ff7f43c9a0949c166085b4dac403a8ec5ef864f4836b9947985c811189ce0ae0ea2a32ebee6ef3914fd265cca96173bb41edb6e757eb7644bfeb3075b60a0764d160340b9ecea4a556b89752bd1e9ed08617edb644d104865fc0c8d011799a963652d622718010f46d2e500c4427060af535fac7d3a154ab827926f9acf0ad6d370b7ed9369801f3c618a209d8b2a5f30771227c4dc2f4522ed0244c6efab773996cd3fb89f6868ff8de8d50aa2d30977499e41fc8a4f32c54375631183e0aac992001fd7ce9382045791fa86aad7a5c64375b22fe894fd945ceeaa3170dfc474d70910fb1d358ffeb09b5db8e875517c8b685877f3fc81b622765deab874ce7a6942eb741bac5f19ba64ee6c4b2542d06c5a85e2972139c26a26834b6def57ee43de411828dc7f458dc5542d31a8f1ce04a76ea71864b45b9cb396642e207100ae7a65c558ab41402c0d7f8578d9164fea31f3f570076c25a994fbc20237f823d95f81db5676f2708cd48868093ef5cb680a0d9e1747074fdf3959fcd7f048f8d85e113367b547ec6f48a2888da2dced113f90e77554a329e8d8427410834f2d4681e3009ca53a430168e3c8da98ce8c0685700be9d175c4c4ef844e5aa02934e049c204bf92d6389c2ca3c4afbe24d38eb114c3f295e0fb9a30a1fde2fc90c8308f3a4fd540d7f3a82325410a93fb4904e85dab75913cdba7872340c6b7efa63b1c239f759d3d881d06097976f5ef48361df6f885950c7293983d9c43f453754c254f90de2b918e24cff959f75b2aa511f978f4f5b6e742a74cf0c534d6280d48575d01bdef04eda37b61be5085970708416f69a1ba60fa100b6a2862c051e2c14ba1183420c7bf5c9bd817980e7a59ee2806219e55e94ab1b79db52760f73196c1c03d842da523565e8e9e3996d47e0fbb575c6b26a9a5b92a084edc050f30c3bb1a77f5755add64a6f6ed22cd6308c3596cd89d38214bf73a2fad9a44895a0f31b1b4140f4ed7dedb3468e69fd4413d3b722451cec620117b64f662e28cd901de53344c7b685782201532ff4a1877319d90b213307fbb4881ce45176f78ed1f6d27be1de998a3a68c62d4fae661b8718612f34fd8c7aed27e53f35346820315b093126a99aec723cc1d2478f6d87593ff5f745025ecb35b59ebd7d0cc244cb6a32bf3c243c8f5160696aa4fad9333cd9c7e3ca10066e243538f467bc422ba9d0fc0093bb48220102372208d5704711ce89185142f0acc25f3f1203d58d0ff44bf9d339ceb449c721358c01c3d72863a8765eedcf0097da67ed27c5381a112a8b8c62442a5e383d59c41a4ba2121df1954fe3b8e47302dc58ac04e01a9c84ddd1f63d80190ceca8b8f51c4b5351343d9f4c04cf46643ef1c83e834f56d963c92f24cbefefbe5889a2c267de796ef91f493cf46381ba255b35a2ca2a7ef676731c36685a9577caaa7ca1153bf8e0a43c0ee69379d1b0add2d60328ad3577283edf3fc09ef748e6c954902f98bbaee8a2a348ffa6c1a73e9eabe2e2809b73c2993df4e41f525d1e4dfc935b9b365e200017e21a7519067164fb7d16c88ae3f7610bdbbafcfdae83c104edde4b2c684c38f688fcc26bf150186f80ecd9d228cd9b6e29a07d1039b8308dc75218cd2f0a23686d0a0d51b347fbfdcc092b731d5bc5e53e4375e0a38cffcd49bcfbeda6d3f9ed934b693d065e029ca9edf5396ad3ce0410832366c1ad4a56ed4e3c626ed3f1adc5c8814989a7c13c503d5b8efa6342da1a99534f576618bc21caf352638cff4f46254c859faac5b06f3f740e99e8913d6b0e294c833c06803560fd012f1e44511d75bffc3cafc0b6876ae94aaff5ab8c952eae30eeac6f4ce27ed24be591e9251b4e5f8180edc3e71760cca0931b54351ee234aecca1152486ebfcbf59a8ed325c66481fa94de5a9ca285156e80bce779f3e0361451face80cd3842ae57319f107984da3686052f5a4b1ac266ef395e4d6ea356002e4c1a109e63ca1a9a6664e16ee532be07a7e5662bc132c14102131d0a52993cbb99dbe82e3bc3020373dcf1d0b30f6ee25b4a1043d2541976409070f75d70b86df96d1b66e181bd82334ab1007466f7d963c058d8a11cd643e5ce16079498d6f1d58deef23af5aa5126f9572372c573230e3b47097d3cf22a815ec41282c2e39372a0b7580d3741570223bebca5f5b28839afe1ac59548fa348f46abd4aadd4ea425ca50a76610d1f28f8850e795de91d651ea83adb8475c8c7335d8f32bb6cad7043448a8a702c178b327c2520789f32adac2ff753a8cd0821c75c9f5897bee0ad61421277677ed64de473eb32852781c5064482fa71c86283fb8941c92c80d1a55712d4981ade92c78bb0e27beb3afd66c2e73a186e4e8af4c5a0f95d35ba83a938607692fb2c62863bf47e3b7e4c7479541b4b97c9a42d9ab1671d18937f3f8862ab16b97338b008d60a23135f021e084d14285001ca540c5506e8e13843f0dd674d6ba55b4ac6c1a85ba0a3f5e28694d414574c8d966c5340eb66c9e3c681eac362c152e73b613c677a289b5ee009ad10db920b57ee513ebe82d5399e182d45eb75c9fce8b6cc4bef3d419bd77d7baab1496589b35b32ceb36a7bc3e18bdb8af13334179950247a9fb77cca573429805f9601cffc3538623edaaff2214390a7b0e8a65d4e03463b4f543f79fbe87108b70a611b6e823dcb5dab79c78c7f9f55d486a81a32cd6fd448b6c2b204fee736c724a33a49ce4a38e7f696b81264c9bc83f9cb2a7afcbb509273298f696ec049d64e4798da28e2b6daaeab9222ac3bc92d27a97f0e87ed6503e9636fa8138a6f8fceed629c9c9df8b493a5add707388e47c05e919c5490eb37db3b4da449c4eea620254693ce8e70fd181b85b550cd8385de319f43a2a5eb9f496c28f97b037cecbfb9d7e6810472356d5f4a8c76d6852138dbb75ceac7f893fd7f3157466b570193b1da38252a165092ff4010fffe76802f7fc1b06a9f80788ecaf9387c1d1c4759b974d5eff373f7dc7900771c01e6a5d24740b80b827f00ab02731ba1b416a99748f89f2aa5470d8235397e9142f90a12745136c3bb25974b10ba848375c02ffdd77e252bb291e138e624f3c2558a6b8b8ef93563680fbb9ea18a4e023eec5ef3388479acb051a845d06256f2d8c46744aa60c584c66bc321612a7c852231457e0d605614e372462b6fde68ff07ff076eba030ae7e24a30315b9e4f9d6106cb88da664bd8ea3da804c5773ecc15b27c3220d0b4edfb135dbaa1f4fda8aa723cc257a55095cf50cb13762a38ef0a00514caaca009f55dce6bc008e246182b8087e98893b56bf07c1667598e86589c70935e2441e165b9df2ec4f7dd09cf87c24a4873d02a43c8437702632222ea32215ab81cb52c5698f07beffeed26844a9fe3860516b56d39871939bd49b9b70e6d665a5fcb400754fde69ff560d835ceb3cf60944d475a821594a2f8dad37ef608b70a497abf20a13f82ada21c44e0468a864dfb758c7449a8d4ae69cd87e2e72e7d21dcdb449a605e2543c9a9846e5a35d920fb99a7b332f07db3c774149c68924534017671d9799ac890d6535378cc1f581cf62f0666876a1b0cc3511ce10ff62d9980044e7c2ab409b68a2f833d54418883df9ec29fb434554a4242ef98e6f0429bc545fdb290fc8c82fa3683cbae5df45961e30d0a5f53e2438e1dd153f4f9bb28921484c8441fd1b55d4a5f60a34313ad8901d853b6fb46b2b48023969c5dae62d550bf620500017b241c20901636f36a5de5037ee580169416c37afa1f456874d8862e85015f3780b2e48f3bdb814c8c9584bdcf2ecc9c2202baac888b8336a74aae52b1e16e678ee8b5b089ec0b57b0f28d5b217cf011dafc66c10068d246deb4f8c9c74904af963f0d46bee4ab2950b8de608bc12eff1f8fa7ddc370ea367139e3cc820e19f6615a1eb980d50d23cfcdd6e2fe4f2f67e72556b5fb28ac75627d2c1f1b8a595f1673292bfd5d697e5576597f17856b230df883c149f4543eca6eab5d5fad2bc29eca1f72bbd7e7ab549bec5669bd83f61a0a4a54a83236a5c2127262dc350f04e1d2865b01c8aff0206bd20e8fc7222c557fdf4565fe24bbbd07da5c07f815fd476ece2ae90e16b69bfa963a15c389b184180e6cc9d29a99e2a51bb9bcfa845d2b759bc09df53b43b21f4ae75a7ed45f48b258b9d32efa9315dfd25fa8ea2db9a59d25d484d655b77229703f64fdf08393bcc7866991093f9ea39cdac5cadf629db696b3c7675d226def058c7c11d1da84f4cb6913580372ce46ce2f62dd8c76fb64331a34201fff7a83a63c1f72bf53acd3c5a2f6ceef4e4415904378b4e01ddfcea7a8aeb4d7f48b8593e4826ed32ea502d4b5a42d8efc5f51d0f09955e75b80db556cc7117cb8bad651ea6fda3ab3a5df1a4e7079ea6dc8b6aa323a75c66dc6e64317b10a9e12c55f1314468308dd0ef9638a4d2389005bb2a51c6bd6d2c4c9f0fcdd044cb0fd0f298251bac44500fa1ff05926ad363bd879261edc7ae45991350b0e4e4062b81d8b626537573024efcd88caa3687ed87f02c4ebc993dfb1780422540cc0950b6aedabdcb690e84696642170913b9f60518ed54ccc5450128764d318ca4c5bd7f7979369edd6a3efb8edecc77e33c26a2aa81ff55fc4969026110e35cb951e0e115cc103357711a09f37412baa11fc6288728d359a96f93fe39785d0f8fd55ff8fb1a65853d798b7d4f8d40a23248411004f745fd9a982acf16e599f742e0e9d217a0a597c90e9131d3a6f2018b5254f28330fee792703dd8df5ad47190515d66dee189e4177724d412310ba1bd23a9ee20976ee3aac9c025737c61bad02770e66c8e663ee82f6ec6ae3f19e229b2bf328a20856ad98cacc938cc6b6438c61e4de6a519eb8cd07ef65286401a74d1d97a3896943f771bfe69cf3ea43874e8df4bb5bd0ec22aeea1b41385fbf8cf0a83a8c91568e32b9c1c178ac1a56ffdc630fa1bc0a89acd10836eab3a2131ea402abe086135f282d5089afe4ad47e1d99106147c69c04b62d103ff9a09048aad2e8e690f5fc9c362f597ec3c7dcf80c28878d29b160cf66ccdf1bd0fe472aae8d1d35ad1019530174532fcff9d50c31491a91820c688a6af6e6af3337b236bc344e951d78281451c0fba7c2dab9d49c69923e0001a71632a881f18faa41893b297f5c7be21933aad88a51d81457bd43d2f45f5b2cd9f7b3495dde9707f2831000ac29a1162f5375ec957c846eb4aa46de3015891fa6be766e012723b44952eddf2919734903d041d5cfc0b7859646eb18d7a2513bf17904ffe0351484708d2402b9cbb5de980a6a914069a2cfa8ea263166dae25aa7f2b18c827c3edf31f369e658cfc1c9bb90f0550f0982e625a40867a2146294be2981006521f0fea70cf215e62be9b32e845461bc88bb30b948f0cb172b8d2fcaa0ea857bf60e85ecf7f5118de0613a3122f9b42b4e9c0ff8f928a36c626a691eef6ef3cf7dee27ffa3c1c627d8a3313034cf935fbdb1bca346b0fda8f38b9b4aaf9d46521ef1625f411f4fb450c25117a03eb3b6185867ba99fd0b46abbf5a288f496d3e1f172d1da30af143e13b8409448025dd193c7457b0a12118926f21e95f2b5d45bfdefe361e40f518aeb4b8fdbf11120c7dc265b63d30592749d2b6d46ba87742a6e85c681eb09d66cff66ec50fe02a5f9e042b0667a2eae93e885eb93a1089a9121789dabf1b6b24259f5f64926774aeab97f5830ca4c67d5824aa6cfc651293caa8d743d948505d56a18f5fbdc1921ddcef32a51142f4bac51ba036e1ab12d73f6e0361be009e0fd1bdc47a272d04bf673b795b6bb9bd886d3eb70df0dec8b75db5d9a61d87b8d2bd0544ed634b7a4a41feeddb5f19491dc609e95854fce844b3dd4cd3bbd33826d1c1dc78c1b449c22142f557d7827be597585c21cbeaddc274d0caa7d621fd7c67131b1c461034ea293187ae9bd9ad21b686513458598f907e57cf786d1bb1ce434fb9c161f7ebfb178cc489aeb0c0ae3786d3bb15244adfa6b8cf155c8e8bc15ce8c03e097ae7b731e79c20117026eec6941d0e7a347930637acf982838d733f10666e8074aac25dddf47cb809a0197ac53205f051972779a63c93a6fc5ab55221d6a4428d474c359ed790dcf84a25488efe59e4214e14377cf31e0a8067e66916a12dc967055d2ba8c02e803c0aa29ff984f860745b110a19d46bc7695e2dc39665484dc9470d8b20ffa5834ff5f9e76b9077edbc04f8f7633d220b751cadc188523130ec4ef4cf50e5a1e9152056d1599a023a8c325e433fb093927c53b8002ccf6632e9fda64747b4c50667e168325f76f3048676040d4d45a5a68da18933b869ad080f5663f7500de94c14ca5739e5b85b3c3bfd2bd5c738f6e67486ab42447335d7cae253b263585b9b14bc6e3444b35f28ff55eb6f704923d76ceaf8c040580aea65df2abac26ae157da33d196d99361d793f98a130dbba5e4d7b40129e9bcf211923759e7b9b80854824949b10009e3efd9404848c8f138c7c73f32e3adc62e728cf536ec922c0b2fe0f500e07c19977eb54d8c0a1e88f5eb1fc2713f41a2029a108c41d4d73ce53979572039f7ece08380e7d859399f97fcde7401456e8642fdfeeef65ddcf9ccfca5b3b293010763d5b21b2b7a4ee215f5de22b2408785415fee5785aa65167b962a518ba1b4bd8e79ec243866d1860ac36010347d0e7b1d5ad33722cab0b01a88882275a5d791625e0b9e7579150d72b84e2a9dc6b1077bf11cc2c1f6d6a66583c8f34e719d7cc243e1369d615972b49587f97ec0b5e9b780aada72ff5434e8b6c6d657768b0d11a48356f392387310eb73d483d0beda79faf1be1fa7e8fe673ed5a57b7cf81e0b636ef2904d709435e35a6010c17b61186dceb3f9f7e5618111007794472937c3c8b9305e24c7aa042c6494f278dadacae846b8f970e8f61fc00e0e95ecac75819f5f9507d7752f5f558bd56c1f14092349f0e5cdb713fee744eca44d85b4b4a5453fe5d1165125c86b3e8617a44955b7d39e67a80577f88702b0b417076da33a4cba128dfaa6547f465c05d89088b61ee9d2a6e7721e54cc5424b1aa71aa3c0fd42dd2261fea318eaf03534784bd522926eaf0790e9b093e06af698385a5cc9f63533add23ec88b909197014a810af375a8a84845079cba9c4faf876b1fa823f84716f51ea68f43441d1fc07bdd7b1c122d950dd6889b9c2a25f5f451ed3322aa9db4b293707cab18b2948f150d78ccea0af6b42888adf564c840d7163e8bd53a00bffec04c43d5fb62c00de88c7f4797c1bde5713da3661b791d335f4e23ad3557062b91fa6a8058a36aabe5b8e3c605bbf5e9154b2ed31aa3bb1279e41ea068e86b827e60284db64278df0e8c84ae9e0f042735a80df5b3d6055af2e74cff93fd28feac4956b49d7fb65f3fda70a5386ec7833e013d7a0843938146615273ed86d51a58ccc509fda1655398c9eb40d1c75f4324724e9178961ee2bda764b8b852f912dde1f486a480f008ec8c96fb36f5aa9e2ba31d87ca3f249b7c141b269857f6896531e5912953293049d84889df7cf6cc1824aa5fc056c6acc91864c4e5d9ae1daceddd90fe8dcb37af95eb6f7c4cfbd50b33d22a96d2fb2ad455bb361a1e570228f6f48cd0b8e2cf85b12a2e73387816e55c9a791ec762aa5336894e9d6b91321c0d37cfb2d8af20fc83a8a063eaf2ff676d2261d943f9bb48f5511916fdaf7754609cccbca5fcbbfed8d12e24038f9dd4c5613edebbb250369830e566b66254799898819bef0f0481803d26492c0c4a89ee35c6c757decd640253bdc8db1928f5860e7612d9dfc91d0d91e1d21bc3eb2bfeb13ce973a4a1d3e1399294c18039c705a908212bfb2e3e6437fe9c43d767187857678b1ae4655938dda036143946b323ad1c36888ff9f9ff2575fa9ec9cf0924d20cd73c2bbc56147b7ed44b803d5374b05228b943f65ac3ffc68e1f7cb8a0a96f4b18ebe0df114992d9e9a5671018daf28c9ff1ea73459da2574a4cdef7d2184538350f3d4eaf7dffeaaa8dbe3e0928801a2d1f99ababa578e12c97b50ae87f1a043636c380b3fcb9468948621d8bee00389424632e816878f25c1def87ac0e324ffea6bb638cb649dbba66ebf716bfb0c49ab32961c6c14a3efb818c81c326743973b52fa4b2aabc9124124b001ed55f28aaa9bc74d67a7c748b6270a9314090f119ce530d2a357e6de9c7a69a1686f6e3b2070b78592b4a5bab7c4e217c9e6db90add4791766877f9b0caa87d0e717625f33260686b8e0e0b68c626658e0b0f69bb5f1963228eef15d46cbc7e069eed69e7b61563c1d4bd82ea568e0c96cd1bd57b8ea3055d0169387d75e2f4ae29951ac012ee880e682fda34e79ee5892ff7503c5baa2a12d9ba3159a1230a56b5fc7b89df6affeafa0356e15fdd45f75ff1c8cdd48cb0e576720ccd5450b1444bd575108a3b3b30a13a742caad6bf6fb722617ab01d51b3f1a344b807018a2dc27504b91c00214ffb9b669e9876b31631a4900d76ebc1f4144d07b57f0b9bede1bbc0c5fca670fda0001ae38c795ab0a0b3c97fbdabbbba1afc141ef89a013d5ddf167d9690ca3c4455a2b064d2d050ba70f7dd94bf3dfcb47e1d4a39ebb59d6008af4a6d32e705b285956319854a9b58fe1ccde8adc165286424e8655e6a592b663101cf1fe843265c19eb2335155eb91a7ddff88e2090cb075256b7ddd757a51a6c0bcc7b0a0088400a8cb0f21897e23fc639191cf56d2c884af583e268854b71965548974ca44ae2c98746f1b8a4cda8e601c8284fe935d251e264a63aa1b2e7cf0411646e81d1486ddb4ce1279f58151c6fb9a3c2eed6f89166e7faf88296d40b9ee24fb366abcca5d37a673623f6c87466c7d02b5fd245b35ddca3ad731249a60511473ca5a858c06245ced12e6f99a1422acd93a0c4138707c3cbe1c44d1c895309f6913784ac6132198838a0a82b3d72d088cc5e77828f737af0fda05e91a82944c1c9a742f6e20ee7e8f3d68de40eb2fafd41321135a407ca74e61c1da1b1ee2cd408ff8a4d333a4baced8c90943c21e8a07a12c1e1bdb855b657dd4fff2b3f038edfed6224b38a3bfceb9edec2df92ded930d6dedca6fd70c7018a86bf24ec1653d3a88196505fae6b3a172f06276d1b6e3b428bf6b87381ff232a7ac61e621fec4bef670838b4d6dd2bbdf30246134a0c3e019a71312220384a73fd1d80e7fcd5bcdcb6e9c431a44b5958177332ecce8ad8cbbaf5e299a23ef5b6fd0581a1053578ea6476e68159939de0ca46c9d05c466d4b559c898226f4d8c1626aa52e73fe14b65c058438559ac78642f82c43ed98103beef1a9377bbc720380cd8217c02cb1293495fa5b4f4bb6f67cd0bcc0ff691ecaa0d3fc3071038bf9502e5d1e28e9f0cbbcd4c23bf344dea9a1c742f2c34cfa63be29a184f7008e574d2aa79a580f84f5c9bfe8f235d4bf13fba7778e7b7bdc50e52858d85733acc48bad8d4203b329ee8344b69dfd005e58be89960180c92e90979e58d654e0e9a60da6b12a006981b5546791dc306d81543d58b427fa919e75981d36ad8d44ea77e151c7c14a377157aa26a9903578a0a58ad8c82bff158e2e08dc594330b5dbf10b0e16e688ef75c1f4d1f3682d44b56d1cb853696e6038dbd3637eca48d4a3e1244f0c054fe62d96603669c66e62ca4d63dab63a1c43f3e2abe5fbb89cfc80710839ec0d2f6d36f4e70c3460c80357f9d3caed70ee8dbfd41ef5a46874955208ea498f6bd6aa545c7fa4b49a6092572cb33532935e4f54cd8d4e1cdce64167e15367933816f6a1f1c9da959eaae9115216c5349aba8e177825152904144213ffd0a01d66acc28be5e79058d156dc749e1c6a99ac82c66864216bcac3a0f1075d97241b7db99f169198483184c4367d07bbe6599e696dead4825824362c5de27112e1cabfb69561769ada311d3c70990b846b2da14cf1cccb94ebddbc8a0815aa12d3dc1a7015d24465c5fca946307b4e590b21ee7f4df54a3ea0b399aeb7d70099c020eeb77be9e7e7f92ade3bfd0b02175a0e8b7d6b73571f5df67d23e7a72ff4d8c2c15529b9fa2fa9e802ea131ca920290e3bc667546090f0ae5faf1d9c798b3eedb65e73037d34bb06598651e26d0ce0dc9dd034a870325337dbeebd5e8487f7b9ba9bdff9bf092ac5e962dc6516c2bc48cde4e23752ab18062bf4d43e8a7d66ddbe78e1800a6044acdcdead184f87cd8f95463edb10f54f4ecb3cfa49b4aa18da4022ebd5affb4cc6c4b80f489338fdadefbe9eb94e0616264d207c841867a485f2399990c1cf76b6545ead81e022421f1b812f93d27fdd974cc0dcf9c8837d389caae959c19aef4c06f7ed4211624709f3efd6c6ab46fce185c31674c1102fe1219082ec50e2cb627333e91c4836cb2ba070fe6b24d6909230fa7e105e2127d5dc7b0a01126abd663dfd9090ee42db0f5c1f86a99df40a1da705707c218b4880e0d7094216a0a3ba9cbc42652d8a8a9b984ae869669d3d76ea25e6f2e7a45d7c43ea210e552622359adbc27ffdf30220bcc33d1bdde7f12108b4151429cd9283f63894c4d5238b003a391a7c7b5b2c47e6961d53799bf9a5d5035996a33aa89a8c08e2541d609b7825719673abf855763f320c1d72e49b3d00d2fc2aaf7f371008dbda20f368c834f50365a4ccab0d124174e2701f488cb1ff8e2cacb41b285dff36e3582f98302580a4164259ea5071e81cce76f0986ba09a9e78c40a0b8f6bcb6fdbb4c6d7b588f7dd9d9b12be5f8ec329ba303f5a3e14d8ffc840a369bea6e4db138ab1832aa5646048530d9e2a7f947b10534c5e6ed42ec5249eb87328371674b84837b4093a02ad7676d1d8d17899c10a6ad31ff9331e3cb8aaf3a9a75e5aa36a704feef517cdfa900efde4cf8c7dd9af76394e7f968d9e67eafd3500654426f0056ef3243c2f1c715f09f9faa15501e59fa806bc83b4e407fd7e75d946f660e2ff08458277599850778aa5de07ac6b5eae9a1bcfaa4322507d63d37309468d66f70b48839b149ea908e56ab81ab308920eae0c9ca7b5fada48c4b1278eee4634006f5bb2f9318523b24e80189f7d89a640089c00c06dd26e80ca16fc9c1f34554cd00957beaae6ecf30dde6f307e1bb389c6bdd4c1e4f303bdd29f7ae1fd431a2008ed3cdae8dc34efc7305e063a266d283879499faac63f33c1962b8864f8957f16acf5a52d42be67d03b7cba3eb80944bf9f6c0550d1cb73d7d1650ec49a783bd340118ced8eaa30df5012de4a457367dd786be35f0d1a3b167bb2c60476899364d74c63bb6f8433c531ffd2017ecf32b6f062d6ca98410e8b410cd168fb0a2b4a7324daa2e4effe10fbdb872f444907357a891c3eefa8445f1944f64539d9da3dc70b83c1e8249dada6e1f514caba910bb7f25690b639986fdcb81485304e29e4ed88fc361d03686d938b6068e547a8652c2d52c556cbb9367d356470fec2e9e840677fef1e95ddf6282da885a52c00bdd11aaaa6bae1178bb75928ef92727d3d0e99d4c26cd279aa1cd8f4adb58bae94d4efccf64e8e46c985670201ad93fb5b28bbea3991bc55ef911063d57af52ba11e2ac9a39a398d664dd9661a1d5a11ef0485dfed2f5e4a6a927018ad311d1b8e189bf7b6c2513d8782e43873263d8187f84d77132322838723288347ac9fbedcc6b51a39f6608469bf2486ffc11e40abb9d5b5eda85a5a4443422c5b853eebfa47066d17bd7451d2f60a6fb57ff6e83d575043b6cbd0772237ba0088880c07b1913d0aa2803615de67a13e63f8508a00453d8572c12539571cba1239268775d44ff8a6b8ae727272af0e95c86807fcf2d01991747982bb60a99446e3e969150bf957e0cc60262e8bbf4b91fe2048fe13b7d11ceb02e7760f1125fc3faff6e0e866c5c11c9363c6848c4bcdf77fd12f459bad58e09ff09b55299917723146204a20dfcdbc475c630293da527b0a4380b5997cd2410280b839b1a5a76d830f44f424620d65ce73a4ef4c08fb2dc443a1fe9c9b3837a9e0f9fd7d10696ad16c16dea0101b19fcae4221fecb87f3b2cd38299c01a3e99c74b95ffc6ae816f296215b24c016a11c384706c687802742a0793f5af24ce0a9ddd0fe1272aef1027a8447617ed70cb66601b284187b07324ffa3165e319dd8131ed84b1e1b82c172f3890ae8b958dfd9ed04d59eee74e67f9a7743b9591feb3e4e88cb5075612e0e339092f5bd9f89e7644d1a7149e50214584b1381d952f7c52f49a58fdfbe303f7265ad96eef7caa30907d846acdadcf66e4ffaaf0a2d7f73fbcc5e4d69b64782f1af716bea4dfa38f07bca30f6985048f8999f7ede761a794d2ae557d9643c10c7eedbae639d57689b3a86328c9033c8898e1651f28150344afeb3dd5f3bd13c20e681641ba756f1d1baac73772022f22f42d41b1d8fd522b7c5bfd36f698aedc4696496389f47efc2038099500987bbab2b59112da96b4e3168f597a0186346708453ec4efb3cc122297bfb35dae844c5f31fc4256c5faac94c0c6c1414692feb157814d41eb5ccb780a9fb31733ebce5444b37cc0aa9f9e676966cc4d205458f5c047e043be85623986bf2c63a3db947a2454091b506faf5db2dd5507fcc415e0bc26ae4d77866c0bfae48a3e488c217ada1d5f4b1ae12e00b97ed208d48ce6183552f53b44a29aac38aa0ae1f10ad2f92d8e41826c80aa2a912d5fc527cc4818dfefda684aba6ed75711a32ceeba83fbcd7ffdd25099dfd52bec507546e940d07f1659a7a6e9c997624cdf4634941b6d3eb7a708e23e7326a9cbd57aa2e8bde42b40ccbe7308b351a984d6510abcb0a13ddd915b7cb1b653c9d691fae2f9ad11ece6c6a5d714f506d2a0509929ff7c22a2c8a0ca0f7a5d22e90b6e2dd4fe3cd40433c6c1439a365292ab28bacb924f4c769fc92bcf597be1e5eeaaad8974d2fa903f2d64f82053fa9f3cd8f29865a01d7e6581f1f72999d846ecbd02e1b47fefdd0f762d991c2edd05247a5c384096ee8d2f8736755e9a34cd6fa9bfb9a8530d929797b7e2c3e9d4a2456dfa1b43eed6aea7aab33533d9785eb6fd77cb4dadb2d4e09eb5d5be1b7473fe8f3d5338eb4a124918a80a9f62c90cf3cd629d818a0f5e5bd11d5c7163423015282e7620d1f7790d3437e66ec563369343db4f6ed489a2f07f1af436ab243f6ad52a8e15b25e732e501b31e7d1822cd6991cac7ac9e7f0e74b409dd1581af760dec64138c733a7f06b1e22205fcd203d6c5cc31ca70c68299745f1eaedb19f1648078cd70818e44b12584a88de2dc2641e771679f9ebd9586e3ff0df9bf56e4ce08e39c83e53044737a3e3799be33b4a2a64b66077a4a4ba6b27cc39c0173c49008c619556095842cd8bd8af25fb8a3a7d0d764b050db9cd3ff99147c370aeecea1e703de9a0a4c0c9d309360f60c5e78784cf57c08704093c7b1e717fda5a2c30c25539ca3936d791aa1175ae19078ada11d8df67ee6f6d81b111ffc1a8c8e8c827886a57c8745723ba503e4de3deb143855c52e68c54cd9b406e105eb7fb8b6411150b76c8560b00606cfacfe8406a561e229f04ff4d66a29779d062f17cdd60cba836eabac27ae7f06528cd3521bba1b2571526984e671eb1ff8b157734a4e07dfffc2ef454622ed5b20eeaa130f0227fe146fe8fd6fb7c71309d10625b04c5d508c2ae410af21be1e37889ddd58d8bbf0103a07c86fa34001c8bc6d4da2fef0df58eebf46aab4159f224c97584e70422c06ace9e593cc08301d61b105eb9285d18f58f4bab2b70167755aceba78011e9ff5d1e1809ee3b74968dede78b9ece2986210cb42118e0cdc1323cef3308220dc0262f1431c4e1fd014135700121d3784c459040d0ebd2d8a3efd052f4659bc68658a8fbbf32dbc134401729941a04e6eaa143747c20136585ddeb07e3dc0319f520bd89f1d7015da3b58b7643bf6ba25518bad33b8d2a00093401ce55a5974eed3ffa6e393667f82414341971964cfbe15ad1867d17bd5d10ba1f729a08020239872210a362b62b53f272edd3fcac8eddb350ba23ee8387bfc8822d487e5420f13b983e3b7f6fd58710ef5ed5b54ada92c95eca83475523225e516b4fe964a78985a8a92ce575be8cb176a52a2141ac6252749dacfd03dfdae9f3662a2e4455e45cf7835ef3ea99073109e326089c4d222dfbbbedcaab06e09f8e658a0c452e60f8ed08f8dfd01a3b7bfa0dbb3b893956cf6e765f3926d65630bf7ab421da074a2eefb4250cfa5dcd46a01dfbc019a33e85f4417b13acc74d064ca3b56e6ea8aec38cd63ccd8335628e104e3c71a92dafcd9efe6218efa24c3aa3f2b32c34220384ba676d2038e35811a1e7d242bf57332d802bfd5a866cef34bad8d53176c3f2145ecb0a8d67ed823b2e0a364ae38bf357381bef2d28854f7280f0d0725bfcf4baa8c3390efe0f40794d965b75bd7bd5336edea12f4f57b3b5d220fb01dcc2af33b51298e70b69a3d73068b7b6a7f361aabeb72a59c70230cdd8ac53240d25b471ce538d0afb91c6dc7abfd2e3703bc7dbb2dd74eee5713297794849d9288926a63ebb46b5af0bd4d18b9b25ffdd3049e51c80b6e2fef049c9c810dca20a9e3b4be9d861d0c0ac6739c47bb2eaf3cbe2b6d71c104843446e1889b1673817171fcbf2958d34521b433ed91258cf58db230777bab0138e9765af5ce3aad53bea9d202ed6aa905be6be775a497d6f3354d5549e34e062e92a3a7c7a7c0e9e9874811bf6c1411f7c2001bde7efa818b2e11ae7402edbdccaff59315a7707e5e325d5952d8bcf993c88a152617ee1d4ebfdac030d39c3dca09ee21b63995bf5eb5fd48ca13a141e5398b6fcc93073417cd22f11fdc379ffb498490c4d24d4d7c7403c66aaf3a5f92d6efd21deb7519887f6693c377c5a96ef7ba1350ed1ab1192a0186a3b7da9ff6a4c1528a55ae079f8f31f916ee0e55326a9ec825c479cf431a41e7ab1edbac9dc690666c62a3f501b543dc7573df46c761d11797fc522c0f58ac1838c3149d278a1ddeee2bd290fb5c46c5f3a9c917ec6a12267fabca21318be8a9fdb7113bfd3c68656e6cafd9c84d733ceb033780eb9c93791edc5626f88b3990b202bbd065e3123946daac3e3ffa2ddeb41581af667c67893f11662a5b5c041f51fc293d0bfbcf9fd9610f8707966709b7c8a032265fbed199125b27792e84efa8b76a1651e1ca1e59dbd4ca4484fe159a3fdbb96536b6001930eb1095cc8a461013d2e5cfece61f82ce7bf32885ddbed2d5188db035b90b141e1bb091f3d08980572cc0650cc83ffa32020d8bfeef3dba42d9015fca4024f07f192d6f530e3b9ef5f2bdc44c0cd391d2860652116ae633fcefe4f580df9abc09fa69df924e7bf78d4e917e52c1774d240d8afb8c0e43969dbb39a308a6668c579ac26fdf6789a172f9a8c326da770fbf171e14b0c18634ef31467c22f4243dd99e5e4f36ab11c00281c3750b52c85fe7c4fe95efc2b356de51d132c1746fd5ba927ab74411935330e0ecf340eea127d24875d656e6173b06aceaa5c37ab7e1b8f2b527ee7614d61e404bfd71d523ac8fac019c6c3bd12e3ce2d8b1e71bb2b51dd54532f45c568ec6ca669d9648fcf18fd28f4ea84a89c60e4395cf028ee5843857b44dc8f6c20fda05e38259987095a29640a51779a83854545f1994ea5630a8dd01b52947856fafa23e8196c3a40cc065bcb50a6a42a534be005c267f811bf4af6fb3787369065a9d64b13c926af7742b55940226782a752dce5ead79073b9ba8d90966aa3b6f35e47a74e34a47cdf73b14014579f27e54501280a46dd3767c402fd5e79552738aa405a8ab1e0c62ef9cc4a3c2da40a3efc633e733182e6b836b4b7ad067475ff410b20689cd20d976ff24cbbcd36f267dfdb1cedc718f984bd279df543d0285e958e72ef49a4554b1c2283a70aa131cf1ab6bd0a1071ba92afb0343614860cc6d2f4df8775273b68ce5b4c1f46e95e7d80f9c130723519272449e036b4852a159974ab40ba77de0d4e8c4877b98b4e7863ae8c4b0d6b94039996969b0707467f0383c7141091d4e90a7c724c77972dddf95708da78b6e6ac8028a274b7392c86c9b84ecdc67678d6e7119af8ba1db3a4f2c3c1b4fafd2475a6cdcd2fb2eec757640b2936252f1d7e7cef06a9aaeb9cb5013e6cdfdc75997c76cb164160fe55dcd8e72e5ef4e31dea4d9db4fec775ead8f590fb0eabefc9100921fc9135d5fae8a8f55fbd21662ace142e1548e53e036bbd21d74242655afc1c312fc4df39c5a478dc208917bdd80727cd9114238cf6d408b9585b2584ac1f9a837b72584a985f44525e560e47d8b38af0393f54d8c4d842e25d00e961f36cef2674bfb4b40221d24b043e2ecc155424be7626c33a474028534a9f2d2a4f39a0ce7b326cf5697a146b95765fdeb403070e7c307fff330d461ecac6b847d7ecc08c762bebc0bb4da73a1728481fa8b529222ee12af6af2a9b113c0089e8e1caf6e90bc9884a3ca59848da2e2cf5d1e7631abad60418d55a87b12a12a157cbad1ba69bb68a19b376c006151e70917d5c364c015ac8e329a11b6a214d7b404b1f380a458f1aff81ee3e027af6de449b2867fa32b8abe54abae61d76db5402443639ad825845cad56400d78b8b3838e84366dfe48c835f96f13b2e01866f0e339d8bc273113871dc7bfe8aef12dd80d6a390a1465af8fd6fd9c429fff6a8cbb91614f1222fcc5ccbd5ef53728e86afd78655542bc4b03b8a0763a39545ba3810ed5b94adcbd0e740862d26d790aec8fceab637c3af98dabe33bc6f6e73690d9e8256fa076984e0692e481f07108e8f431320143bb929a604a52203bbf15bb1e57d36f0bb117841e7a8bfdeabb6bf8c58bc2c32b49a0d736e2eae97ef62849359ada4d6a0438bc75c0a892e38546954283856405b5dd68ffd095744793b8824dc0c06ec50bcb2c8a7221d57b50af477c477d30dfdd824d28ba2e40799dcefd4184562eb836718e1bd9ee4e97be92cc34e9945f375fd2fec3f91d88a1fffab583338782d5e429e971c0cb96d6cada64cae960cd466c4fdab988713a129ca666dcf471a26a8d349216f261ba42a6f09333d5e54723a5a09b620033f9a4c60225046df6b6ac06a0f8f2795d39a5453da17a1d936ba785284d95d013c81048fcdc9300a1a65258fcbc1b6bc209542ce1eae11cec66bd3caa7a2ee71e11a141a16004fbcf4d91dc4788e89b7a1bef1895e77fccaaec51e3fb299ce73fac321293a2001d641ba4ee4481f0ff8540a20a24e56f0a7f43de9f24228c28906bbfc347a16543ac1ee7d25809b0c05e0bd2c91e8bf9f9217f7f933dd03ece0bb9c5a1507b1af6127b1ab125ca52c22bb75e43c6f99bf53330486bf896684cbf8c112823ee2fe2b3a508664052a3a129a04a19790a4b2f6deb8a9bbae993716deb766b01f57b3f7bf980ff406aca94dd6b4a26489fe3e94e9c8779adfb37dcf66712ffb3fab32420d81aaf1d655152d93253d2d27d0cca6d47a04d5a6fb34d73874b1f523bc8a3ee1a4bc1005877997a94bf7fd070aeff193234dce75351cf6c918e47c5d339648ac5b682a4ef49d6e149db2d84794bb1ca17c34ce23adb75de77a7ab154977a1d3ead3e05d962a03ef070afb5cdbaa4dbe1fc677ea1cfdb13e43e1dfb1bd083f261bc1eb9ab09cad0a4d868e73c6e5160cde19a57aee9e78122a32498eddc67604549b5c4e921602519633d988ddc205fbe6f64aa21186886d4947f9842ac46298039b0971eef306753dbe6bb8086f099955cc0660fdc6983d78b5943dab5631dd850551878e43b18008fbb53ef17d92cae21b4fb8d5650d262d98d03e5f76ca20e68dd1de10e16010f398cddff71a979d05580bb00a1a025b4518842e3866a4c38dff06ec8f94bd7ed9aa191d389d08b230537477768a586920f1c431375cf3bb2496ee3f1cc08efd6744a84397b412413d649283d2ba33816084b81ebfe2d9b0dda9957c659547ab5e8b75d019006bf6f717f44a3365b336b1e4f33a010316aece3dc1426e40a587b4dcb279efb1bfec511625a0609150d9bdca9721719014bd8ba8ac1feb85040bb6cceae21ec76bdf7573e11ea34f3666688825a29754b6fb91b8fd2d8466bbca8949c3aca76959c0ef6bff02bf2e3d7cfda5e666a0b838f3789dff18ca07efb754f8114b117a475025ecfc20d3a0adff1ff5750d78188b4b6b9444f06de5f10e306834f35e0f94c0f1f94002db3eaba71899fd19afce948689045215a1f6d148584bfa2e813c2c84bfdb51f8fa5d90fdeac6502e919183470ccd7c976eb0a7861ecffd2a704b50f4c728b98179be795692ea95baa3b651ec3b901b5111aea4a4acaf75d58ab0e8a5d5e9a267dde4da551b2be0047fe998c2b71dd63f12df5583798046e7ad7b83118ffade914984f60af1cdfc3353b257166100703aa8d69f292bb9b2eb6d67149ae7a871f21f7f5ec9c18a022c365d22c6c862526e0bfb641b08a5fa4b2f94687a3c57180fe6e1637e193b74310890692dfd4270aa4cb9dfcb0bb0ad4c04ce126021a27744dd7b548d817aac0250d7fb0e206cf07856113c8ecd1fc4460d79b04e88455a0d4016087c3fc481684ce9d3af5641007efd3084b8ff517605e8d0c15f9df12e7ec013be8185d39465313bc53de96353967a91b2b4c26442d1c69fa177a126f6abd88665a4952fc90918274b68317756ade4d52263df18b2012b5de7d180905b78526818bfa89d01e1a4e5df2a7a6e17593d7dfd624bbc7a7f6c9c5fa33862ba25458198ca287adf131beaf4435318243e9b00e5ac8e463b4885d531a78b703804ac2f4adcbe35bf6e42e58e234ac0b3bddd41f9ffc17940c75fbbf0b13367781c6c2719524d647450f4c35f7d8d2e4d47c5845e2e54da04c17bd071b32c3878938038943d2e8669118b55362ad62607b6a3f3547cbc044223c9599055b6ba4f2e9bfdea487815079989877beb45ba25a6521f5b5588227e2cd8e56765c9f635574054297e2420f81619ec4d773af6525555248240443a6701eb07d2f1c6d6879682e287151da1b9528edf3d39424b7f09c91f2ba793d8ca90e0abfb4110ef435066c96e2e82a86378b4777f85ffe7fc37e9c17a494b286ad0ed9c6c4422bcd2f37573f87865a333431d5380de1107acfa7cd83634cd73b4916293a978b495aa213409c0322ff9454755ae794d6011f3a948fa1986185bddb82db3099b6438a65efbff6128c0180eecb78293001ca3b9e0f0558ede3e151814d4cb6e39ae161d8107809ef74f47d4bfa420b890cbcfcd593d663046d62126862b0d153880c79da9d63f16b92c54f2721b1f90ef5c3abfc736130cc9385795fcd078022794d0665ee8e0d0670235878cef2d3db068a55ec647a6b4adc8dcf406959a5098f30ee80a2e7651fa1f9627352c27071b6a2f4daa52aaf3ec6fb1174c11042f4f35947558f6a31215c33a033220f88a30868152bd3d0f31ae0e2894916005e44525cdaec36eff4c43d680f01e7fca68180d83c1720e4f16750ea18b858eb95af2b2bb531c4aac1dda9daa8d03669e21a3126179d5ae36768d03add7de07d404616c5ebffdff5de75800819a6b49bd9ed2fb889e3340ac3d29c3623a4ebec37ccbc5b0b53388298b493cadf6ae808badee69a94eec9f6daf844f03783f8432d7a88c66ee0f3d697768e608b2c16562271cdd0fed793e43a49e2a08f5e774f7229a0e377afd89846be2a45c4729a262a41578308807292dbd9987bcb27e42c07fcf46da242229774393a1103be828ac7ee805c94fa9b1a5d9dd92f1576f341e8294c98895f72966fcc4f2adad5d72171ba8ff2ca18ab0b660e5b834112fd494d28c1c86d0d675bac35c28616aaf4a8e8a748e67a41aae343211e00261c59719b7beddfcd575baab47afca8ec298ffa2539a264bdbcc62154ad979165a99ec6f24c01b5ad3c6119afca8d328948e67baa1a6871d39f040df29e5809f0f71a9c107572e110279ee38cb79cf9c2070a494ff9249743a270f8c5ac98d5786ff3c4116745805c2a148e324d91acf09b86bcff1b25bb9ce757f12028c1ef0226af78712785ed17790fac67a252366583fc9eeea1ed05638f0c9e9606a29670cf83fd2e39362a2065c47a145f1344f9ccc746bc189420326a177c96bb2228bf0961f4407cb20ac051793eaf98561d5e84836607855f794c882901c62c854c1bf77a715aca1010aa31944a4fb9b84b4bf14d25aac11c66a841451821ffa689b0f4daa74a911a0c9a346f2211f141119bc046a355e81982a3b9451b12b544dea65c2c16ecf88a413c179e0da5aab08e417c8fe5c4412eb20cdfde65dfeae86e22316118848c99200c5835c65a9290e33c1494f085bba5adee9e7a714294cf65cdfa7f28abc395f576828b311c320a905e5ad3a0b5c9a9fc0fc2a541631c9da28121c002d6e8d57e2e462e11893aff1b554a7fc250c782b03e41ec0f7c22b23e2bdd4a47bf3745dbdd9dea342df93894ec0afa7911f90769a79ce27ecc961cd30b0a23b648b58165022c9109ca58f5066c01a63c0775ca7d972cdc1371dcb4f05b1377a492fb5483f6c1f154a32e6f77bc9d6b82d69aa9e3c5c3de776e8f839d5cce71179142a42b8a21008435148e212c2d8de0aa90d09ec2742c16bec51dce7d8925ae20af53627c540567f4096ddc767a485a6997ae1115646acb5da45a66828c3147de83d50f500ab13d02b80b43405452e03fd18c5ee7cf710dd1184d8f37ee9a71b1be526fb9bbc9a7a884ec166b2d64ba8d1a051c35901d0c1d47f50d3e2e8ef333a11656f140cd5dc8dc0aef0852767646f66f6031c8680bee6b3a894144c944e7a3e0e3cd065bcce82e7ca9059423cb2c7975865d8804ded058e33bbb074fd580cbd978d745fc50b92e4f5f457ba0fd9f13b50264667f5d8fda497c1d6c8ee1c3a9a342adce5dacd2955e7514cf4aff6a0ac73cb34f1725bef5d032add64a880cadef1a0fd3fcaf7e1700c7370fb7c616ce2e060736cedca4c127c508b478e194a6803db09b09fd7854428cdcc6e07ede368495361d8af37f8f9407edcd38770691194e2147f3cb33324a2f5d3c3d2e91a88fd2e3b0ac58c4b5d39ae8ce07eb41847a34e0ebe49c13e30397a4efc32a2f18e9c485728e7dc76587456694fab33f64371843c139a8702a86f2ed8217a61d5663f755c3baa0c3708f2e7fe47595627025ba3da8654b6d6aa84a174586dea820aebbac9e8ee18b997358f58dc20e042edc6aae4cb8c77a4ddcd3a83406f4800399201804ae656203257ad7739c2954bf15a619a64098e76f6ebf4fb6a83e2855c9176b5209d628a6591dffa27fdf0ea2cd5f54bef83df0a80d841525d6b8b8d3f63f778661d20d5f437b29aa4a7b2175464c5c149f34dfc7d53d0adc46a343d8753608370114135c916f432fa1325cef8036657be5c9384100c04d010d6696b1b5d6c47c77b01f405c49351a28c0a627e560b728287503455f682438580c091ac4de8c6d9165dab03497dda200c09dcddd03f106ebdd8bb0b34e9f396853b02b353e9b80790921140d3d138c377cdd2052edda203e92bda869b56c3d4a73f688dbfedf94aebe85eafcecdbfbfde38b0fe4e1650a42d6f40010f8ddf7b71b05e282f3aaf4e7c1f929a16b4ee284b39fa79d72c579b5f9831500668c94d9af533e3b46e6c3fa7e831292c782519c4353d44f39c0c5bc18ec8a2d31bb3619f6c7b7bfd1eaab1f0c9829581963692a5e49cd09af7eae3c1075a4453c9d8380fabab9cf0e2a56ed4e5a2bcfa0a779d096c96fec4beb5dfb6d9c7afd05c8242f4ac2c10b23fc1fc13bf805ac6240a296c7ea3d1f83d2d82d926a4ebd420442a9ac0cf6631bb18d2469ab6659e7fd68477452482750bf6286546778fcb706d03ac62b3cde2983c51dab26bede05aecd149009cf1ef0319fcd1d8768ddc9b1b80ff34f93789201b56b8e72375822e5fbacd2fe34b4a419509da4ee05891ca075b50c9ba285bfbd46c738c0e6e6ecedf8081d3789db8444134754e7a8a72ca709c70a5cec5b0952a8f3eb9ffdeb4f9c1d2634e40825c8d7c501f9ae31db9fdd35c7c52688155398365a58809edbe8ae727d0ea367418dd61fd504ecc250800939aedde59832624fe995dc55c3cd50156e0c6a46024bdb7dc106647ae1f80df2a796593a2fb83416818546772401fe84464e99d34efdaedccc06f9ba169c2586a4f01b55de01f732ebcd82876d00fcd5cb2df3adcf17ee8e836ded79fa314ad49767676ea4e4bcfa652697db17e2c6b2bc4dfa1054f31ae1b323fad2526e2e34ea98e519dbd8238cfac537b11e62379fdbbc3af399a01a7806b001d6220b07b9d6663d1590e10d4abb476fe585a115c73256b28347a5ca79dcd9d082aa39c54350f601fee284abbdce4a61f22dc3d7dcb9c09f533b5525cefccaa4e4d8a2175155d21eadd55b02c9ec332ed2dcda74040ac7a141b7c88e9d70928f103fa9fc38e6174a701c212d881294aebbcaa3d341b68548f9d6d53d9d0570b6697bda0ca6434d37560019d126c4c6c2a77cc4ad976d4f29bc859c5bc3b21b172d50414d49c282480332291935a001797d8b34da5db5d1220a7c42896f97bf5ad3279ee2fa507d678f8c9ee75bdf441f52c33500e74dcb5cbfd3d5a7adbe6a4f1af6c0953bd662fce274c9642fc006bb3486faa28cca7ff827c0b1d5414b8f34802550842798aa7d5bbbdb6f25e32e10b2e2e085059c43a87e77cb20cee18c5e6345b05c0393d2ecdd7176bf06142b3df3785590c75a16c7367547385f23db1c0842d422176fd7611f24f8582ef45c5c079385d740c553ba33fd67ebfe771ea88c1c39bfb277f4b5482230706152f9754bb5f5929ba63cf1bac03de34462c55886de12b2a62be4d55e56371d5bb93c66ab83b77a8acb879056ec8f310b982d13ac3a5f1acaf0df11de122947d6366b1a88dbd6c724216cbe8c231c6b555b7b4676c705472dec3a930f37c20940b58c37e56c50e3a84a0833bff1ab7adbcbeb217df6b6bbcee890fd2547590bd957c117247dca325377991a0a9f509a182c2d898888fa8a3125483177bf8312382b16b6dde357790cfaca7f605ac262d4df2eb0b50c8573d0075c13cf71024c06a872b4e00f1f3fb9df3d22ff47a9e9373a5fda813e160313d45b5e8d1a0f1249fb03a3f94f832e3ae2c7a7ee9f2c40dae733f63b661647b4cfeb625998d487a524df6915c102127cd40dccc662dd997a844c62cc8dac54aee4746d821d3a19f4eb2c28040c6c65d5c89ac65cbb87847eee2c78513950c5fab2e4d3f118a4c243556f675a19fb09e221bd510786ca3f6e602b338f5a1371e0d1ec44bc6d53bc2dc188401fa1ce268d6d1d663e3f80a11196cac99bfa01447dfc70ce47f77397f3084e58fa9b0e2c756147cea819d6de5a1c82ffc3a2640fa378be5292a448b9800050bb6dff6e8da6401db6f2869e735c7d4a4c24a58aef738f714e9a080054821ce4a7c875cce8102dd620e0ecb47be88febcf4ad71264765f946945ae61b168b37b680fbb952cfad0993252b23e647e9fce6be16cd3b06082483b8b9f8cea96e7709baea7b4625ef18673dcbb646156ad5e23bfa2c59c3e245efd804e9c9251574f54ce1fb9bcf59b1e6435d7bfd6f0c1e36beaf60eefe9d3a31a56502c525c387fe20dfec6907cfc6d66da738805b37d9b9300574fb1689161051e0eba91e0756c9e5d2a38af494705f881f1aa3f8abc92285c999d589e35c0d570da53d71bf5ed5e82d0b4227c9ef3ae4dbb433bc8cc8f9145649426ad05fe65bd27d52efaa5c2dafaa940cf86b59298f4dec5927b789dbfa7c1c17e58eceb0f947cc72a71d70ade5601933821ba09e6e2180da417475c54b8b48021625cee2d06e1ea9ade546289be1370cfcf684b50011ea40c287bf1427c2ede819833592297e7e4750511f9433a2652a06ae028cc51570015db7b820ffd891341f17541e052671db7e3bb4b5937d3f088f2040bc50cd4a00f6a28f357c04977b6bc48677819b1f3cb3e0dcb2edf60b50a5fd44c26c0f804318cd1460fe8c86fe096473a445cef6b2a797245cfeccfaac6f51814180ef52174e6ced7b69c038a628c109a90bd1ae85047c9ed406581c0419f02353a2c4551afadb1066a5a13b80d05da72556cc9be456b52ac3168568359cf14bb422fc43fd2a0283ac86057c8e6d04fae7da44a55defb7cf0021eb31401837c26cbb861697431afa014b0fb021f75b5b3b5d2378320f76a114f4495751e5d6713e64fac17af1bc5c5db9295506b007d54c0b02f3f0c7b73fde11127927b9d39c875e6b615fcd113af85a8765179df1b6a7c6e499279b45a33153a4acc8c9f9e0d5c4af3b8c6d172891a65a09b1b97794c254c69ae4031fe6d6f1160b40cb0c7bd3a9191afe5a73275cc068f91e5c31605964f8967609766b49694c0adedeeae105b8276f5d9dd4a8c2a464dca23249cd77298fed92e523ca0639078d28d1180eaa3d3c46742c1701863e1ec6dd4f6fdff4317c5ac8d30114683a08d27e51a2d79c90927a498476f55f6844e64b249f9025838fc478c3e82aa90f8c7b9b2226fa2553460ce503e960d443230ac7de437d811e4a4f355c6a2d87907ccc042abad124bca87feff64b357667e996393c0e2b5b01d3ccec3aa1141f27b5b4a1f37ffdb02fb04a2877cb13092c10775655763fc663f3f1a080f9003efb008dce6f85e3845c320c939a363c87e569e683154db45b8cdc9c732e67acafabe01fa582d1cf75011a0cf6059efc847dfa891839a2e0a3fa38a2d02ffdc8259a5c4036d7eec085170048548e0ea764aa349379bea75073433b28d0cafad7aad24e8dcc47bf27dfd1d00a99b0167c4954424df12f45b3439ce1f52a5b8a08c088538981d84d50a44bf2b2ba0deba71037cc7233d0924ea315893069d69819a655e3e86cc63f44073002e9b56a6701d8896172651fd210f62bd2240d83e11244f325c9cc0254ff747189dfb467d5ce0fdc8c25de56e3db61ec3af3232d56ed0b17dff6fd732707db966a09497345cbefc407f8031f666e6be9fdb4441bf94156da764b0b19d3c1803f72c90072c11c1b133836dd23be400667fe5ea1478659b5cbf996a234a103d0d2d6fca705289d29ba6daf99cbb182c7d45b0338f37b6fd67f21167843a56e5ad6e38e10ea35eb29b4b95f52cab8171deede3bd7b2833675cd4ec47f6a383786c32f005d9062a2e62ce916a780cd911394d934020289c2f068d7b25e4a90a18085c974ad232e45a8fd15ab7fdbafcecaab94952ac68727c057924e6c361acda2216a56581a7</script></div><script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","slug":"CYOU工作笔记","updated":"2020-03-02T09:33:59.164Z","comments":true,"link":"","permalink":"/2019/07/08/CYOU工作笔记/","excerpt":"本文章需要输入密码才可以查看.","categories":[],"tags":[{"name":"工作笔记","slug":"工作笔记","permalink":"/tags/工作笔记/"},{"name":"游戏开发","slug":"游戏开发","permalink":"/tags/游戏开发/"}]},{"title":"互联网体系结构总结","date":"2019-05-08T17:25:57.000Z","path":"2019/05/09/互联网体系结构总结/","text":"The Design Philosophy of the DARPA Internet Protocols（1988） 读书笔记TCP/IP协议在（1988-15）年提出，本文目的是解释出于何种原因互联网协议采用了TCP/IP设计。事实上，互联网的设计哲学是从最初的协议逐步进化而来，直至现如今的标准。例如IP和TCP的层级结构， 看起来是如今互联网协议设计的基础，但在最初的协议中并不存在。 DARPA互联网架构的最高目标是研究出一个可以高效多路复用现有内联网络的技术。最初的目标是通过ARPA分组无线电网络将ARPANET连接到一起，另一种选择是设计一个统一的系统（多媒体网络），用以连接多种传输媒介。同时，分组交换技术用以实现多路复用，其他的技术，例如电路交换，也曾被考虑使用。但是考虑到应用场景的支持等原因，分组交换最终成为了互联网架构的基础。最终形成了互联网的基本结构：一个分组交换通信设施，其中不同网络通过网关（分组通信处理器：用以实现存储和分组转发算法）相连。 文中列出了七条次级目标，这些目标是影响互联网架构设计的重要因素。其中，最重要的一条是即使网络和网关失效，互联网也应该继续提供通信服务。为达到这一目标，就必须保护正在进行的会话的状态信息。需要强调的是虽然“生存能力”次级目标中最重要的一条，它的优先级仍然低于顶级目标。第二目标是互联网架构应该在传输服务层支持多种服务类型。不同的服务类型是通过不同的传输需求区分的，例如传输速度，延迟和可靠性。TCP协议在设计之初试图支持所有类型的网络服务，但显然是十分困难的。TCP/IP的出现是为了让互联网架构能够承受并行传输，并最小化依赖性，延迟以及对带宽的需求。第三，一个成功的互联网架构需要能够容纳多种网络技术，从军方到商用范围。其余优先级较低的目标，或效率较低，或没有完全在工程中实现。 总之，当时的互联网架构是非常成功的，网络协议被广泛使用并且衍生出了许多类似的架构。理论上存在着比数据报（datagram）更好的模块，用以得到更好的生存性以及灵活性，同时满足资源管理以及问责机制的需要。是当时DARPA组织的研究方向。 Named Data Networking of Things（2016）读书笔记全面部署物联网面临两大挑战，一是如何使不同种类的电子设备进行通讯，二是在建立通讯后如何保持其连续性和安全性。这篇文章讨论了NDN可以如何改善和简化物联网通讯，主要针对目前IP网络无法解决的问题。这些问题包括： 简单的通讯任务需要复杂的解决方案 通道和会话机制造成的安全问题 本地通讯有严重缺陷物联网中的每一个“物”都会按照层次结构分配一个名字，这种命名方式与NDN根据数据名检索的检索模式恰好吻合，使得NDN十分适用于物联网网络。NDN在网络层加密命名数据，从而保证数据只被授权用户获取，以数据为中心的机制解决了物联网应用中安全性的问题。基于命名的传输方式也适用于物联网，例如对延迟的容忍度高，快速恢复丢失的本地内容以及逐跳阻塞控制。网络内存储可以让流行的内容更容易被传播，促进本地文件进行恢复，数据加密可以使最简单的NDN应用也可以享有上述的优势。为了让NDN的核心网络层协议实现物联网框架的功能，在网络层需要设置必要的命名规范；控制正在运行的附件以及对附件的增删；需要做信任管理，访问控制，数据融合；应用层面的消息收发；高效的多端通讯；以及将物联网整合进因特网。在NDN上实现物联网还存在许多问题，包括使用多个层次结构命名；在无基础设施的环境中进行路由；在高度有约束的设备上实现；数据收集模式的问题等。","raw":"---\ntitle: 互联网体系结构总结\ndate: 2019-05-09 01:25:57\ntags:\n    - 研究生课程\n    - 互联网体系结构\n---\n\n### The Design Philosophy of the DARPA Internet Protocols（1988） 读书笔记\n\n    TCP/IP协议在（1988-15）年提出，本文目的是解释出于何种原因互联网协议采用了TCP/IP设计。事实上，互联网的设计哲学是从最初的协议逐步进化而来，直至现如今的标准。例如IP和TCP的层级结构，\n看起来是如今互联网协议设计的基础，但在最初的协议中并不存在。  \n    DARPA互联网架构的最高目标是研究出一个可以高效多路复用现有内联网络的技术。最初的目标是通过ARPA分组无线电网络将ARPANET连接到一起，另一种选择是设计一个统一的系统（多媒体网络），用以\n连接多种传输媒介。同时，分组交换技术用以实现多路复用，其他的技术，例如电路交换，也曾被考虑使用。但是考虑到应用场景的支持等原因，分组交换最终成为了互联网架构的基础。最终形成了互联网\n的基本结构：一个分组交换通信设施，其中不同网络通过网关（分组通信处理器：用以实现存储和分组转发算法）相连。  \n    文中列出了七条次级目标，这些目标是影响互联网架构设计的重要因素。其中，最重要的一条是即使网络和网关失效，互联网也应该继续提供通信服务。为达到这一目标，就必须保护正在进行的会话的状态\n信息。需要强调的是虽然“生存能力”次级目标中最重要的一条，它的优先级仍然低于顶级目标。第二目标是互联网架构应该在传输服务层支持多种服务类型。不同的服务类型是通过不同的传输需求区分的，例如\n传输速度，延迟和可靠性。TCP协议在设计之初试图支持所有类型的网络服务，但显然是十分困难的。TCP/IP的出现是为了让互联网架构能够承受并行传输，并最小化依赖性，延迟以及对带宽的需求。第三，一\n个成功的互联网架构需要能够容纳多种网络技术，从军方到商用范围。其余优先级较低的目标，或效率较低，或没有完全在工程中实现。  \n    总之，当时的互联网架构是非常成功的，网络协议被广泛使用并且衍生出了许多类似的架构。理论上存在着比数据报（datagram）更好的模块，用以得到更好的生存性以及灵活性，同时满足资源管理以及问\n责机制的需要。是当时DARPA组织的研究方向。\n\n### Named Data Networking of Things（2016）读书笔记\n\n全面部署物联网面临两大挑战，一是如何使不同种类的电子设备进行通讯，二是在建立通讯后如何保持其连续性和安全性。这篇文章讨论了NDN可以如何改善和简化物联网通讯，主要针对目前IP网络无法解决的问题。这些问题包括：\n1.\t简单的通讯任务需要复杂的解决方案\n2.\t通道和会话机制造成的安全问题\n3.\t本地通讯有严重缺陷\n物联网中的每一个“物”都会按照层次结构分配一个名字，这种命名方式与NDN根据数据名检索的检索模式恰好吻合，使得NDN十分适用于物联网网络。NDN在网络层加密命名数据，从而保证数据只被授权用户获取，以数据为中心的机制解决了物联网应用中安全性的问题。基于命名的传输方式也适用于物联网，例如对延迟的容忍度高，快速恢复丢失的本地内容以及逐跳阻塞控制。网络内存储可以让流行的内容更容易被传播，促进本地文件进行恢复，数据加密可以使最简单的NDN应用也可以享有上述的优势。  \n为了让NDN的核心网络层协议实现物联网框架的功能，在网络层需要设置必要的命名规范；控制正在运行的附件以及对附件的增删；需要做信任管理，访问控制，数据融合；应用层面的消息收发；高效的多端通讯；以及将物联网整合进因特网。  \n在NDN上实现物联网还存在许多问题，包括使用多个层次结构命名；在无基础设施的环境中进行路由；在高度有约束的设备上实现；数据收集模式的问题等。  \n","content":"<h3 id=\"The-Design-Philosophy-of-the-DARPA-Internet-Protocols（1988）-读书笔记\"><a href=\"#The-Design-Philosophy-of-the-DARPA-Internet-Protocols（1988）-读书笔记\" class=\"headerlink\" title=\"The Design Philosophy of the DARPA Internet Protocols（1988） 读书笔记\"></a>The Design Philosophy of the DARPA Internet Protocols（1988） 读书笔记</h3><pre><code>TCP/IP协议在（1988-15）年提出，本文目的是解释出于何种原因互联网协议采用了TCP/IP设计。事实上，互联网的设计哲学是从最初的协议逐步进化而来，直至现如今的标准。例如IP和TCP的层级结构，\n</code></pre><p>看起来是如今互联网协议设计的基础，但在最初的协议中并不存在。<br>    DARPA互联网架构的最高目标是研究出一个可以高效多路复用现有内联网络的技术。最初的目标是通过ARPA分组无线电网络将ARPANET连接到一起，另一种选择是设计一个统一的系统（多媒体网络），用以<br>连接多种传输媒介。同时，分组交换技术用以实现多路复用，其他的技术，例如电路交换，也曾被考虑使用。但是考虑到应用场景的支持等原因，分组交换最终成为了互联网架构的基础。最终形成了互联网<br>的基本结构：一个分组交换通信设施，其中不同网络通过网关（分组通信处理器：用以实现存储和分组转发算法）相连。<br>    文中列出了七条次级目标，这些目标是影响互联网架构设计的重要因素。其中，最重要的一条是即使网络和网关失效，互联网也应该继续提供通信服务。为达到这一目标，就必须保护正在进行的会话的状态<br>信息。需要强调的是虽然“生存能力”次级目标中最重要的一条，它的优先级仍然低于顶级目标。第二目标是互联网架构应该在传输服务层支持多种服务类型。不同的服务类型是通过不同的传输需求区分的，例如<br>传输速度，延迟和可靠性。TCP协议在设计之初试图支持所有类型的网络服务，但显然是十分困难的。TCP/IP的出现是为了让互联网架构能够承受并行传输，并最小化依赖性，延迟以及对带宽的需求。第三，一<br>个成功的互联网架构需要能够容纳多种网络技术，从军方到商用范围。其余优先级较低的目标，或效率较低，或没有完全在工程中实现。<br>    总之，当时的互联网架构是非常成功的，网络协议被广泛使用并且衍生出了许多类似的架构。理论上存在着比数据报（datagram）更好的模块，用以得到更好的生存性以及灵活性，同时满足资源管理以及问<br>责机制的需要。是当时DARPA组织的研究方向。</p>\n<h3 id=\"Named-Data-Networking-of-Things（2016）读书笔记\"><a href=\"#Named-Data-Networking-of-Things（2016）读书笔记\" class=\"headerlink\" title=\"Named Data Networking of Things（2016）读书笔记\"></a>Named Data Networking of Things（2016）读书笔记</h3><p>全面部署物联网面临两大挑战，一是如何使不同种类的电子设备进行通讯，二是在建立通讯后如何保持其连续性和安全性。这篇文章讨论了NDN可以如何改善和简化物联网通讯，主要针对目前IP网络无法解决的问题。这些问题包括：</p>\n<ol>\n<li>简单的通讯任务需要复杂的解决方案</li>\n<li>通道和会话机制造成的安全问题</li>\n<li>本地通讯有严重缺陷<br>物联网中的每一个“物”都会按照层次结构分配一个名字，这种命名方式与NDN根据数据名检索的检索模式恰好吻合，使得NDN十分适用于物联网网络。NDN在网络层加密命名数据，从而保证数据只被授权用户获取，以数据为中心的机制解决了物联网应用中安全性的问题。基于命名的传输方式也适用于物联网，例如对延迟的容忍度高，快速恢复丢失的本地内容以及逐跳阻塞控制。网络内存储可以让流行的内容更容易被传播，促进本地文件进行恢复，数据加密可以使最简单的NDN应用也可以享有上述的优势。<br>为了让NDN的核心网络层协议实现物联网框架的功能，在网络层需要设置必要的命名规范；控制正在运行的附件以及对附件的增删；需要做信任管理，访问控制，数据融合；应用层面的消息收发；高效的多端通讯；以及将物联网整合进因特网。<br>在NDN上实现物联网还存在许多问题，包括使用多个层次结构命名；在无基础设施的环境中进行路由；在高度有约束的设备上实现；数据收集模式的问题等。  </li>\n</ol>\n","slug":"互联网体系结构总结","updated":"2019-06-06T14:26:27.999Z","comments":true,"link":"","permalink":"/2019/05/09/互联网体系结构总结/","excerpt":"","categories":[],"tags":[{"name":"研究生课程","slug":"研究生课程","permalink":"/tags/研究生课程/"},{"name":"互联网体系结构","slug":"互联网体系结构","permalink":"/tags/互联网体系结构/"}]},{"title":"深度学习概念总结","date":"2019-03-25T13:54:50.000Z","path":"2019/03/25/深度学习概念总结/","text":"encoder-decoder类型网络autoencoder &amp; PCA (Principal component analysis)所引发的对监督/非监督学习更深入的思考： batch normalization:当然我们是可以用之前提到的对数据做 normalization 预处理, 使得输入的 x 变化范围不会太大, 让输入值经过激励函数的敏感部分. 但刚刚这个不敏感问题不仅仅发生在神经网络的输入层, 而且在隐藏层中也经常会发生。神经网络的输入参数维度越低越好 图卷积神经网络资料非欧空间数据如何处理 vgg16:Conv5_3指的是第五个卷积block里面的第三个卷积层图卷积神经网络：eng处理非欧空间数据 聚类算法：四种 Drawing 3D (or 2D) shapes differentiably is challenging in TensorFlowDIRT(git)可以解决这个问题 查看cuda版本：cat /usr/local/cuda/version.txt查看cudnn版本：cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2","raw":"---\ntitle: 深度学习概念总结\ndate: 2019-03-25 21:54:50\ntags:\n    - 深度学习\n    - 基础知识\ncategories: 学习笔记\n---\n\nencoder-decoder类型网络  \nautoencoder & PCA (Principal component analysis)所引发的对监督/非监督学习更深入的思考：  \n\n[batch normalization](https://morvanzhou.github.io/tutorials/machine-learning/torch/5-04-A-batch-normalization/):当然我们是可以用之前提到的对数据做 normalization 预处理, 使得输入的 x 变化范围不会太大, 让输入值经过激励函数的敏感部分. 但刚刚这个不敏感问题不仅仅发生在神经网络的输入层, 而且在隐藏层中也经常会发生。  \n神经网络的输入参数维度越低越好\n\n图卷积神经网络[资料](http://tkipf.github.io/graph-convolutional-networks/)\n非欧空间数据如何处理\n\nvgg16:Conv5_3指的是第五个卷积block里面的第三个卷积层\n图卷积神经网络：[eng](http://tkipf.github.io/graph-convolutional-networks/)\n处理非欧空间数据\n\n聚类算法：[四种](https://blog.csdn.net/u011511601/article/details/81951939)\n\nDrawing 3D (or 2D) shapes differentiably is challenging in TensorFlow\nDIRT(git)可以解决这个问题\n\n查看cuda版本：cat /usr/local/cuda/version.txt\n查看cudnn版本：cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2","content":"<p>encoder-decoder类型网络<br>autoencoder &amp; PCA (Principal component analysis)所引发的对监督/非监督学习更深入的思考：  </p>\n<p><a href=\"https://morvanzhou.github.io/tutorials/machine-learning/torch/5-04-A-batch-normalization/\" target=\"_blank\" rel=\"noopener\">batch normalization</a>:当然我们是可以用之前提到的对数据做 normalization 预处理, 使得输入的 x 变化范围不会太大, 让输入值经过激励函数的敏感部分. 但刚刚这个不敏感问题不仅仅发生在神经网络的输入层, 而且在隐藏层中也经常会发生。<br>神经网络的输入参数维度越低越好</p>\n<p>图卷积神经网络<a href=\"http://tkipf.github.io/graph-convolutional-networks/\" target=\"_blank\" rel=\"noopener\">资料</a><br>非欧空间数据如何处理</p>\n<p>vgg16:Conv5_3指的是第五个卷积block里面的第三个卷积层<br>图卷积神经网络：<a href=\"http://tkipf.github.io/graph-convolutional-networks/\" target=\"_blank\" rel=\"noopener\">eng</a><br>处理非欧空间数据</p>\n<p>聚类算法：<a href=\"https://blog.csdn.net/u011511601/article/details/81951939\" target=\"_blank\" rel=\"noopener\">四种</a></p>\n<p>Drawing 3D (or 2D) shapes differentiably is challenging in TensorFlow<br>DIRT(git)可以解决这个问题</p>\n<p>查看cuda版本：cat /usr/local/cuda/version.txt<br>查看cudnn版本：cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</p>\n","slug":"深度学习概念总结","updated":"2019-06-06T14:26:28.016Z","comments":true,"link":"","permalink":"/2019/03/25/深度学习概念总结/","excerpt":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"/categories/学习笔记/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"C++ & C#/Unity notebook","date":"2019-02-18T01:06:46.000Z","path":"2019/02/18/lang-notebook/","text":"C/C++Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file? 右值引用与move()\\forward()函数：std::move执行一个无条件的转化到右值，更像是”rvalue_cast“；std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时；右值引用的目的是减少数据拷贝，提升性能 虚继承：解决菱形继承问题 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。 堆是操作系统维护的一块内存 自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改(当然，你要通过非正当手段也可以修改)？？ 头文件声明static变量，多个文件include该头文件，会导致每个文件都有一个专属的static变量 const的物理常量性和逻辑常量性：物理常量性就是const对象不能改变，但是可以123456789101112131415161718192021222324252627282930313233343536373839404142434445constexpr：constexpr所修饰的变量一定是编译期可求值的，runtime的时候不能赋值，不然会报错，所修饰的函数在其所有参数都是constexpr时，一定会返回constexpr。 泛型技术：说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 重载set的 oprater &lt; 就可以使set内部按特殊要求有序 LFUCache全局对象的构造函数会[在 main 函数之前先运行](https://www.cnblogs.com/zpcoding/p/10805639.html)[extern与static](https://www.cnblogs.com/wh5313/archive/2012/06/12/2546112.html)：没有链接属性的标识符（none）总是被当做单独的个体，也就是说该标识符的多个声明被当做独立不同的实体。属于internal链接属性的标识符在同一个源文件内的所有声明中都指同一个实体，但位于不同源文件的多个声明则分属不同的实体。属于external链接属性的标识符不论声明多少次、位于几个源文件都表示同一个实体。 [static变量初始化的问题](https://www.cnblogs.com/weizhixiang/articles/5771501.html)：类成员的static变量要在代码块外初始化，否则要加const [定义与声明](https://www.cnblogs.com/damaohai/p/11497143.html)：区别在于是否分配空间（extern） do...while(0)的作用：宏定义函数的时候解决“；”所带来的问题。宏跟函数的区别在于宏是把参数替换到指定位置（++a的例子），imgui中也有提到 C++类的内部可以定义引用数据成员，必须通过成员函数初始化列表初始化 const修饰的属性只能在构造函数里初始化，然后就不能用变量名改值了，但是可以直接控制变量所在的地址直接修改值 #pragma once：避免include重复引用一个文件 空类的sizeof为1：那是被编译器插进去的一个char ，使得这个知class的不同实体（object）在内存中配道置独一无二的回地址。类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域 ``` delete p; ``` 实际意思是删除了p所指的目标（变量或对象），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放，指针p的真正释放是随着函数调用的结束而消失），释放堆空间后，p成了&quot;空指针&quot;。如果我们在delete p后没有进行指针p的制空（p=NULL)的话，其实指针p这时会成为野指针，为了使用的安全，我们一般在delete p之后还会加上p=NULL这一语句 包含纯虚函数的基类可定义指向派生类对象的基类指针和派生类对象的引用，不能直接定义自身对象 [print输出格式控制](https://blog.csdn.net/qq_37059136/article/details/80841675)vecotr的at和[]: v是个空集合的情况下，[]访问是行为未定义的，at访问则会抛出std::out_of_range异常。c++标准不要求vector&lt;T&gt;::operator[]进行下标越界检查，原因是为了效率，总是强制下标越界检查会增加程序的性能开销。设计vector是用来代替内置数组的，所以效率问题也应该考虑。 unique_ptr是智能指针的一种 comptr和unique_ptr的区别： ``` C++auto_ptr&lt;string&gt; aps(new string(&quot;abd&quot;)); auto_ptr&lt;string&gt; aps2; aps2 = aps; cout &lt;&lt; *aps &lt;&lt; endl;//报错 此时aps已经失去对string内存的所有权，如果是两个普通指针，则没有问题 cout &lt;&lt; *aps2 &lt;&lt; endl; implicit conversion/explicit conversion: pragma comment ( lib,”wpcap.lib” )表示链接wpcap.lib这个库。和在工程设置里写上链入wpcap.lib的效果一样（两种方式等价，或说一个隐式一个显式调用），不过这种方法写的 程序别人在使用你的代码的时候就不用再设置工程settings了。告诉连接器连接的时候要找ws2_32.lib，这样你就不用在linker的lib设置里指定这个lib了。 C++的钻石继承：dreaded diamond： 函数声明后边的const：const的函数不能对其数据成员进行修改操作。const的对象，不能引用非const的成员函数。 noexcept：该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。 class和struct的区别：最根本的引用类型和值类型 volatile: A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided. vector &amp; list:vector方便随机查询；扩容时因为它使用内存是连续的，会申请块更大的内存，造成整块内存的拷贝list由双向链表实现，好增删，不好查询 decltype:有时我们希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量（初始化可以用auto）。为了满足这一需求，C++11新标准引入了decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 12345678910111213int getSize();​int main(void)&#123; int tempA = 2; /*1.dclTempA为int.*/ decltype(tempA) dclTempA; /*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize().*/ decltype(getSize()) dclTempB;​ return 0;&#125; 在C中，使用typedef定义struct在创建结构体是就不需要Student stu; ```了，直接使用typedef定义的别名例如S，``` S stu; ```123456789101112131415161718192021unordered_map不能使用pair作为键值，需要提供pair的hash函数，map可以 hash_map与unordered_map: 前者使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存；后者记录元素的hash值，根据hash值判断元素是否相同。 速度上2最优其次hash_map最次map &amp; （位 “与”） and ^ （位 “异或”） | （位 “或”） or ~ （位 “取反”） 位移运算符(&lt;&lt;/&gt;&gt;)：乘以/除以$2^n$整型最大最小值：INT_MIN,INT_MAXmap&lt;&gt;如果不赋初值，不是NULL是0[vector](http://www.cnblogs.com/Nonono-nw/p/3462183.html)：向量``` bash#include &lt;vector&gt;; iterator：迭代器 STL中的基本容器顺序容器：vector，list，deque等关联容器：map，set等 upper_bound, lower_bound:1234567891011121314151617181920// lower_bound/upper_bound example#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::lower_bound, std::upper_bound, std::sort#include &lt;vector&gt; // std::vectorint main () &#123; int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; std::vector&lt;int&gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&lt;int&gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); // ^ up= std::upper_bound (v.begin(), v.end(), 20); // ^ std::cout &lt;&lt; \"lower_bound at position \" &lt;&lt; (low- v.begin()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"upper_bound at position \" &lt;&lt; (up - v.begin()) &lt;&lt; '\\n'; return 0;&#125; a++/++a123int a = 1;cout&lt;&lt;a++&lt;&lt;endl; // 1cout&lt;&lt;a&lt;&lt;endl; // 2 12vector&lt;int&gt; &amp;nums;for(auto i : nums)&#123;&#125; unsigned 无符号的 unordered_map C++ struct 构造函数附默认值的写法：12345678910111213struct student&#123; int age; student *child; bool sex; int check; student(int input):age(input),child(nullptr),sex(true),check(1996)&#123;&#125;&#125;;int main()&#123; student a = student(18); cout&lt;&lt;a.age&lt;&lt;a.sex&lt;&lt;a.check&lt;&lt;endl; return 0;&#125; out11811996 把指针运算符 * 应用到 var 上是完全可以的，但修改 var 的值是非法的。这是因为 var 是一个指向数组开头的常量，不能作为左值。C++ 指针int var; //var 输出：20int p; p = &var; //p 输出：地址////////////////////p 输出：20引用int&amp; a; a = var; //a 输出：20 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。 new动态分配内存（只能new一个指针吗？不是），delete删除，delete [] pvalue 变长数组 普通数组到vector 一维到多维 模板：函数模板/类模板 内联函数（inline属于ret-type）：啥时候用，ret-type还包括哪些？减少了函数调用，但是增加目标代码的大小 boost库：准标准库 string::find(&quot;a&quot;) 如果没有找到”a”，会返回一个固定的大数，且等于string::npos 的值 CC#嵌套类型：类里声明类。 struct是值类型，内存分配在栈上； Action与Func是特殊的delegate：func必须有返回值，可以加0到若干个参数，action必须没有返回值，可以加0到若干参数；用event修饰的delegate更加安全。EventHandler就是一个已经声明出来的delegate where and new()在C#中，泛型的使用非常广泛，为了泛型调用安全，经常需要对所使用的类型进行约束。在对泛型的约束中，最常使用的关键字有where 和 new。其中where关键字是约束所使用的泛型，该泛型必须是where后面的类，或者继承自该类。new()说明所使用的泛型，必须具有无参构造函数，这是为了能够正确的初始化对象 静态多态性：函数重载、运算符重载动态多态性：抽象类和虚函数（抽象类和接口的区别：抽象类比接口更详细点，可以继承多个接口，但只能一个类） 正则表达式得看看todo 装饰器 attribute 方法前边直接加个函数的区别 Unity矩阵对应的几何变换 https://orangered3stones.iteye.com/blog/1940821对于N+1维坐标表示的理解 https://www.cnblogs.com/btgyoyo/p/7085264.html碰撞检测 http://www.jmecn.net/tutorial-for-beginners/chapter-15-collision-detection.html 基于组件的引擎架构：派生关系，通过继承父类获得父类的功能，这些通用功能为了能够为各种派生类提供服务，都必须实现到基类中不再是父类中的接口，而变成子对象实例，为游戏对象提供服务组合和继承的区别gameobject都派生自object 为什么coroutine 生命周期 c#的语法 反射 代理 设计模式 工厂 单例 装饰器设计模式 shader todoC++ 语法，算法，引擎：A*再来一遍，多线程，模板，迭代器，网络同步Unity 网络Unet，Mirror","raw":"---\ntitle: C++ & C#/Unity notebook\ndate: 2019-02-18 09:06:46\ntags:\n    - C++\n    - C#\n    - Unity\n    - notebook\ncategories: 学习笔记\n---\n\n# C/C++\n\n[Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file?](https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl)\n\n[右值引用与move()\\forward()函数](https://blog.csdn.net/coolmeme/article/details/44459999)：std::move执行一个无条件的转化到右值，更像是\"rvalue_cast<T>\"；std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时；右值引用的目的是减少数据拷贝，提升性能  \n\n[虚继承](http://c.biancheng.net/view/2280.html)：解决菱形继承问题  \n\n在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区  \n1. 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。\n2. 堆是操作系统维护的一块内存\n3. 自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价\n4. 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。\n5. 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改(当然，你要通过非正当手段也可以修改)\n？？\n\n[头文件声明static变量，多个文件include该头文件](https://bbs.csdn.net/topics/390720572)，会导致每个文件都有一个专属的static变量  \n\nconst的物理常量性和逻辑常量性：物理常量性就是const对象不能改变，但是可以```*a.ptr=anything;```，逻辑常量性用```mutable```关键字保证，mutable的成员变量在const成员函数中也是可以改变的  \n\nconstexpr：constexpr所修饰的变量一定是编译期可求值的，runtime的时候不能赋值，不然会报错，所修饰的函数在其所有参数都是constexpr时，一定会返回constexpr。  \n\n泛型技术：说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。  \n\n重载set的 oprater < 就可以使set内部按特殊要求有序 LFUCache\n\n全局对象的构造函数会[在 main 函数之前先运行](https://www.cnblogs.com/zpcoding/p/10805639.html)\n\n[extern与static](https://www.cnblogs.com/wh5313/archive/2012/06/12/2546112.html)：没有链接属性的标识符（none）总是被当做单独的个体，也就是说该标识符的多个声明被当做独立不同的实体。属于internal链接属性的标识符在同一个源文件内的所有声明中都指同一个实体，但位于不同源文件的多个声明则分属不同的实体。属于external链接属性的标识符不论声明多少次、位于几个源文件都表示同一个实体。  \n\n[static变量初始化的问题](https://www.cnblogs.com/weizhixiang/articles/5771501.html)：类成员的static变量要在代码块外初始化，否则要加const  \n\n[定义与声明](https://www.cnblogs.com/damaohai/p/11497143.html)：区别在于是否分配空间（extern）  \n\ndo...while(0)的作用：宏定义函数的时候解决“；”所带来的问题。宏跟函数的区别在于宏是把参数替换到指定位置（++a的例子），imgui中也有提到  \n\nC++类的内部可以定义引用数据成员，必须通过成员函数初始化列表初始化  \n\nconst修饰的属性只能在构造函数里初始化，然后就不能用变量名改值了，但是可以直接控制变量所在的地址直接修改值  \n\n#pragma once：避免include重复引用一个文件  \n\n空类的sizeof为1：那是被编译器插进去的一个char ，使得这个知class的不同实体（object）在内存中配道置独一无二的回地址。\n\n类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域  \n\n``` delete p; ``` 实际意思是删除了p所指的目标（变量或对象），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放，指针p的真正释放是随着函数调用的结束而消失），释放堆空间后，p成了\"空指针\"。如果我们在delete p后没有进行指针p的制空（p=NULL)的话，其实指针p这时会成为野指针，为了使用的安全，我们一般在delete p之后还会加上p=NULL这一语句  \n\n包含纯虚函数的基类可定义指向派生类对象的基类指针和派生类对象的引用，不能直接定义自身对象  \n\n[print输出格式控制](https://blog.csdn.net/qq_37059136/article/details/80841675)\n\nvecotr的at和[]: v是个空集合的情况下，[]访问是行为未定义的，at访问则会抛出std::out_of_range异常。c++标准不要求vector<T>::operator[]进行下标越界检查，原因是为了效率，总是强制下标越界检查会增加程序的性能开销。设计vector是用来代替内置数组的，所以效率问题也应该考虑。  \n\nunique_ptr是智能指针的一种  \n\ncomptr和unique_ptr的区别：  \n\n``` C++\nauto_ptr<string> aps(new string(\"abd\"));\n\tauto_ptr<string> aps2;\n\taps2 = aps;\n\tcout << *aps << endl;//报错 此时aps已经失去对string内存的所有权，如果是两个普通指针，则没有问题\n\tcout << *aps2 << endl;\n```\n\nimplicit conversion/explicit conversion:\n\n#pragma comment ( lib,\"wpcap.lib\" )  \n表示链接wpcap.lib这个库。和在工程设置里写上链入wpcap.lib的效果一样（两种方式等价，或说一个隐式一个显式调用），不过这种方法写的 程序别人在使用你的代码的时候就不用再设置工程settings了。告诉连接器连接的时候要找ws2_32.lib，这样你就不用在linker的lib设置里指定这个lib了。  \n\nC++的钻石继承：dreaded diamond：  \n\n函数声明后边的const：const的函数不能对其数据成员进行修改操作。const的对象，不能引用非const的成员函数。  \n\nnoexcept：该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。  \n如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。  \n\n[class和struct的区别](https://zhidao.baidu.com/question/748004411503788052.html)：最根本的引用类型和值类型\n\nvolatile: A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.\n\nvector & list: \nvector方便随机查询；扩容时因为它使用内存是连续的，会申请块更大的内存，造成整块内存的拷贝  \nlist由双向链表实现，好增删，不好查询  \n\n[decltype](https://www.cnblogs.com/ghbjimmy/p/10636030.html):有时我们希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量（初始化可以用auto）。为了满足这一需求，C++11新标准引入了decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。  \n\n``` C++\nint getSize();\n​\nint main(void)\n{\n    int tempA = 2;\n    \n    /*1.dclTempA为int.*/\n    decltype(tempA) dclTempA;\n    /*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize().*/\n    decltype(getSize()) dclTempB;\n​\n    return 0;\n}\n```\n\n在C中，使用typedef定义struct在创建结构体是就不需要``` struct Student stu; ```了，直接使用typedef定义的别名例如S，``` S stu; ```\n\nunordered_map不能使用pair作为键值，需要提供pair的hash函数，map可以  \n\nhash_map与unordered_map: 前者使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存；\n后者记录元素的hash值，根据hash值判断元素是否相同。  \n速度上2最优其次hash_map最次map  \n\n&  （位   “与”）  and  \n^  （位   “异或”）  \n|  （位   “或”）   or  \n~  （位   “取反”）  \n\n位移运算符(<</>>)：乘以/除以$2^n$\n\n整型最大最小值：INT_MIN,INT_MAX\n\nmap<>如果不赋初值，不是NULL是0\n\n[vector](http://www.cnblogs.com/Nonono-nw/p/3462183.html)：向量\n``` bash\n#include <vector>;\n```\n[iterator](https://www.cnblogs.com/maluning/p/8570717.html)：迭代器  \n\n[STL中的基本容器](https://www.cnblogs.com/cxq0017/p/6555533.html)  \n顺序容器：vector，list，deque等\n关联容器：map，set等\n\nupper_bound, lower_bound:  \n``` bash\n// lower_bound/upper_bound example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::lower_bound, std::upper_bound, std::sort\n#include <vector>       // std::vector\n\nint main () {\n  int myints[] = {10,20,30,30,20,10,10,20};\n  std::vector<int> v(myints,myints+8);           // 10 20 30 30 20 10 10 20\n\n  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30\n\n  std::vector<int>::iterator low,up;\n  low=std::lower_bound (v.begin(), v.end(), 20); //          ^\n  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^\n\n  std::cout << \"lower_bound at position \" << (low- v.begin()) << '\\n';\n  std::cout << \"upper_bound at position \" << (up - v.begin()) << '\\n';\n\n  return 0;\n}\n```\n\na++/++a\n``` bash\nint a = 1;\ncout<<a++<<endl;  // 1\ncout<<a<<endl;    // 2\n```\n\n``` bash\nvector<int> &nums;\nfor(auto i : nums){}\n```\n\nunsigned 无符号的  \n\n[unordered_map](http://www.cplusplus.com/reference/unordered_map/unordered_map/?kw=unordered_map)\n\nC++ struct 构造函数附默认值的写法：\n``` bash\nstruct student{\n    int age;\n    student *child;\n    bool sex;\n    int check;\n    student(int input):age(input),child(nullptr),sex(true),check(1996){}\n};\n\nint main(){\n    student a = student(18);\n    cout<<a.age<<a.sex<<a.check<<endl;\n    return 0;\n}\n```\nout\n``` bash\n1811996\n```\n\n把指针运算符 * 应用到 var 上是完全可以的，但修改 var 的值是非法的。这是因为 var 是一个指向数组开头的常量，不能作为左值。[C++](https://www.runoob.com/cplusplus/cpp-pointers-vs-arrays.html)  \n\n**指针**int var; //var 输出：20  \nint* p; p = &var; //p 输出：地址   \n////////////////////*p 输出：20  \n**引用**int& a; a = var; //a 输出：20  \n\n所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数  \n\n引用很容易与指针混淆，它们之间有三个主要的不同：  \n  1. 不存在空引用。引用必须连接到一块合法的内存。  \n  2. 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。  \n  3. 引用必须在创建时被初始化。指针可以在任何时间被初始化。 \n\n试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。  \n\nnew动态分配内存（只能new一个指针吗？不是），delete删除，delete [] pvalue\n\n[变长数组](https://blog.csdn.net/fanyun_01/article/details/77430682) 普通数组到vector 一维到多维  \n\n模板：函数模板/类模板  \n\n内联函数（inline属于ret-type）：啥时候用，ret-type还包括哪些？  \n减少了函数调用，但是增加目标代码的大小\n\n**boost库**：准标准库\n\n`string::find(\"a\")` 如果没有找到\"a\"，会返回一个固定的大数，且等于`string::npos` 的值\n\n# C#\n\n[C#嵌套类型](https://www.cnblogs.com/rinack/p/5695610.html)：类里声明类。  \n\nstruct是值类型，内存分配在栈上；  \n\nAction与Func是特殊的delegate：func必须有返回值，可以加0到若干个参数，action必须没有返回值，可以加0到若干参数；用event修饰的delegate更加安全。  \nEventHandler就是一个已经声明出来的delegate  \n\n**where and new()**\n在C#中，泛型的使用非常广泛，为了泛型调用安全，经常需要对所使用的类型进行约束。  \n在对泛型的约束中，最常使用的关键字有where 和 new。  \n其中where关键字是约束所使用的泛型，该泛型必须是where后面的类，或者继承自该类。  \nnew()说明所使用的泛型，必须具有无参构造函数，这是为了能够正确的初始化对象  \n\n静态多态性：函数重载、运算符重载  \n动态多态性：抽象类和虚函数（抽象类和接口的区别：抽象类比接口更详细点，可以继承多个接口，但只能一个类）\n\n**正则表达式得看看todo**\n\n装饰器 attribute 方法前边直接加个函数的区别\n\n\n# Unity\n\n矩阵对应的几何变换 https://orangered3stones.iteye.com/blog/1940821  \n对于N+1维坐标表示的理解 https://www.cnblogs.com/btgyoyo/p/7085264.html  \n碰撞检测 http://www.jmecn.net/tutorial-for-beginners/chapter-15-collision-detection.html\n\n基于组件的引擎架构：  \n派生关系，通过继承父类获得父类的功能，这些通用功能为了能够为各种派生类提供服务，都必须实现到基类中  \n不再是父类中的接口，而变成子对象实例，为游戏对象提供服务  \n组合和继承的区别  \ngameobject都派生自object 为什么  \ncoroutine 生命周期 c#的语法 反射 代理 设计模式 工厂 单例 装饰器  \n设计模式 shader\n\n# todo\n\nC++ 语法，算法，引擎：A*再来一遍，多线程，模板，迭代器，网络同步  \nUnity 网络Unet，Mirror","content":"<h1 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h1><p><a href=\"https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl\" target=\"_blank\" rel=\"noopener\">Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file?</a></p>\n<p><a href=\"https://blog.csdn.net/coolmeme/article/details/44459999\" target=\"_blank\" rel=\"noopener\">右值引用与move()\\forward()函数</a>：std::move执行一个无条件的转化到右值，更像是”rvalue_cast<t>“；std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时；右值引用的目的是减少数据拷贝，提升性能  </t></p>\n<p><a href=\"http://c.biancheng.net/view/2280.html\" target=\"_blank\" rel=\"noopener\">虚继承</a>：解决菱形继承问题  </p>\n<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区  </p>\n<ol>\n<li>栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。</li>\n<li>堆是操作系统维护的一块内存</li>\n<li>自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价</li>\n<li>全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</li>\n<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改(当然，你要通过非正当手段也可以修改)<br>？？</li>\n</ol>\n<p><a href=\"https://bbs.csdn.net/topics/390720572\" target=\"_blank\" rel=\"noopener\">头文件声明static变量，多个文件include该头文件</a>，会导致每个文件都有一个专属的static变量  </p>\n<p>const的物理常量性和逻辑常量性：物理常量性就是const对象不能改变，但是可以<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">constexpr：constexpr所修饰的变量一定是编译期可求值的，runtime的时候不能赋值，不然会报错，所修饰的函数在其所有参数都是constexpr时，一定会返回constexpr。  </span><br><span class=\"line\"></span><br><span class=\"line\">泛型技术：说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。  </span><br><span class=\"line\"></span><br><span class=\"line\">重载set的 oprater &lt; 就可以使set内部按特殊要求有序 LFUCache</span><br><span class=\"line\"></span><br><span class=\"line\">全局对象的构造函数会[在 main 函数之前先运行](https://www.cnblogs.com/zpcoding/p/10805639.html)</span><br><span class=\"line\"></span><br><span class=\"line\">[extern与static](https://www.cnblogs.com/wh5313/archive/2012/06/12/2546112.html)：没有链接属性的标识符（none）总是被当做单独的个体，也就是说该标识符的多个声明被当做独立不同的实体。属于internal链接属性的标识符在同一个源文件内的所有声明中都指同一个实体，但位于不同源文件的多个声明则分属不同的实体。属于external链接属性的标识符不论声明多少次、位于几个源文件都表示同一个实体。  </span><br><span class=\"line\"></span><br><span class=\"line\">[static变量初始化的问题](https://www.cnblogs.com/weizhixiang/articles/5771501.html)：类成员的static变量要在代码块外初始化，否则要加const  </span><br><span class=\"line\"></span><br><span class=\"line\">[定义与声明](https://www.cnblogs.com/damaohai/p/11497143.html)：区别在于是否分配空间（extern）  </span><br><span class=\"line\"></span><br><span class=\"line\">do...while(0)的作用：宏定义函数的时候解决“；”所带来的问题。宏跟函数的区别在于宏是把参数替换到指定位置（++a的例子），imgui中也有提到  </span><br><span class=\"line\"></span><br><span class=\"line\">C++类的内部可以定义引用数据成员，必须通过成员函数初始化列表初始化  </span><br><span class=\"line\"></span><br><span class=\"line\">const修饰的属性只能在构造函数里初始化，然后就不能用变量名改值了，但是可以直接控制变量所在的地址直接修改值  </span><br><span class=\"line\"></span><br><span class=\"line\">#pragma once：避免include重复引用一个文件  </span><br><span class=\"line\"></span><br><span class=\"line\">空类的sizeof为1：那是被编译器插进去的一个char ，使得这个知class的不同实体（object）在内存中配道置独一无二的回地址。</span><br><span class=\"line\"></span><br><span class=\"line\">类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域  </span><br><span class=\"line\"></span><br><span class=\"line\">``` delete p; ``` 实际意思是删除了p所指的目标（变量或对象），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放，指针p的真正释放是随着函数调用的结束而消失），释放堆空间后，p成了&quot;空指针&quot;。如果我们在delete p后没有进行指针p的制空（p=NULL)的话，其实指针p这时会成为野指针，为了使用的安全，我们一般在delete p之后还会加上p=NULL这一语句  </span><br><span class=\"line\"></span><br><span class=\"line\">包含纯虚函数的基类可定义指向派生类对象的基类指针和派生类对象的引用，不能直接定义自身对象  </span><br><span class=\"line\"></span><br><span class=\"line\">[print输出格式控制](https://blog.csdn.net/qq_37059136/article/details/80841675)</span><br><span class=\"line\"></span><br><span class=\"line\">vecotr的at和[]: v是个空集合的情况下，[]访问是行为未定义的，at访问则会抛出std::out_of_range异常。c++标准不要求vector&lt;T&gt;::operator[]进行下标越界检查，原因是为了效率，总是强制下标越界检查会增加程序的性能开销。设计vector是用来代替内置数组的，所以效率问题也应该考虑。  </span><br><span class=\"line\"></span><br><span class=\"line\">unique_ptr是智能指针的一种  </span><br><span class=\"line\"></span><br><span class=\"line\">comptr和unique_ptr的区别：  </span><br><span class=\"line\"></span><br><span class=\"line\">``` C++</span><br><span class=\"line\">auto_ptr&lt;string&gt; aps(new string(&quot;abd&quot;));</span><br><span class=\"line\">\tauto_ptr&lt;string&gt; aps2;</span><br><span class=\"line\">\taps2 = aps;</span><br><span class=\"line\">\tcout &lt;&lt; *aps &lt;&lt; endl;//报错 此时aps已经失去对string内存的所有权，如果是两个普通指针，则没有问题</span><br><span class=\"line\">\tcout &lt;&lt; *aps2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>\n<p>implicit conversion/explicit conversion:</p>\n<h1 id=\"pragma-comment-lib-”wpcap-lib”\"><a href=\"#pragma-comment-lib-”wpcap-lib”\" class=\"headerlink\" title=\"pragma comment ( lib,”wpcap.lib” )\"></a>pragma comment ( lib,”wpcap.lib” )</h1><p>表示链接wpcap.lib这个库。和在工程设置里写上链入wpcap.lib的效果一样（两种方式等价，或说一个隐式一个显式调用），不过这种方法写的 程序别人在使用你的代码的时候就不用再设置工程settings了。告诉连接器连接的时候要找ws2_32.lib，这样你就不用在linker的lib设置里指定这个lib了。  </p>\n<p>C++的钻石继承：dreaded diamond：  </p>\n<p>函数声明后边的const：const的函数不能对其数据成员进行修改操作。const的对象，不能引用非const的成员函数。  </p>\n<p>noexcept：该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。<br>如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。  </p>\n<p><a href=\"https://zhidao.baidu.com/question/748004411503788052.html\" target=\"_blank\" rel=\"noopener\">class和struct的区别</a>：最根本的引用类型和值类型</p>\n<p>volatile: A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</p>\n<p>vector &amp; list:<br>vector方便随机查询；扩容时因为它使用内存是连续的，会申请块更大的内存，造成整块内存的拷贝<br>list由双向链表实现，好增删，不好查询  </p>\n<p><a href=\"https://www.cnblogs.com/ghbjimmy/p/10636030.html\" target=\"_blank\" rel=\"noopener\">decltype</a>:有时我们希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量（初始化可以用auto）。为了满足这一需求，C++11新标准引入了decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tempA = <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*1.dclTempA为int.*/</span></span><br><span class=\"line\">    <span class=\"keyword\">decltype</span>(tempA) dclTempA;</span><br><span class=\"line\">    <span class=\"comment\">/*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize().*/</span></span><br><span class=\"line\">    <span class=\"keyword\">decltype</span>(getSize()) dclTempB;</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在C中，使用typedef定义struct在创建结构体是就不需要<figure class=\"highlight plain\"><figcaption><span>Student stu; ```了，直接使用typedef定义的别名例如S，``` S stu; ```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">unordered_map不能使用pair作为键值，需要提供pair的hash函数，map可以  </span><br><span class=\"line\"></span><br><span class=\"line\">hash_map与unordered_map: 前者使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存；</span><br><span class=\"line\">后者记录元素的hash值，根据hash值判断元素是否相同。  </span><br><span class=\"line\">速度上2最优其次hash_map最次map  </span><br><span class=\"line\"></span><br><span class=\"line\">&amp;  （位   “与”）  and  </span><br><span class=\"line\">^  （位   “异或”）  </span><br><span class=\"line\">|  （位   “或”）   or  </span><br><span class=\"line\">~  （位   “取反”）  </span><br><span class=\"line\"></span><br><span class=\"line\">位移运算符(&lt;&lt;/&gt;&gt;)：乘以/除以$2^n$</span><br><span class=\"line\"></span><br><span class=\"line\">整型最大最小值：INT_MIN,INT_MAX</span><br><span class=\"line\"></span><br><span class=\"line\">map&lt;&gt;如果不赋初值，不是NULL是0</span><br><span class=\"line\"></span><br><span class=\"line\">[vector](http://www.cnblogs.com/Nonono-nw/p/3462183.html)：向量</span><br><span class=\"line\">``` bash</span><br><span class=\"line\">#include &lt;vector&gt;;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://www.cnblogs.com/maluning/p/8570717.html\" target=\"_blank\" rel=\"noopener\">iterator</a>：迭代器  </p>\n<p><a href=\"https://www.cnblogs.com/cxq0017/p/6555533.html\" target=\"_blank\" rel=\"noopener\">STL中的基本容器</a><br>顺序容器：vector，list，deque等<br>关联容器：map，set等</p>\n<p>upper_bound, lower_bound:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// lower_bound/upper_bound example</span><br><span class=\"line\"><span class=\"comment\">#include &lt;iostream&gt;     // std::cout</span></span><br><span class=\"line\"><span class=\"comment\">#include &lt;algorithm&gt;    // std::lower_bound, std::upper_bound, std::sort</span></span><br><span class=\"line\"><span class=\"comment\">#include &lt;vector&gt;       // std::vector</span></span><br><span class=\"line\"></span><br><span class=\"line\">int <span class=\"function\"><span class=\"title\">main</span></span> () &#123;</span><br><span class=\"line\">  int myints[] = &#123;10,20,30,30,20,10,10,20&#125;;</span><br><span class=\"line\">  std::vector&lt;int&gt; v(myints,myints+8);           // 10 20 30 30 20 10 10 20</span><br><span class=\"line\"></span><br><span class=\"line\">  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30</span><br><span class=\"line\"></span><br><span class=\"line\">  std::vector&lt;int&gt;::iterator low,up;</span><br><span class=\"line\">  low=std::lower_bound (v.begin(), v.end(), 20); //          ^</span><br><span class=\"line\">  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^</span><br><span class=\"line\"></span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">\"lower_bound at position \"</span> &lt;&lt; (low- v.begin()) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">\"upper_bound at position \"</span> &lt;&lt; (up - v.begin()) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>a++/++a<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 1;</span><br><span class=\"line\">cout&lt;&lt;a++&lt;&lt;endl;  // 1</span><br><span class=\"line\">cout&lt;&lt;a&lt;&lt;endl;    // 2</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; &amp;nums;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(auto i : nums)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>unsigned 无符号的  </p>\n<p><a href=\"http://www.cplusplus.com/reference/unordered_map/unordered_map/?kw=unordered_map\" target=\"_blank\" rel=\"noopener\">unordered_map</a></p>\n<p>C++ struct 构造函数附默认值的写法：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct student&#123;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    student *child;</span><br><span class=\"line\">    bool sex;</span><br><span class=\"line\">    int check;</span><br><span class=\"line\">    student(int input):age(input),child(nullptr),sex(<span class=\"literal\">true</span>),check(1996)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int <span class=\"function\"><span class=\"title\">main</span></span>()&#123;</span><br><span class=\"line\">    student a = student(18);</span><br><span class=\"line\">    cout&lt;&lt;a.age&lt;&lt;a.sex&lt;&lt;a.check&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>out<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1811996</span><br></pre></td></tr></table></figure></p>\n<p>把指针运算符 * 应用到 var 上是完全可以的，但修改 var 的值是非法的。这是因为 var 是一个指向数组开头的常量，不能作为左值。<a href=\"https://www.runoob.com/cplusplus/cpp-pointers-vs-arrays.html\" target=\"_blank\" rel=\"noopener\">C++</a>  </p>\n<p><strong>指针</strong>int var; //var 输出：20<br>int<em> p; p = &var; //p 输出：地址<br>////////////////////</em>p 输出：20<br><strong>引用</strong>int&amp; a; a = var; //a 输出：20  </p>\n<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数  </p>\n<p>引用很容易与指针混淆，它们之间有三个主要的不同：  </p>\n<ol>\n<li>不存在空引用。引用必须连接到一块合法的内存。  </li>\n<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。  </li>\n<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。 </li>\n</ol>\n<p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。  </p>\n<p>new动态分配内存（只能new一个指针吗？不是），delete删除，delete [] pvalue</p>\n<p><a href=\"https://blog.csdn.net/fanyun_01/article/details/77430682\" target=\"_blank\" rel=\"noopener\">变长数组</a> 普通数组到vector 一维到多维  </p>\n<p>模板：函数模板/类模板  </p>\n<p>内联函数（inline属于ret-type）：啥时候用，ret-type还包括哪些？<br>减少了函数调用，但是增加目标代码的大小</p>\n<p><strong>boost库</strong>：准标准库</p>\n<p><code>string::find(&quot;a&quot;)</code> 如果没有找到”a”，会返回一个固定的大数，且等于<code>string::npos</code> 的值</p>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><p><a href=\"https://www.cnblogs.com/rinack/p/5695610.html\" target=\"_blank\" rel=\"noopener\">C#嵌套类型</a>：类里声明类。  </p>\n<p>struct是值类型，内存分配在栈上；  </p>\n<p>Action与Func是特殊的delegate：func必须有返回值，可以加0到若干个参数，action必须没有返回值，可以加0到若干参数；用event修饰的delegate更加安全。<br>EventHandler就是一个已经声明出来的delegate  </p>\n<p><strong>where and new()</strong><br>在C#中，泛型的使用非常广泛，为了泛型调用安全，经常需要对所使用的类型进行约束。<br>在对泛型的约束中，最常使用的关键字有where 和 new。<br>其中where关键字是约束所使用的泛型，该泛型必须是where后面的类，或者继承自该类。<br>new()说明所使用的泛型，必须具有无参构造函数，这是为了能够正确的初始化对象  </p>\n<p>静态多态性：函数重载、运算符重载<br>动态多态性：抽象类和虚函数（抽象类和接口的区别：抽象类比接口更详细点，可以继承多个接口，但只能一个类）</p>\n<p><strong>正则表达式得看看todo</strong></p>\n<p>装饰器 attribute 方法前边直接加个函数的区别</p>\n<h1 id=\"Unity\"><a href=\"#Unity\" class=\"headerlink\" title=\"Unity\"></a>Unity</h1><p>矩阵对应的几何变换 <a href=\"https://orangered3stones.iteye.com/blog/1940821\" target=\"_blank\" rel=\"noopener\">https://orangered3stones.iteye.com/blog/1940821</a><br>对于N+1维坐标表示的理解 <a href=\"https://www.cnblogs.com/btgyoyo/p/7085264.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/btgyoyo/p/7085264.html</a><br>碰撞检测 <a href=\"http://www.jmecn.net/tutorial-for-beginners/chapter-15-collision-detection.html\" target=\"_blank\" rel=\"noopener\">http://www.jmecn.net/tutorial-for-beginners/chapter-15-collision-detection.html</a></p>\n<p>基于组件的引擎架构：<br>派生关系，通过继承父类获得父类的功能，这些通用功能为了能够为各种派生类提供服务，都必须实现到基类中<br>不再是父类中的接口，而变成子对象实例，为游戏对象提供服务<br>组合和继承的区别<br>gameobject都派生自object 为什么<br>coroutine 生命周期 c#的语法 反射 代理 设计模式 工厂 单例 装饰器<br>设计模式 shader</p>\n<h1 id=\"todo\"><a href=\"#todo\" class=\"headerlink\" title=\"todo\"></a>todo</h1><p>C++ 语法，算法，引擎：A*再来一遍，多线程，模板，迭代器，网络同步<br>Unity 网络Unet，Mirror</p>\n","slug":"lang-notebook","updated":"2020-08-17T04:54:32.778Z","comments":true,"link":"","permalink":"/2019/02/18/lang-notebook/","excerpt":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"/categories/学习笔记/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"/tags/Unity/"},{"name":"C#","slug":"C","permalink":"/tags/C/"},{"name":"notebook","slug":"notebook","permalink":"/tags/notebook/"}]},{"title":"python数据分析、可视化相关笔记","date":"2019-01-21T13:23:34.000Z","path":"2019/01/21/Kaggle笔记/","text":"python数据分析、可视化相关笔记我的主页 sklearn-tsne提供了数据可视化的工具：TSNE提供了一种有效的降维方式，让我们对高于2维数据的聚类结果以二维的方式展示出来pytorch的dataloader出来有三个部分（编号，tensor（图片内容信息（100张，1个通道，长，宽）），tensor（标注））","raw":"---\ntitle: python数据分析、可视化相关笔记\ndate: 2019-01-21 21:23:34\ntags:\n    - 数据分析\n    - 数据可视化\n    - Kaggle\ncategories: 学习笔记\n---\n\n# python数据分析、可视化相关笔记\n\n[我的主页](https://www.kaggle.com/taye310)\n\nsklearn-tsne提供了数据可视化的工具：TSNE提供了一种有效的降维方式，让我们对高于2维数据的聚类结果以二维的方式展示出来  \npytorch的dataloader出来有三个部分（编号，tensor（图片内容信息（100张，1个通道，长，宽）），tensor（标注））","content":"<h1 id=\"python数据分析、可视化相关笔记\"><a href=\"#python数据分析、可视化相关笔记\" class=\"headerlink\" title=\"python数据分析、可视化相关笔记\"></a>python数据分析、可视化相关笔记</h1><p><a href=\"https://www.kaggle.com/taye310\" target=\"_blank\" rel=\"noopener\">我的主页</a></p>\n<p>sklearn-tsne提供了数据可视化的工具：TSNE提供了一种有效的降维方式，让我们对高于2维数据的聚类结果以二维的方式展示出来<br>pytorch的dataloader出来有三个部分（编号，tensor（图片内容信息（100张，1个通道，长，宽）），tensor（标注））</p>\n","slug":"Kaggle笔记","updated":"2019-05-04T11:31:57.266Z","comments":true,"link":"","permalink":"/2019/01/21/Kaggle笔记/","excerpt":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"/categories/学习笔记/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"/tags/数据分析/"},{"name":"数据可视化","slug":"数据可视化","permalink":"/tags/数据可视化/"},{"name":"Kaggle","slug":"Kaggle","permalink":"/tags/Kaggle/"}]},{"title":"关于三维重建的文献综述","date":"2019-01-03T23:58:17.000Z","path":"2019/01/04/关于三维重建的文献综述/","text":"目录arXiv检索 1812.10558 通过视频素材实现从2d到3d的面部重建来完成测谎 1812.01742 单一视角的三维重建，使用对抗训练（非人 1812.05583 基于学习的ICP（迭代最近点算法）重构场景（非人 1812.07603 通过视频素材的面部模型学习 1812.05806 自我监督的引导方法，单图片的三维人脸重建 1812.02822 学习生成模型的隐藏区域（非人 1901.00049 基于轮廓的衣着人物（全身 A类 通过直接体积cnn回归从单图重建大范围三维人脸（源码lua+py 使用图到图转换的无限制面部重建（源码lua 老师推荐 使用affinity field的实时多人二维姿态估计 综述通用关于三维重建单个图像进行三维重建的数据驱动方法：一是明确使用三维结构，二是使用其他信息推断三维结构2DImage—&gt;encoder—&gt;latent representation—&gt;decoder—&gt;3DObject不同方法区别在于对三维世界采取的限制：多视图一致性学习三维表示、利用关键点和轮廓注释、利用2.5D草图（法线，深度和轮廓）改善预测 encoder-decoder的含义 关于shape priors许多方法选择更好的捕捉多样的真实形状non-deep方法关注低维参数模型，使用CNN来学习2D渲染图像和3D形状的共同嵌入空间其他方法依赖生成模型去学习shape priors 博客链接3D人脸重建学习笔记CSDN3D重建的学习笔记简书 Learning Single-View 3D Reconstruction with Adversarial Training 1812.01742传统方法用多个角度的多张照片实现三维建模问题两个：一是需要大量的观察点；二是物体表面是Lambertian（非反射）albedos是非均匀的另一种三维重建的方式是利用物体外观和形状的知识从单视图二维图像生成（假设shape priors足够丰富）CAD库（computer-aided design）：shapenet，pascal3d+，objectnet3d，pix3d 这些方法都从渲染的图像中回归三维形状：将二位图像转化成潜在表示的编码器 以及 重建三维表示的解码器为了学习shape priors深度学习算法需要大量的三维对象注释，自然图像中获取三维注释很有挑战，因此使用合成图像（三维模型渲染出的图像）CNN的domain shift问题，导致基于cnn的三维重建性能恶化 这篇文章的方法：提高重建模型性能，为了实现获取三维物体标签，他们shape priors训练出的网络有个重建损失值，给这个值引入了两个限制一是受domain shift文献启示，强制让编码的二维特征不变，对应于他们所来自的domain。这样合成图像训练出的编码器在真实图像上表现更好二是将编码的二维特征限制在现实物体的多种形状之中，通过对抗训练定义这两个损失值总结：一个模型和损失函数，利用shape priors提高自然图像三维重建性能（两种方式使用对抗训练）reconstruction adversarial network(RAN)只使用rgb图像信息，和易于获取的自然图像。独立于编码器和解码器，并且可以使用到其中借鉴了domain confusion（作用是classification），为了让从合成图像里训练出来的模型在真实图像这边有更好的表现 具体方法：todo 通过直接体积cnn回归从单图重建大范围三维人脸目前三维人脸重建的方法多假定有多张面部图片可以使用，这使得重建面临方法上的挑战：在夸张的表情、不均匀光照上建立稠密对应关系这些方法需要复杂低效的管道构建模型，拟合模型。本文建议通过在由2D图像和3D面部模型或扫描组成的适当数据集上训练卷积神经网络（CNN）来解决这些限制 Extreme 3D Face Reconstruction: Seeing Through Occlusions 极端3D面部重建：遮挡透视（讲）bumpingmapping概念的推动下，该文提出了一种分层方法。将全局形状与其中细节进行解耦。估计粗糙的3d面部形状为基础，然后将此基础与凹凸贴图表示的细节分开。与本文相关的工作： reconstruction by example 这类方法用三维脸部形状去调整根据输入图片估计出的模型，降低了观看条件却损失了真实度与准确性 face shape from facial landmarks 这类方法稳定但是模型都差不多，没有细节，而且不清楚遮挡landmark的情况下表现会如何 SfS Shape-From-shading 根据光反射生成细节丰富的模型，但是受环境影响严重，需要满足其对环境的特殊要求。任何遮挡物都会生成到模型中 statistical representations 最著名的方法是3DMM，这篇文改进了这个方法直接根据图片强度信息用cnn回归3DMM的参数和面部细节 deep face shape estimation 深度网络一是直接用深度图重建，二是estimate 3D shapes with anemphasis on unconstrained photo 观察条件高度不变但是细节模糊 准备工作矛盾：整体形状的高度正则化vs细节的弱正则化。解决方法：bump map representations which separate global shape from local details 理解的正则化：使模型更有普适性，低正则化是让模型有更多细节、更有特点，反之是让模型更接近普适的规则（每个模型都有一只鼻子一张嘴两只眼睛）给一张图片建立以下几个部分：基础形状——S，面部表情——E，6维度的自由视点——V。接下来是bump map捕捉中级特征（皱纹等非参数的），最后完成因遮挡丢失的细节。添加细节基础形状使用3DMM，3DMM用了resnet的101层网络架构。表情部分由3DDFA提供，更新的有expnet。确定视点用了deep，facepostnet。中等程度细节：image to bump map，修复遮挡细节，基于软对称的模型完善。LFW验证 PPT用：目的：现有单图三维重建局限性很高，必须在正前方、距离近、无阻挡的视点，该文设计了一种用于在极端条件下提供细节丰富的面部三维重建模型的系统。极端条件包括，头部旋转以及遮挡方法：简单讲步骤，关键的创新点，值得学习的点后边会细说。总的来说：先创建面部整体的基础形状，与局部细节分开，在基础形状之上建立中等程度的面部特征。这样做可以保证极端条件下整体面部形状的稳定性。其他较新的方法往往用局部细节构建整体形状。 构建基础形状s，构建面部表情e，构建视点v：凹凸图可以分离整体形状和局部细节这仨东西分别是干什么用的：基础形状使用3DMM，3DMM用了resnet的101层网络架构。表情部分由3DDFA提供，更新的有expnet。确定视点用了deep，facepostnet。image to bump map转换凹凸图训练集：用深度编码-解码框架生成凹凸图学习建立凹凸图：定义了自己的网络损失函数，可以在不牺牲高频细节的情况下抑制噪声还原遮挡细节给予范例的空洞填充方法搜索参考集混合细节更复杂的修补基于软对称的模型补全 贡献：解决对foundation的高度正则化 VS 对detail的低正则化 两者的矛盾 注： bump map使用灰度值来提供高度信息，normal map使用xyz轴所对应的rgb信息 卷积与反卷积 跑demo流程： NVIDIA-docker启动container，如果跑代码没有driver重新run一个，用readme里的run命令。 之后会出现860m只支持cuda5.0的报错，需要从源码编译pytorch。首先docker里装anaconda wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2018.12-Linux-x86_64.sh 应该不用在docker里装cuda和cudnn，直接安装pytorch的依赖然后安装pytorch应该就可以 在1080上不会出现上边的报错，完全按照README走就行。 PPT Learning to Estimate 3D Human Pose and Shape from a Single Color Image(讲) DOI:10.1109/CVPR.2018.00055SCAPE: shape completion and animationof peopleSMPL: A skinned multi-person linear modelSMPL是一种参数化人体模型，与非参数化模型的区别在于，参数化的可以用函数映射的方式表达出来，或者说是可以解析的？非参数化则认为是通过实验记录到的模型，不存在解析表达式。 Stacked Hourglass Networks资料一资料二 feature mapchannel:卷积核个数、特征图个数、通道个数关系 PPT O-CNN: Octree-based Convolutional Neural Networks for 3D Shape Analysis还有adaptive o-cnnThe main technical challenge of the O-CNN is to parallelize the O-CNN computations defined on the sparse octants so that they can be efficiently executed on the GPUWe train this O-CNN model with 3D shape datasets and refine the O-CNN models with different back-ends for three shape analysis tasks, including object classification, shape retrieval, and shape segmentation. Pixel2Mesh（讲）code编译tensorflow math_functions.hpp找不到。需要软链接这个玩意ln -s /usr/local/cuda/include/crt/math_functions.hpp /usr/local/cuda/include/math_functions.hpp 关于eigen和cuda资料makefile怎么写。hdf5 HDF（Hierarchical Data Format）是一种设计用于存储和组织大量数据的文件格式 CUDACC_VER is no longer supported.的报错看来要更新eigen3才能解决github上新版eigen考到anaconda的eigen和support里就可以成功编译cuda了 图卷积神经网络资料图卷积神经网络材料所有的卷积都是在探讨如何对局部数据按照某一个操作聚合，不同的操作方式就对应于不同的卷积。学习卷积核的过程其实是学习局部聚合参数的过程 PPT SMPL: A Skinned Multi-Person Linear Model(多篇基础，15年)Video Based Reconstruction of 3D People Models(讲，没用网络) DOI:10.1109/CVPR.2018.00875 (video2mesh)第五页第一张图解决了人体非刚性的问题但是问题在于人必须转身后摆出相同的姿势 不允许姿势变化第二张图 可以随意动 不同时刻的深度图非张性的注册并融合到一个template上存在 phantom surface的问题 运动的快会四肢胳膊 两个头第三个 加了一个static的人体模型作为约束 运动速度可以更快 第一个使用rgb相机 并且支持用户运动的重建方法主要思想 和visual hull相似 不同角度拍摄剪影进行重建visual hull的基本原理 几个角度拍摄 分割出前景得到silhouette然后从相机坐标到silhouette的每一个点可以做一条射线 形成的曲面成为silhouette cone用这些cone作为约束就可以重建出三维模型 可以类比为雕刻的过程去掉cone之外的部分 最终剩下的部分就是人体的形状 标准的vh的问题是只能用于静态的物体 这篇的主要是讲怎么把vh用到动态的物体第八页 每帧姿势都不一样 要做的就是去除由于运动对cone造成的变化 称为unpose的过程用unpose的cone做三维重建 使用的人体的三维表达：smpl 参数化模型 T是template的mean shape，Bs是体型变化造成的模型变化Bp是pose的变化带来的变化问题在于没有办法model衣服头发面部特征 基础上加了D offset用于表达smpl表达不了的信息 四个步骤1 前景分割 获取silhouette cone， tracking获取人体模型的姿态2 利用pose信息做unpose操作 转到Tpose姿态下3 人体重建 包含衣服 头发 人脸的人体模型4 多视角图像生成人体贴图 1 基于cnn的方法 2d drawn detection 图像分割的方法 前景分割生成silhouette优化第12页的能量函数 进行pose tracking //简单来说就是求最优的pose和shape的参数 和模型匹配到检测到的2d drawn detection和silhouette上//2 第一步得到的cone进行unpose 每一条射线进行unpose转到canonical pose下//两个数学表达式 射线的转换//任何一点vi 和 任何一条射线ri3 利用unpose后的cone做三维重建 称为consensus shape，相比较SMPL/视频表现出的是可以对衣服进行重建过程可以通过优化一个能量公式实现Edata：模型上的点到unpose ray的距离三个正则项：lap保证局部光滑，body保证重建出的与smpl差距不大，symm保证左右对称4 有了几何信息后 生成appearance信息 生成texture map 第一步有每一帧的pose，精确的将模型覆盖到图像上通过//重投影获得贴图// 用sfs（之前的文章有提到）可以提供更多细节，本文方法可以提高的地方对能量函数的理解：构建能量函数就是我们用方程的最小值来描述我们想要达到的实际效果。资料 第一步最费时间 一帧一分钟 model和silhouette的匹配费时间穿裙子解决不了 改变不了smplmodel的拓扑结构 拉不过去基于cnn的分割已经接近于完美了 用的别人的方法 不是重点给纹理图上色：consensus shape 结合第一步的pose 精确匹配到每一帧的图像上 back projection ppt Learning to Reconstruct People in Clothing from a Single RGB Camera（2019.4video2mesh延伸论文，同一实验室）octopus安装dirt遇到的问题：https://github.com/pmh47/dirt/issues/23已经尝试过cuda10.1/10.0/9.2 cudnn都是对应版本，tensorflow单独测试成功更改gcc/g++版本：https://blog.csdn.net/u012925946/article/details/84584830 最终安装dirt解决方法是：ubuntu 18.04，cuda 8.0，cudnn 6.0，tf 1.4.0，driver 396.54注意conda install 的 cudatoolkit和cudnn不能取代本机安装的cuda和cudnn，也就是说本机要安cuda，cudnn，conda装tf时要装cudatoolkit，cudnn 先装tensorflow再装-gpu 才能启用gpu 前者版本不能比后者高，libcudnn.so.x报错需要在conda里安装tf，tf-gpu。注意版本匹配 跑Octopus的实验时需要scipy&gt;=1.0.0numpy&gt;=1.16Keras&gt;=2.2.0tensorflow_gpu&gt;=1.11.0dirt否则会报：12345678910111213141516171819202122232425262728293031323334(video2mesh) ty@ty-GE60-2PF:~/repos/octopus$ bash run_batch_demo.sh Using TensorFlow backend.2019-05-29 15:18:24.784883: I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA2019-05-29 15:18:24.835566: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:892] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero2019-05-29 15:18:24.835835: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1030] Found device 0 with properties: name: GeForce GTX 860M major: 5 minor: 0 memoryClockRate(GHz): 1.0195pciBusID: 0000:01:00.0totalMemory: 1.96GiB freeMemory: 1.08GiB2019-05-29 15:18:24.835855: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -&gt; (device: 0, name: GeForce GTX 860M, pci bus id: 0000:01:00.0, compute capability: 5.0)Processing sample...&gt; Optimizing for pose... 0%| | 0/10 [00:00&lt;?, ?it/s]Traceback (most recent call last): File \"infer_batch.py\", line 87, in &lt;module&gt; main(args.weights, args.num, args.batch_file, args.opt_steps_pose, args.opt_steps_shape) File \"infer_batch.py\", line 46, in main model.opt_pose(segmentations, joints_2d, opt_steps=opt_pose_steps) File \"/home/ty/repos/octopus/model/octopus.py\", line 290, in opt_pose callbacks=[LambdaCallback(on_batch_end=lambda e, l: pbar.update(1))] File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/engine/training.py\", line 1010, in fit self._make_train_function() File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/engine/training.py\", line 509, in _make_train_function loss=self.total_loss) File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/legacy/interfaces.py\", line 91, in wrapper return func(*args, **kwargs) File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/optimizers.py\", line 475, in get_updates grads = self.get_gradients(loss, params) File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/optimizers.py\", line 89, in get_gradients grads = K.gradients(loss, params) File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/backend/tensorflow_backend.py\", line 2757, in gradients return tf.gradients(loss, variables, colocate_gradients_with_ops=True) File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/tensorflow/python/ops/gradients_impl.py\", line 555, in gradients (op.name, op.type))LookupError: No gradient defined for operation 'smpl_body25face_layer_1_7/smpl_main/Svd' (op type: Svd) 显卡驱动还崩了 用ubuntu自带的怎么切驱动nvidia-smi都会报一行错NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installedand running.然后切不懂了卡在390 有这个问题https://askubuntu.com/questions/1035409/installing-nvidia-drivers-on-18-04 2019.6.4 https://github.com/pmh47/dirt/issues/6 dirt inside cmakecache.txt add -DNDEBUG to CMAKE_CUDA_FLAGS:STRING https://github.com/pmh47/dirt/issues/23tensorflow.python.framework.errors_impl.NotFoundError: /home/ty/repos/dirt/dirt/librasterise.so: undefined symbol: _ZN10tensorflow12OpDefBuilder4AttrESs should not use conda install tensorflow &amp; tensorflow-gpu, use pip install instead nvidia driver keeps the newest one. 1234567891011(dirt) zhangtianyi@likun-ThinkStation:~/github/dirt$ python tests/square_test.py Traceback (most recent call last): File \"tests/square_test.py\", line 4, in &lt;module&gt; import dirt File \"/home/zhangtianyi/github/dirt/dirt/__init__.py\", line 2, in &lt;module&gt; from .rasterise_ops import rasterise, rasterise_batch, rasterise_deferred, rasterise_batch_deferred File \"/home/zhangtianyi/github/dirt/dirt/rasterise_ops.py\", line 6, in &lt;module&gt; _rasterise_module = tf.load_op_library(_lib_path + '/librasterise.so') File \"/home/zhangtianyi/anaconda3/envs/dirt/lib/python2.7/site-packages/tensorflow/python/framework/load_library.py\", line 61, in load_op_library lib_handle = py_tf.TF_LoadLibrary(library_filename)tensorflow.python.framework.errors_impl.NotFoundError: /home/zhangtianyi/github/dirt/dirt/librasterise.so: undefined symbol: _ZN10tensorflow12OpDefBuilder4AttrESs 成功安装后test时出现上边的问题 -d_glibcxx_use_cxx11_abi=0改成1 gcc/g++版本从4.9换到5重装dirt就好了 总结：py2.7 tf1.13.2 cuda 显卡驱动装新的 setup.py里的dependence去掉用conda装 cmakelists.txt cmake_flag 加-d_glibcxx_use_cxx11_abi=1 change CMakeLists.txt line5 intofind_package(OpenGL REQUIRED COMPONENTS OpenGL EGL)comment line9line53 intotarget_link_libraries(rasterise OpenGL::OpenGL OpenGL::EGL ${Tensorflow_LINK_FLAGS})As a hack, you can try directly linking the correct library: remove EGL from line 5 of CMakeLists (so FindOpenGL no longer searches for it), and at line 52, replace OpenGL::EGL by /usr/lib/nvidia-384/libEGL.so.1.1.0 cmake ../csrc -D_OPENGL_LIB_PATH=/usr/lib/nvidia-390. 对应驱动版本 cmakecache.txt 加-dndebug make cd .. \\ pip install -e . tests 笔记本会卡死！！！ Neural Body Fitting: Unifying Deep Learning and Model Based Human Pose and Shape Estimation（3DV 2018）intro已经有很多成功的工作，生成人体关键点，棒状表示模型（火柴人）（说的就是openpose）这里作者提出的是基于smpl的更具挑战性的任务：estimating the parameters of a detailed statistical human body model from a single image Traditional model-based approaches typically optimize an objective function that measures how well the model fits the image observations传统的需要一个差不多初始化模型，然后把初值优化到最终结果（不需要3d训练数据——带3d动作标注的图片）CNN就是forward prediction models，就不需要initialization，但是需要3d姿态标注，不像2d标注好获得 他们近期的工作通过把重建出的模型投影回2d空间更新损失函数，就可以使用2d标注了本文的目的：To analyze the importance of such componentscomponents: image—(CNN,3d notation trained)—&gt;smpl model(hybird params)—&gt;image—(reproject)—&gt;2d notation for CNN training要形成闭环（loop）NBF = 一个包含统计身体模型的CNN两种监督模式：full 3d sup和weak 2d sup，bottom-up top-down的方法，使得NBF既不需要初始化模型也不需要3d标注的训练数据因为光照、衣服、杂乱的背景都不想要，专注于pose和shape，所以用处理后的image代替原始rgb image结论： 12-body-part的分割就包含了足够的shape和pose信息 这种处理后图像的方法比起用原图，效果有竞争力，更简单，训练数据利用率更高 分割质量可以强有力预测fit质量 总结： unites deep learning-based with traditional model-based methods an in-depth analysis of the necessary components to achieve good performance in hybrid architectures and provide insights for its real-world applicability related workMost model-based approaches fit a model to image evidence through complex non-linear optimization, requiring careful initialization to avoid poor local minima.用2d关键点是为了降低fitting复杂度lifting to 3D from 2D information alone is an ambiguous problem 前人的工作有用rgb image的/image+2d keypoint的/2d keypoint+silhouette的NBF不需要初始化模型，用semantic segmentation做图片代理输入，原因有三： 去除与3dpose无关的图像信息 比keypoint和silhouette语义信息多 允许分析精细程度（粒度）和placement对3d预测的重要程度 三个数据集UP-3D，HumanEva-I，Human3.6M 三个数据集UP-3D,HumanEva-I,Human3.6M up-3d有大量smpl形式的3d标注 其他数据集： HumanEva-I使用方法：To be able to use HumanEva-I dataset you must do the following: Sing up and agree with the license or Login if you already have an account. Download the entire HumanEva-I dataset as either zip or tar archive depending on your system. Download critical HumanEva-I update and update the OFS files. Download the latest source code. (optional) Download background statistics (optional) Download the surface model for subject S4. 装matlab, XVID codec, DXAVI toolbox, Camera Calibration Toolbox for Matlab给matlab指定了mingw作为c++编译器 1234567Undefined function or variable 'dxAviOpenMex'.Error in dxAviOpen (line 3) [hdl, t] = dxAviOpenMex(fname);Error in testDxAvi (line 4)[avi_hdl, avi_inf] = dxAviOpen([pathname, filename]); 运行mex_cmd出现 12F:\\datasets\\HumanEva-I\\Release_Code_v1_1_beta\\TOOLBOX_dxAvi\\dxAviHelper.h:9:21: fatal error: atlbase.h: No such file or directory #include &lt;atlbase.h&gt; 应该是没有这个库的原因，有说是visual studio的库，打算装个vs2019 ATL库试试matlab不支持2019 mex -setup -v可以看到指搜索到vs2017所以装了vs2015，atlbase就可以了123456Building with 'Microsoft Visual C++ 2015'.Error using mexdxAviOpenMex.cppBaseClasses\\ctlutil.h(278): error C4430: missing type specifier - int assumed. Note: C++ does not support default-intg:\\grads\\3dreconstruction\\humaneva-i\\release_code_v1_1_beta\\toolbox_dxavi\\dxAviHelper.h(15): fatal error C1083: Cannot openinclude file: 'qedit.h': No such file or directory 原因在这里link github上找了win64编译好的.m脚本，解决。 todo 怎么做validation 实验复原实验 Extreme 3D Face Reconstruction: Seeing Through Occlusions Github 环境：linux docker镜像 依赖： our Bump-CNN our PyTorch CNN model the Basel Face Model 3DDFA Expression Model 3DMM_model dlib face prediction model Learning to Reconstruct People in Clothing from a Single RGB Camera Github 环境：linux tf 依赖： DIRT SMPL model pre-trained model weights 备注：图片预处理需要 PGN semantic segmentation：Linux/tensorflow Code OpenPose body_25 and face keypoint detection：Win .exe Neural Body Fitting: Unifying Deep Learning and Model Based Human Pose and Shape Estimation Github 环境：win/linux tensorflow-gpu==1.6.0 依赖： SMPL model(跟上边的还有区别) segmentation model fitting model 备注：没training code tex2shape： hmr hmd shift-net 数据集 HumanEva-I 环境：win/linux matlab 依赖：几个toolbox其中dxavi用的github上编译好的.m UP-3D 环境： 依赖： Human3.6M 注册不通过（20190716） repos repo name description VideoPose3D 3D human pose estimation in video with temporal convolutions and semi-supervised training smplify-x Expressive Body Capture: 3D Hands, Face, and Body from a Single Image neural_body_fitting Neural Body Fitting code repository octopus Learning to Reconstruct People in Clothing from a Single RGB Camera videoavatars Video based reconstruction of 3D people models extreme_3d_faces Extreme 3D Face Reconstruction: Seeing Through Occlusions 3Dpose_ssl 3D Human Pose Machines with Self-supervised Learning pose-hg-train Training and experimentation code used for “Stacked Hourglass Networks for Human Pose Estimation” PRNet Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network (ECCV 2018) vrn Large Pose 3D Face Reconstruction from a Single Image via Direct Volumetric CNN Regression openpose OpenPose: Real-time multi-person keypoint detection library for body, face, hands, and foot estimation Codevscode想在不同的conda环境下都有类型提示和跳转需要在vscode里切环境ctrl+shift+P —&gt; python:select interpreter —&gt; {your env}官方文档 import tensorflow 没有报错也没有反应：tensorflow-gpu跟conda安装的opencv有冲突！！改用pip install opencv-python就解决了 同文件夹下module import要加.1234import tensorflow as tffrom .batch_smpl import SMPLfrom .joints import joints_body25, face_landmarksfrom keras.engine.topology import Layer git-lfs在fork的repo上使用会有问题 “can not upload new objects to public fork” python moduletqdm: process bar toolgreenlet/gevent: 协程工具 octopus 流程：读文件（segmentation/pose） png和json文件K.set_session启动tfsession声明model（octopus），加载weights解析segm：io.py里有解析segmentation的方法解析pose优化pose优化shape生成模型（点和面的list）写入obj（write_mesh） opt_pose:两组数据: data/supervisionopt_pose_model.fit(): opt_shape:data/supervisionopt_shape_model.fit() 想尝试把dirt换了，用别的differentiable renderer tex2shapedecectron2（pytorch环境）先做uv图tex2shape出模型，因为显存不够影响了重建效果（用video2mesh的conda环境就可以（tensorflow+keras））目前的代码是否可以训练模型，hdf5文件怎么生成（keras的hdf5文件，就是tf的ckpt，model.save就完事了，现在主要问题是fit train data） hmr End-to-end Recovery of Human Shape and Pose有train code，可他妈太妙了数据预处理步骤： 数据集lsp —&gt; tfrecord datasets LSP and LSP extended COCO we used 2014 Train. You also need toinstall the COCO API for python. MPII MPI-INF-3DHP Human3.6M Download link to MoSh 训练数据预处理TFRecord:数据序列化成二进制的工具 keraskeras.layers.Lambda(function, output_shape=None, mask=None, arguments=None)Wraps arbitrary expression as a Layer object. keras.backend: At this time, Keras has three backend implementations available: the TensorFlow backend, the Theano backend, and the CNTK backend. LambdaCallback() 要解决的问题 现有数据集的数据怎么处理到能用在smpl上 ！！（解决 hmr里解决了训练数据—&gt;tfrecord的过程） 确定量化指标 ！！（解决 hmr有evaluation） 确定遮挡情况下的重建效果！！（hmr，tex2shape，octopus，360texture那个） 实验室/作者汇总 名称 文章 链接 MPI SMPL/Octopus/.. https://virtualhumans.mpi-inf.mpg.de/ UCB(Angjoo Kanazawa) 预测人体动作/动物形体重建 https://people.eecs.berkeley.edu/~kanazawa/ 周晓巍(浙大) .. http://www.cad.zju.edu.cn/home/xzhou/ 技术要点汇总 文章名称 完成任务 技术要点描述 end to end recovery of human shape and pose(HMR) an end-to-end framework for reconstructing a full 3D mesh of a human body from a single RGB image 不知道速度怎么样，其他的有做到实时的了 不计算2d/3d joint position，使用了一种高效的mesh representation parameterized by shape and joint angles hmd 分阶段deformation hmr做基础模型，找到joint，anchor关键点deformation，在产生个深度图做vertex级别的deformation deephuman 不用smpl，直接从image用cnn还原三维结构 用了带语义的三维信息semantic volume bodynet 不用smpl hmd里提到的，不用smpl，用cnn找joint找sil构建3d pose再用cnn构建volumetric shape，用smpl监督算一个3d loss。总之就是多loss联合监督回归三维体积 Deep Textured 3D Reconstruction of Human Bodies 不用smpl hmd里提到的 double fusion 用的单个深度摄像头，做到实时三维人体重建 内外两层模型，里边是smpl外层可以根据深度信息较大幅度的拟合RGB图像 hyperfusion 单个深度摄像头+IMUs 惯性测量 在处理快速动作，遮挡情况比df更好，这俩重点在于捕捉连贯动作 Learning to Reconstruct People in Clothing from a Single RGB Camera(Octopus) 视频1-8帧做人体重建，10秒完成（说是速度快，但是其他的有做到实时的了） 速度快归功于两点：Tpose下完成特征融合；using both, bottom-up and top-down streams（？？不理解回头看看） Tex2Shape: Detailed Full Human Body Geometry from a Single Image 单图重建模型，用了detectron的densepose对图像预处理出IUV图，然后根据原图+IUV图出模型 前置条件detectron/densepose/smpl Multi-Garment Net: Learning to Dress 3D People from Images Learning to Estimate 3D Human Pose and Shape from a Single Color Image 周晓巍 跟hmr差不多 hmr用了个判别器，这个用三维模型投影回二维平面做监督 Learning 3D Human Dynamics from Video single image预测人体3D past and future motion present a framework that can similarly learn a representation of 3D dynamics of humans from video via a simple but effective temporal encoding of image features Predicting 3D Human Dynamics from Video 跟上边都是UCB的Predicting Human Dynamics (PHD), a neural autoregressive model that takes a video sequence of a person as input to predict the future 3D human mesh motion LiveCap:Real-time Human Performance Capture from Monocular Video the first real-time human performance capture approach that reconstructs dense, space-time coherent deforming geometry of entire humans in general everyday clothing from just a single RGB video 应该是预处理阶段重建模型（需要花费时间），实时添加动作。重点解决两个非线性优化问题，提出两阶段（stage）解决思路 Three-D Safari: Learning to Estimate Zebra Pose, Shape, and Texture from Images “In the Wild” 不需要图像分割/关节点标注的动物模型重建 SMAL PVNet: Pixel-wise Voting Network for 6DoF Pose Estimation 对象姿态估计旨在检测对象并估计其相对于规范框架的方向和平移 PVNet predicts unit vectors that represent directions from each pixel of the object towards the keypoints. These directions then vote for the keypoint locations based on RANSAC//vector-field presentation 实验规划 hmr：End-to-end Recovery of Human Shape and Pose octopus 有模型 有纹理贴图 用了Detailed Human Avatars from Monocular Video.的贴图方法 tex2shape 这个有衣服的细节 试试有遮挡的情况下重建效果怎么样 Learning 3D Human Dynamics from Video Multi-Garment Net: Learning to Dress 3D People from Images pvnet 遮挡截断情况下可以做6DoF Pose Estimation 周计划2019.10.21 现有数据集的数据怎么处理到能用在smpl上 ！！（hmr有dataset—&gt;tfrecord的code） 确定量化指标 ！！ （hmr：跟3d groundtruth 点对点算距离，数据集human3.6m — 这东西不知道啥时候能下载） 2019.10.28 处理输入图片准备test（图片加遮挡，截断，运动模糊） hmr、octopus、tex2shape 进行test test结果进行量化评估 2019.11.4 复原结果汇总 贴图怎么上 量化指标 2019.11.11 训练code跑起来 量化指标 日报2019.10.28hmr，tex2shape环境部署todo：处理输入图像，查看结果 2019.10.29hmr结果已出，tex2shape需要densepose预处理图片，需要看看densepose对于遮挡，截断，运动模糊的处理情况todo densepose结果查看 2019.10.30detectron2可以用了，但是2提供的densepose的visualization mode不全，没有IUV，导致作为tex2shape的输入会有问题。还需要继续想办法todo：hmr基本上没有细节，只有pose和大致shape，接下来要主要关注tex2shape在有遮挡的情况下细节重建的效果找两个带贴图repo试试，octopus/garment/360evaluation没有human3.6做不了，那边注册不通过没法下载 2019.10.31摸鱼 2019.11.1detectron2里的densepose没法出IUV的图，不太明白IUV这个图怎么用opencv出。只能在densepose结果图上做遮挡看看tex2shape的重建效果了完成hmr/tex2shape的遮挡测试，todo：octopus/还有smpl加贴图 2019.11.2/3休 2019.11.4dirt 有个undefined symbol 大概率是跟显卡驱动 cuda版本有关系 因为笔记本上就装上了dirt装不上garment也没法跑，得想办法用opendr代替dirtdirt装上后有个segmentfault 明天继续看整理tex2shape/hmr/octopus的结果明天看看贴图怎么搞，octopus用了个方法，还有garment那个的 2019.11.5octopus keras.base_layer会报个参数错误densepose(tex2shape)不知道怎么出IUVgarment(上贴图的)用了MPI-IS的mesh组件 需要python3TODO: humaneva, garment, Semantic Human Texture Stitching 2019.11.6量化指标：the mean per-pixel error of 3d displacements maps中文叫位移贴图/与凹凸贴图（法线贴图属于凹凸图），高度图不同贴图挺顺利的，理论上所有smpl的模型都适用。贴图这边接下来要看怎么用自己的数据（从img—&gt;pkl—&gt;texture）octopus还是不行 操他妈的(keras outputs不是layer类型的，不知道为什么)（11.6更新：因为当时smpl()改成了smpl.call()，还是要走基类的call()的不然不是Layer类型）Lambda表达式是核心问题 明天看 2019.11.7Octopus解决了，Lambda表达式没问题，smpl那个继承了Layer的类在调用call()时调用了call()，后者参数数量与基类Layer的call()参数数量不一致，导致了问题hmr的训练需要groundtruth 3d，先放着吧看effective C++(4/5) 2019.11.8数据集MPI_inf_3dhp/MPII/COCO 下载下载数据集coco/mpii/mpi_inf_3dhp学习dx12 2019.11.9/10休 2019.11.11coco/lsp/lsp_ext/mocap_neutrMosh/mpii/mpi_inf_3dhp —&gt; tfrecordhmr train code在tf1.14上有问题 降到1.4试试（conda最低1.4） hmr官方用的1.3//客制的有pytorch0.4的trainer.py的train()有问题 —&gt; sess.run时间太长了 1.4得调cuda版本 还是用1.14 2019.11.12三个新论文 看起来实验会好做一些 train code/dataset都有： PyTorch implementation of CloudWalk’s recent work DenseBody https://arxiv.org/pdf/1903.10153.pdf github Repository for the paper “Convolutional Mesh Regression for Single-Image Human Shape Reconstruction” github Detailed Human Shape Estimation from a Single Image by Hierarchical Mesh Deformation (CVPR2019 Oral) github 2019.11.13看看十大排序七大查找算法（3-0）hmd demo没啥问题 看看train 需要upi的数据集44g 这周五再下evl的用了wild dataset 1.9g//RECON and SYN test 2019.11.14排序/查找算法 2019.11.15upi_s1h//human36m_washed//two test dataset for hmd(eval recon and syn sets//wild set) 2019.11.16/17休 2019.11.18train without coco &amp; human3.6m coco需要联网用json下文件，实验室电脑没有那么多网关流量，human3.6m没数据集train joint的时候dataloader的num有点问题 改成8035试试（worked）donetrain anchor doneeval test doing跑实验的同时看一下红黑树/B树/B+树 2019.11.19eval完成看hmd论文 Detailed Human Shape Estimation from a Single Image by Hierarchical Mesh Deformation 2019.11.20tex2shape的模型是有uv的 octopus/hmd都没有uv 所以没法贴图加贴图那个基于octopus，需要绕着人转圈拍照片，然后做分割eval_wild on self trained model（10hrs）明天看看遮挡情况下hmd的重建效果 2019.11.21shell脚本里使用conda命令需要在conda activate前加上source ~/anaconda3/etc/profile.d/conda.sh遮挡情况下的hmd效果实验eval_wild on self trained model（10hrs）（昨天优点问题 再来一遍） 2019.11.22确定目标 基于hmr和hmd做遮挡部分的重建看hmd论文，研究hmd怎么加纹理细节的 2019.11.23/24休 2019.11.25shadingnet: hmr 3d mesh —1-&gt; depth map —2-&gt; detailed depth map —3-&gt; detailed 3d meshhmd里是先shadingnet根据rgb image预测一个depthmap 然后加上mesh(openmesh + hmr smpl) 投影出的depthmapUnet 输入rbg groundtruth depthmap 结果泛化能力差 所以再来个shadingnet loss是前边unet的depthmap loss 还有depth map重建成rbg 跟input的loss需要解决的问题就是设计网络做第二步（doing sfsnet/3dmm/..）先可视化一下depthmap（done） joint和anchor都独立与shading的，在有rgb出了joint/anchor的前提下 rgb做修复 然后经过shading net(pretrained) 加到project depth map上看结果 不处理的rgb 经过shading net(pretrained)生成depth map 然后在dm上做修复 最后加到project depth map上生成最终dm 建立端到端网络直接从未处理的rgb—&gt;修复完成的depth map，最后加上project depth map hmd的数据集刨除h36m应该有18000+ train set，现在只有9000+ 重新用脚本处理一遍 numpy 高级索引 ndarray[x,y]//ndarray[a==b] 2019.11.26机器在处理数据（就是做hmd 里的 wild set）（coco做了7000+然后断开socket链接了，回头继续转）问题转化为：有遮挡的rgb图生成完整的深度图的问题DDRNet做的深度图重建。试试Deeper Depth Prediction with Fully Convolutional Residual Networks (FCRN)还有ddrnet 王琛的方法，需要提供人体/遮挡的数据集（考虑下怎么做这个数据集），网络是现成的三维人体重建转化到深度图的inpainting这样可以吗？？ 更新ubuntu grub的引导会没 需要到win7下重设 2019.11.27coco数据集的hmd预处理还是有socket error，今晚挂上代理再试一次问题：有遮挡的情况下恢复深度图的detail，还是考虑深度图质量差不多的情况下，深度图生成三维模型的精度见今日周报 基本确定12月的工作内容 2019.11.28固定像素位置加遮罩很容易（已完成），考虑往人体固定位置上加？人体的数据集就18000+ 顶多了 看别人做inpainting的得有4/5w监督数据怎么来？1. 通过hmd shading net出深度图；2. 找别的深度估计方法 2019.11.29先用shadingnet的结果做gt吧，开始处理数据集 2019.11.30/1effective c++休 2019.12.2生成depth ground truth 流程如下img—&gt;hmr result（predict_hmr_dm 批处理hmd_2 18403张train img）—&gt;depth result（predict_hmd_dm 生成depth 到hmd_masked/train）做depthmap的gt要150hrs。。？ 感觉没人做带遮挡的rgb到depth的映射(也就是inpainting和depth estimation的混合)现有的depth estimation方法 pretrained的model对人体的效果极差 根本比不了hmd的shadingnet结果 见周报图incomplete RGB —&gt; complete depth 做不动incomplete RGB —&gt; incomplete depth —&gt; complete depth想出incomplete depth还得150hrs最后可能只能在深度图上做inpainting 2019.12.3写周报leetcode 2019.12.4人体的rgb inpainting目前都没有人做的好，主要是会拿背景的信息填充到人体遮挡区域考虑使用sil，把人体抠出来，看看能不能训练一个针对人体的inpainting网络，再出深度图看效果注：rgb重建的效果也不会特别好，举个例子，拿衣服去补人脸的位置，肯定效果不对。但是，转成深度图再到三维模型上，效果不一定会特别差，待试想想怎么给inpainting的输入加入人体轮廓信息这个约束rbg修复好了 —&gt; 深度图效果好 —&gt; 模型效果好 王琛表示深度图做修复能做，接下来准备等深度图数据集处理完成，进inpainting网络，训练修复深度图的网络模型。 2019.12.5玩kbengine，部署linux游戏服务器，打包安卓客户端，双端联机测试深度图要等到周日晚上，给王琛做 2019.12.6/7/8休 2019.12.9train depth inpainting modelshift-net_pytorch 深度图做出npy和png了，shift-net的图片都是256256，我这是448448，需要调整下网络 2019.12.10开始训练针对深度图的shift-net，30hrs(30 epoch) 明天放到hmd里看效果这次训练用的center mask(25%左右的遮挡率) 有些把人遮住太多了 下次试试随机的或者范围小一点的玩kbengine 2019.12.11贵州电网的一个UI材质工具train好的modeltest需要测试集的depth map，2000多张得搞一下hmd的shading-net没有train code，也就是说rgb到depth这段没有源码，shift-net做inpainting已经很好了，如果有shading-net的train code，合起来或许能做 incomplete rgb —&gt; complete depthNYU的数据集看了精度肯定不够 2019.12.12出inpainting好的深度图重建出的三维模型，这个算是完成目标了，但是是分两阶段完成（不完整rgb—&gt;不完整depth—&gt;完整depth）接下来看shadingnet怎么train的，得能跑通 3d mesh —&gt; 图像空间 初步深度信息 —》 shadingnet 增强深度信息—》mesh到depth的原理 还有 ddrnet的那个loss 开题报告 2019.12.13/14/15开题报告 2019.12.16hmd: 训练策略（train scheme）是仿照的sfsnet 先用了一个Unet，train时候输入是RGB + hmr投影出来的depth，监督数据是Kinect扫的depth（这个Unet train的时候只用到了少量数据集，然后用训练好的模型生成大量的depth，此时depth效果不好） 然后是shadingnet，train的输入是hmr投影出来的depth和原始RGB，一个loss是用unet的输出监督，一个loss是photometric reconstruction loss（问题是这个reconstruct 重建了什么 就能知道重建的这个玩意儿跟什么做比较成为损失函数） 重点看ddrnet怎么优化depth的，原理是什么 阶段性总结 明确人体细节是由深度图产生的，三维重建问题转化到深度图修复问题上 做出了深度图数据集 18000+3000 shift-net针对深度图训练了一个模型，可以用于深度图恢复 tex2shape/octupus/hmr/hmd 基本可以跑对比实验了 接下来的工作是做shadingnet的train对比joint和anchor的train codeshadingnet的dataloader返回的是(src_img, depth_diff, mask)为什么要返回diff??? gt和smooth depth的差 2019.12.17自己做了shadingnet的train code，网络结构Unet（hmd给的），损失函数就用MSE，输入完整rgb还有mask，监督数据depth_gt，learning rate降到0.00001搞搞看能不能rgb到depth 30分钟迭代900多次就训练完了 结束条件是什么不知道 测试中测试结果不好 自己train出来的结果有明显颗粒感 深度数值范围0-1之间，pretrain的+-25之间 明天看 2019.12.18改开题报告 整点ddrnet的公式进去shading net 用MSE train 完全不收敛啊 shadingnet dataloader ： mask就是coarse depth？！ 剪影代替的coarse depth？？ wtf 2019.12.19两个问题：背景是黄的 是因为背景到人体的过度不自然，pre的是背景是0 人体上是0左右 正负50都有细节是有的 但是我的像素不连续 有细节但是数值跟pre对应不上 颜色深浅换个loss看看结果变不变 完全不变 调参也不变。。 2019.12.20不清楚网格的问题是不是通过调参就能解决的，或者换loss，还是不知道depth_diff干嘛用的只能换loss了 自定义loss试试 2019.12.21原因是输入图像和gt图像没有匹配，低级错误下一步进一步调参降低loss 2019.12.22 eval pretrained model和我自己的model shift-net改下输出看结果 G &amp; D：G把输出的channel改成1，loss得跟depth比；让D区分gtdepth和preddepth backward_G and backward_D real_A real_B为什么有两个real？ dataloader在aligned_dataset.py里 real_A == real_B//real_A—&gt;fake_B fake_B—netD—&gt;pred_fake//real_B—netD—&gt;pred_real set_gt_latent干什么用的 下周开始做改进改进版shift-net的实验月底开始写论文 2019.12.23改shift-net： Gnet输入RGB，自己加遮罩，生成fake_rgb，用原始RGB监督；Dnet输入RGB和fake_rgb，输出两个判断结果的计算loss G输入3通道输出1通道，D出入1通道输出二分类，netD和vgg16featureextractor（util）问题： 方框可能太大；把RGB的人挖出来比较好背景干扰太多还是应该输出numpy数组，监督数据如果用png出来的是三通道的rgb图，得改可视化的代码，用plt通过numpy数组生成训练过程中图像 2019.12.24方框缩小，单通道输出，trainning，ETA 25号中午 2019.12.25test 2019.12.26spectral_norm gan用的东西现在要解决的问题：重建深度图不光滑，有明显的网格，重复结构，不知道为什么G就是个encoder decoder 为什么会有网格试试用sil不用深度图的a[b==0] = 0 不行 sil只有8035个把unet最后一层的tanh激活函数删了结果看起来好点了 迭代30次看看效果7次 看起来还原出来的部分并没有什么细节 2019.12.27shift-net几个损失函数得调整，D一直为0了 content过于大D的输入已经是抠出来的了，opt.overlap是什么 2019.12.28/29休回放系统、撤销操作 2019.12.30开会，确定一月时间安排开始论文初稿，学习latex，写公式最麻烦，网络结构图，柱状图，折线图 怎么能让遮挡区域的数值乘个系数？？ 2019.12.31abstract完成 2019.1.1开题ppt完成 2019.1.2latex画Unet 2019.1.3朱青审开题报告，ppt修改 2019.1.4/5休 2019.1.6introductionrelated workmethod 2019.1.7resultconclusion 论文结构 abstract introduction三维人体重建：分两种基于参数化模型的和非的/还是特征匹配的和模板适应的目前方法的局限性，我的方法综述，贡献点总结 related work 参数化的 scape 人工标记关键点* 卷积标记关键点 smpl 非参数化的 methods SMPL，anchor/joint deformation，vertex deformation（our dataset, our net, loss） Loss：G_GAN,G_L1,D,style(MSE vgg),content results &amp; comparison介绍evaluation用的数据集，评价方法，评价/对比结果hmr/hmd/tex2shape/octopus原图inpainting/深度图inpainting/遮挡rgb生成完整的深度图测试150加遮罩—&gt;(只能不带遮罩的进？？为什么)进shiftnet出深度图—&gt;hmd_s使用深度图信息而非shadingnet信息—&gt;结果 conclusion 2020.1.13dhdnet在跑recon测试集的时候方框处理的非常不好现在猜测是因为训练的用深度图gt当作的sil，在A[B==0]=0这步的时候很可能把纹理信息填回方框区域内了。。现在但是理论上shiftnet自己还会加遮罩目前recon测试集上只能用不加遮挡的img做输入效果还可以矛盾点在于 shiftnet是在线加的遮罩啊 为什么输入图像加不加遮罩还会造成影响？？？？ 2020.1.14recon只看joint 还是得看syn输入图像家的遮罩试着比 shiftnet动态加的小一点 84 84 140 140—&gt;87 87 137 137 2020.1.15leetcodeblog 加入vuejs静态页面Mirror 多人游戏demo / kbe C++ 服务端 2020.3.8Attention机制zhihu论文搜索：Self-Attention Generative Adversarial Networks (SAGAN)codeA PyTorch reimplementation for paper Generative Image Inpainting with Contextual Attention paper code 2020.3.9Learning 3D Human Shape and Pose from Dense Body Parts 2020.5.30Losses：下降较明显的有G_L1，content；G_GAN略上升，D下降不明显loss计算公式：$lossD = (lossDfake + lossDreal) 0.5$ (vanilla)fake/real 是BCELoss二分类交叉熵损失函数$loss G = loss G L1 + loss G L1 m + loss G GAN + style loss + content loss + tv loss$loss G L1 是 $L1 loss opt.lambda_A$L1_m 是一个spatical discounting l1 loss（别的论文里提出来的）loss G GAN 是BCELossstyle和content都是MSELosstv是自定义一个损失函数 目前已有的： rgb特征提取—&gt;分三阶段形变smpl模型 depth map到人体表面细节，形变方法（hmd提供） 不完整rgb向完整depth map的转换网络模型 不完整rgb到完整人体模型的端到端系统 合成人体深度信息数据集 后续研究方向（大论文第二章，改进算法）： center mask的大小对重建质量的影响（最大多大就handle不住了） 不规则mask（shiftnet做了，这个好实现） attention机制对于结果的提升有多少（没概念） 目前来看多loss共同作用，有些loss并没有明显收敛（是否等于没作用、贡献）—灼烧实验 depth信息到三维点坐标的形变（deform）关系还能改进（比如深度或者说形变的scale，还有方向，目前是垂直于视平面，可以是垂直于粗模型表面？） structure from motion方向研究（全新方向，建筑行业在用） 加壳，做成用户友好的应用程序 2020.6.2ICIP论文中的四个示例在recon_set中，编号为1，3，95，116 2020.7.8专利： 技术背景 应用与不足 现有技术分析 综上 发明内容 2020.7.13ICIP pptmesh deformation with Laplacian coordinates：一种智能化的方法，能够让用户只需设置个别离散点的新位置来表达他所想要的形变，就能自动根据所需保持的形体信息来计算出剩余离散点应有的位置 conda env pytorch：Python 3.7 + pytorch 1.3 detectron2/densepose/shift-net_pytorch tf2: python2 + tf1.14 hmr, tex2shape, Semantic Human Texture Stitching tf: python3 + tf1.14 + pytorch human_dynamics, neuralgym/generative_inpainting dirt：py2.7 + tf1.13 + dirt octopus, garment hmd(可以跟tf2合并)：py2.7 + pytorch1.0.1 hmd 实验结果 三通道rgb原图到三通道depth.convert(‘RGB’)效果不好，中心预测的不好，四周也没有跟gt完全一致。 缩小遮挡范围1/2改为1/4的宽高 输入三通道rgb 输出单通道npy数组 改下可视化的代码使正常显示 human_depth: 输入三通道depth_png，输出三通道修复完成后的depth_png，这是下边实验的目标效果 rgb2depth_npy_2: 初试版本，1/4边长遮挡，王瑾周报 rgb2depth_npy_3: G去tanh()版本，网格纹理问题解决 rgb2depth_npy_4: 修改D输入图像范围，仅输入被遮挡区域 数学理论相关压缩感知中的欠定方程（undetermined equations）： 目标（朱邮件内容）研究方向：非理想条件下的单目RGB相机三维人体重建 领域现状：目前基于相机阵列以及单目RGBD相机的三维人体重建技术已经较为成熟，仅依靠单目RGB相机的三维人体重建工作具有广阔的发展前景并且具有挑战性。以MPI、UCB、浙大为首的一些实验室已经在该研究方向上已经取得了一些成果，但是输入图像质量都比较理想，非理想条件下的重建效果并不明确。 我的工作：目前确定做非理想条件下的单目相机三维人体重建，提高重建精度包括模型细节、姿态、纹理贴图。非理想条件具体来说有以下情况： 图像中人物受到遮挡（重点） 图像中人物因高速移动产生的运动模糊 图像中人物因环境光照产生的视觉偏差 工作计划：看现有方法在上述非理想条件下的重建效果（文章中没有提到的需要亲自跑实验验证）；设计改善方法，反复实验验证，得到实验数据；论文撰写。 思路 单图多人（人群）三维重建可能需要解决的问题：遮挡（周晓巍的PVNet解决了遮挡的问题，空间维度上的估计）分割大小/相对位置… 跟游戏开发能关联的地方：用引擎看效果实用性 从视频序列中选出作用显著的帧，设计量化评价方法 从不同表达，面点云体素区别入手 增加脸部细节（手部、脚步，观察几个论文的演示视频好像都没有动作细节，骨骼的问题应该是）呢？？结合3dmm（已经有结合的了19.10.10更新） 考虑多模态，加入语义信息辅助重建（还得看nlp的东西，把特征映射到一个空间不知道能不能做） 快速移动/运动模糊的视频/照片做重建（回到图像处理的问题上，不确定目前已有的方法在视频中任务快速移动情况下的重建效果） UCB预测人体动作（时间维度上的估计） 能怎么改进 MPI做的实时 UCB把SMPL用到了动物（斑马）模型重建；不是smpl是smal 光照条件对重建质量的影响 UCB做了动物的模型重建，根据视频预测人体接下来的动作；MPI实时Video to Mesh shape：更有细节/遮挡、截断(空间维度预测)/pose：根据视频、单图预测pose（时间维度预测）/实时更新posetexture：单视角贴图/多视角贴图 疑问6D pose estimation 和 smpl/smal重建出的pose有何异同？？是一个东西吗In contrast to coordinate orheatmap based representations, learning such a representa-tion enforces the network to focus on local features of ob-jects and spatial relations between object parts. As a result,the location of an invisible part can be inferred from the vis-ible parts. In addition, this vector-field representation is ableto represent object keypoints that are even outside the inputimage. All these advantages make it an ideal representationfor occluded or truncated objects. 时间安排 VCIP 5月ACM Multimedia 3月ICIP 1月31日 1月15日初稿和evaluation 1月开始写论文12月实验，开题开始编写代码，训练模型，评估实验数据11月实验设计优化思路，实验步骤，预期的实验结果 11.18-11.29 两周现有方法在非理想情况下的表现 10.21-11.15 四周10月底规划好实验步骤，预计出的结果10月18号确定要做的目标 信息总结fusionmulity domin多元融合 显著性摘要帧对重建质量的贡献 王少帆 北工大计算机学院dblp todo list数据清洗 三个数据集UP-3D，HumanEva-I，Human3.6M清洗的目的？目标？要做成什么样？","raw":"---\ntitle: 关于三维重建的文献综述\ndate: 2019-01-04 07:58:17\ntags: \n    - 3D model reconstruction\n    - 文献综述\ncategories: 论文综述\n---\n\n# 目录\n\n[arXiv检索](https://arxiv.org/)\n\n1. 1812.10558 通过视频素材实现从2d到3d的面部重建来完成测谎\n2. 1812.01742 单一视角的三维重建，使用对抗训练（非人\n3. 1812.05583 基于学习的ICP（迭代最近点算法）重构场景（非人\n4. 1812.07603 通过视频素材的面部模型学习\n5. 1812.05806 自我监督的引导方法，单图片的三维人脸重建\n6. 1812.02822 学习生成模型的隐藏区域（非人\n7. 1901.00049 基于轮廓的衣着人物（全身\n\n**A类**\n\n* 通过直接体积cnn回归从单图重建大范围三维人脸（源码lua+py\n* 使用图到图转换的无限制面部重建（源码lua\n\n**老师推荐**\n\n* 使用affinity field的实时多人二维姿态估计\n\n# 综述\n\n## 通用\n\n**关于三维重建**  \n单个图像进行三维重建的数据驱动方法：一是明确使用三维结构，二是使用其他信息推断三维结构  \n2DImage-->encoder-->latent representation-->decoder-->3DObject  \n不同方法区别在于对三维世界采取的**限制**：多视图一致性学习三维表示、利用关键点和轮廓注释、利用2.5D草图（法线，深度和轮廓）改善预测  \n\nencoder-decoder的[含义](https://blog.csdn.net/chinabing/article/details/78763454)\n\n**关于shape priors**\n许多方法选择更好的捕捉多样的真实形状  \n**non-deep方法**关注低维参数模型，使用CNN来学习2D渲染图像和3D形状的**共同嵌入空间**  \n其他方法依赖**生成模型**去学习shape priors\n\n## 博客链接\n\n[3D人脸重建学习笔记CSDN](https://blog.csdn.net/yyyllla/article/details/84573393)  \n[3D重建的学习笔记简书](https://www.jianshu.com/p/f33b3d440f7d)\n\n## Learning Single-View 3D Reconstruction with Adversarial Training 1812.01742  \n\n传统方法用多个角度的多张照片实现三维建模  \n问题两个：一是需要大量的观察点；二是物体表面是*Lambertian*（非反射）albedos是非均匀的  \n另一种三维重建的方式是利用物体外观和形状的知识从单视图二维图像生成（假设shape priors足够丰富）  \nCAD库（computer-aided design）：<u>shapenet，pascal3d+，objectnet3d，pix3d</u>  \n\n这些方法都从渲染的图像中回归三维形状：将二位图像转化成潜在表示的**编码器** 以及 重建三维表示的**解码器**  \n为了学习shape priors深度学习算法需要大量的三维对象注释，自然图像中获取三维注释很有挑战，因此使用合成图像（三维模型渲染出的图像）  \nCNN的<u>domain shift</u>问题，导致基于cnn的三维重建性能恶化  \n\n这篇文章的方法：提高重建模型性能，为了实现获取三维物体标签，他们shape priors训练出的网络有个**重建损失值**，给这个值引入了两个限制  \n一是受domain shift文献启示，强制让编码的二维特征不变，对应于他们所来自的domain。这样合成图像训练出的编码器在真实图像上表现更好  \n二是将编码的二维特征限制在现实物体的多种形状之中，通过对抗训练定义这两个损失值  \n总结：一个**模型**和**损失函数**，利用shape priors提高自然图像三维重建性能（两种方式使用对抗训练）  \nreconstruction adversarial network(RAN)  \n**只使用rgb图像信息**，和易于获取的自然图像。独立于编码器和解码器，并且可以使用到其中  \n借鉴了domain confusion（作用是classification），为了让从合成图像里训练出来的模型在真实图像这边有更好的表现  \n\n具体方法：todo\n\n## 通过直接体积cnn回归从单图重建大范围三维人脸\n\n目前三维人脸重建的方法多假定有多张面部图片可以使用，这使得重建面临方法上的挑战：在夸张的表情、不均匀光照上建立稠密对应关系  \n这些方法需要复杂低效的管道构建模型，拟合模型。本文建议通过在由2D图像和3D面部模型或扫描组成的适当数据集上训练卷积神经网络\n（CNN）来解决这些限制\n\n## Extreme 3D Face Reconstruction: Seeing Through Occlusions 极端3D面部重建：遮挡透视（讲）\n\nbumpingmapping概念的推动下，该文提出了一种分层方法。将全局形状与其中细节进行解耦。估计粗糙的3d面部形状为基础，然后将此基础与凹凸贴图表示的细节分开。\n与本文相关的工作：\n    reconstruction by example 这类方法用三维脸部形状去调整根据输入图片估计出的模型，降低了观看条件却损失了真实度与准确性  \n    face shape from facial landmarks 这类方法稳定但是模型都差不多，没有细节，而且不清楚遮挡landmark的情况下表现会如何  \n    SfS *Shape-From-shading* 根据光反射生成细节丰富的模型，但是受环境影响严重，需要满足其对环境的特殊要求。任何遮挡物都会生成到模型中  \n    statistical representations 最著名的方法是3DMM，这篇文改进了这个方法直接根据图片强度信息用cnn回归3DMM的参数和面部细节  \n    deep face shape estimation 深度网络一是直接用深度图重建，二是estimate 3D shapes with anemphasis on unconstrained photo 观察条件高度不变但是细节模糊  \n\n**准备工作**  \n矛盾：整体形状的高度正则化vs细节的弱正则化。解决方法：bump map representations which separate global shape from local details\n    理解的正则化：使模型更有普适性，低正则化是让模型有更多细节、更有特点，反之是让模型更接近普适的规则（每个模型都有一只鼻子一张嘴两只眼睛）\n给一张图片建立以下几个部分：基础形状——S，面部表情——E，6维度的自由视点——V。接下来是bump map捕捉中级特征（皱纹等非参数的），最后完成因遮挡丢失的细节。  \n**添加细节**\n基础形状使用3DMM，3DMM用了resnet的101层网络架构。表情部分由3DDFA提供，更新的有expnet。确定视点用了deep，facepostnet。  \n中等程度细节：image to bump map，修复遮挡细节，基于软对称的模型完善。  \n[LFW验证](http://vis-www.cs.umass.edu/lfw/)\n\nPPT用：\n目的：现有单图三维重建局限性很高，必须在正前方、距离近、无阻挡的视点，该文设计了一种用于在极端条件下提供细节丰富的面部三维重建模型的系统。极端条件包括，头部旋转以及遮挡\n方法：简单讲步骤，关键的创新点，值得学习的点后边会细说。\n总的来说：先创建面部整体的基础形状，与局部细节分开，在基础形状之上建立中等程度的面部特征。这样做可以保证极端条件下整体面部形状的稳定性。其他较新的方法往往用局部细节构建整体形状。\n 构建基础形状s，构建面部表情e，构建视点v：*凹凸图可以分离整体形状和局部细节*\n这仨东西分别是干什么用的：*基础形状使用3DMM，3DMM用了resnet的101层网络架构。表情部分由3DDFA提供，更新的有expnet。确定视点用了deep，facepostnet。*\nimage to bump map转换\n凹凸图训练集：用深度编码-解码框架生成凹凸图\n学习建立凹凸图：定义了自己的网络损失函数，可以在不牺牲高频细节的情况下抑制噪声\n还原遮挡细节\n给予范例的空洞填充方法\n搜索参考集\n混合细节\n更复杂的修补\n基于软对称的模型补全  \n\n贡献：解决**对foundation的高度正则化** VS **对detail的低正则化** 两者的矛盾  \n\n注：  \n    bump map使用灰度值来提供高度信息，normal map使用xyz轴所对应的rgb信息\n    [卷积与反卷积](https://github.com/vdumoulin/conv_arithmetic)\n\n跑demo流程：\n    NVIDIA-docker启动container，如果跑代码没有driver重新run一个，用readme里的run命令。\n    之后会出现860m只支持cuda5.0的报错，需要[从源码编译pytorch](https://github.com/pytorch/pytorch#from-source)。首先docker里装anaconda\n        wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2018.12-Linux-x86_64.sh\n        应该不用在docker里装cuda和cudnn，直接安装pytorch的依赖然后安装pytorch应该就可以  \n        在1080上不会出现上边的报错，完全按照README走就行。\n\n[PPT](extreme_3d_face.pptx)\n\n<iframe src='https://view.officeapps.live.com/op/view.aspx?src=https://taye310.github.io/2019/01/04/%E5%85%B3%E4%BA%8E%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%9A%84%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0/extreme_3d_face.pptx' width=800 height=600 frameborder='1'></iframe>\n\n## Learning to Estimate 3D Human Pose and Shape from a Single Color Image(讲) DOI:10.1109/CVPR.2018.00055\n\nSCAPE:  shape  completion  and  animationof people\nSMPL: A skinned multi-person linear model  \nSMPL是一种参数化人体模型，与非参数化模型的区别在于，参数化的可以用函数映射的方式表达出来，或者说是可以解析的？非参数化则认为是通过实验记录到的模型，不存在解析表达式。  \n\n\nStacked Hourglass Networks\n[资料一](https://blog.csdn.net/wangzi371312/article/details/81174452)\n[资料二](https://blog.csdn.net/shenxiaolu1984/article/details/51428392)\n\n[feature map](https://blog.csdn.net/dengheCSDN/article/details/77848246)\nchannel:\n卷积核个数、特征图个数、通道个数关系\n\n[PPT](Learning to Estimate 3D Human Pose and Shape from a Single Color Image.pptx)\n\n<iframe src='https://view.officeapps.live.com/op/view.aspx?src=https://taye310.github.io/2019/01/04/%E5%85%B3%E4%BA%8E%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%9A%84%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0/Learning to Estimate 3D Human Pose and Shape from a Single Color Image.pptx' width=800 height=600 frameborder='1'></iframe>\n\n## O-CNN: Octree-based Convolutional Neural Networks for 3D Shape Analysis\n\n还有adaptive o-cnn  \nThe main technical challenge of the O-CNN is to parallelize the O-CNN computations defined on the sparse octants so that they can be efficiently executed on the GPU  \nWe train this O-CNN model with 3D shape datasets and refine the O-CNN models with different back-ends for three shape analysis tasks, including object classification, shape retrieval, and shape segmentation.\n\n## Pixel2Mesh（讲）\n\n### code\n\n编译tensorflow math_functions.hpp找不到。需要软链接这个玩意  \nln -s /usr/local/cuda/include/crt/math_functions.hpp /usr/local/cuda/include/math_functions.hpp  \n\n关于eigen和cuda[资料](https://blog.csdn.net/O1_1O/article/details/80066236)  \nmakefile怎么写。  \nhdf5 HDF（Hierarchical Data Format）是一种设计用于存储和组织大量数据的文件格式\n\n__CUDACC_VER__ is no longer supported.的报错看来要更新[eigen3](https://blog.csdn.net/luojie140/article/details/80159227)才能解决\ngithub上新版eigen考到anaconda的eigen和support里就可以成功编译cuda了\n\n图卷积神经网络[资料](http://tkipf.github.io/graph-convolutional-networks/)\n图卷积神经网络[材料](https://cloud.tencent.com/developer/news/330322)\n**所有的卷积都是在探讨如何对局部数据按照某一个操作聚合，不同的操作方式就对应于不同的卷积。**学习卷积核的过程其实是学习局部聚合参数的过程\n\n[PPT](pixel2mesh.pptx)\n<iframe src='https://view.officeapps.live.com/op/view.aspx?src=https://taye310.github.io/2019/01/04/%E5%85%B3%E4%BA%8E%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%9A%84%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0/pixel2mesh.pptx' width=800 height=600 frameborder='1'></iframe>\n\n## SMPL: A Skinned Multi-Person Linear Model(多篇基础，15年)\n\n## Video Based Reconstruction of 3D People Models(讲，没用网络) DOI:10.1109/CVPR.2018.00875 (video2mesh)\n\n第五页第一张图解决了人体非刚性的问题  \n但是问题在于人必须转身后摆出相同的姿势 不允许姿势变化  \n第二张图 可以随意动 不同时刻的深度图非张性的注册并融合到一个template上  \n存在 phantom surface的问题 运动的快会四肢胳膊 两个头  \n第三个 加了一个static的人体模型作为约束 运动速度可以更快  \n\n第一个使用rgb相机 并且支持用户运动的重建方法  \n主要思想 和visual hull相似 不同角度拍摄剪影进行重建  \nvisual hull的基本原理 几个角度拍摄 分割出前景得到silhouette  \n然后从相机坐标到silhouette的每一个点可以做一条射线 形成的曲面成为silhouette cone  \n用这些cone作为约束就可以重建出三维模型 可以类比为雕刻的过程  \n去掉cone之外的部分 最终剩下的部分就是人体的形状  \n\n标准的vh的问题是只能用于静态的物体 这篇的主要是讲怎么把vh用到动态的物体  \n第八页 每帧姿势都不一样 要做的就是去除由于运动对cone造成的变化 称为unpose的过程  \n用unpose的cone做三维重建  \n\n使用的人体的三维表达：smpl 参数化模型 T是template的mean shape，Bs是体型变化造成的模型变化  \nBp是pose的变化带来的变化  \n问题在于没有办法model衣服头发面部特征 基础上加了D offset用于表达smpl表达不了的信息  \n  \n四个步骤  \n1 前景分割 获取silhouette cone， tracking获取人体模型的姿态  \n2 利用pose信息做unpose操作 转到Tpose姿态下  \n3 人体重建 包含衣服 头发 人脸的人体模型  \n4 多视角图像生成人体贴图  \n\n1 基于cnn的方法 2d drawn detection 图像分割的方法 前景分割生成silhouette  \n优化第12页的能量函数 进行pose tracking //简单来说就是求最优的pose和shape的参数 和模型匹配到检测到的  \n2d drawn detection和silhouette上//  \n2 第一步得到的cone进行unpose 每一条射线进行unpose转到canonical pose下  \n//两个数学表达式 射线的转换//  \n任何一点vi 和 任何一条射线ri\n3 利用unpose后的cone做三维重建 称为consensus shape，相比较SMPL/视频表现出的是可以对衣服进行重建  \n过程可以通过优化一个能量公式实现  \nEdata：模型上的点到unpose ray的距离  \n三个正则项：lap保证局部光滑，body保证重建出的与smpl差距不大，symm保证左右对称  \n4 有了几何信息后 生成appearance信息 生成texture map 第一步有每一帧的pose，精确的将模型覆盖到图像上  \n通过//重投影获得贴图//  \n\n用sfs（之前的文章有提到）可以提供更多细节，本文方法可以提高的地方\n对**能量函数**的理解：构建能量函数就是我们用方程的最小值来描述我们想要达到的实际效果。[资料](https://blog.csdn.net/a6333230/article/details/80070586)\n\n第一步最费时间 一帧一分钟 model和silhouette的匹配费时间  \n穿裙子解决不了 改变不了smplmodel的拓扑结构 拉不过去  \n基于cnn的分割已经接近于完美了 用的别人的方法 不是重点  \n给纹理图上色：consensus shape 结合第一步的pose 精确匹配到每一帧的图像上 back projection  \n\n{% pdf videobasedreconstructionof3dpeoplemodelsGAMES201850徐维鹏.pdf %}\n[ppt](videobasedreconstructionof3dpeoplemodelsGAMES201850徐维鹏.pdf)\n\n## Learning to Reconstruct People in Clothing from a Single RGB Camera（2019.4video2mesh延伸论文，同一实验室）octopus\n\n安装dirt遇到的问题：https://github.com/pmh47/dirt/issues/23\n已经尝试过cuda10.1/10.0/9.2 cudnn都是对应版本，tensorflow单独测试成功\n更改gcc/g++版本：https://blog.csdn.net/u012925946/article/details/84584830\n\n最终安装dirt解决方法是：  \nubuntu 18.04，cuda 8.0，cudnn 6.0，tf 1.4.0，driver 396.54  \n注意conda install 的 cudatoolkit和cudnn不能取代本机安装的cuda和cudnn，也就是说本机要安cuda，cudnn，conda装tf时要装cudatoolkit，cudnn  \n\n先装tensorflow再装-gpu 才能启用gpu 前者版本不能比后者高，libcudnn.so.x报错需要在conda里安装tf，tf-gpu。注意版本匹配\n\n跑Octopus的实验时需要  \nscipy>=1.0.0  \nnumpy>=1.16  \nKeras>=2.2.0  \ntensorflow_gpu>=1.11.0  \ndirt  \n否则会报：  \n``` bash\n(video2mesh) ty@ty-GE60-2PF:~/repos/octopus$ bash run_batch_demo.sh \nUsing TensorFlow backend.\n2019-05-29 15:18:24.784883: I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA\n2019-05-29 15:18:24.835566: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:892] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n2019-05-29 15:18:24.835835: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1030] Found device 0 with properties: \nname: GeForce GTX 860M major: 5 minor: 0 memoryClockRate(GHz): 1.0195\npciBusID: 0000:01:00.0\ntotalMemory: 1.96GiB freeMemory: 1.08GiB\n2019-05-29 15:18:24.835855: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -> (device: 0, name: GeForce GTX 860M, pci bus id: 0000:01:00.0, compute capability: 5.0)\nProcessing sample...\n> Optimizing for pose...\n  0%|          | 0/10 [00:00<?, ?it/s]\nTraceback (most recent call last):\n  File \"infer_batch.py\", line 87, in <module>\n    main(args.weights, args.num, args.batch_file, args.opt_steps_pose, args.opt_steps_shape)\n  File \"infer_batch.py\", line 46, in main\n    model.opt_pose(segmentations, joints_2d, opt_steps=opt_pose_steps)\n  File \"/home/ty/repos/octopus/model/octopus.py\", line 290, in opt_pose\n    callbacks=[LambdaCallback(on_batch_end=lambda e, l: pbar.update(1))]\n  File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/engine/training.py\", line 1010, in fit\n    self._make_train_function()\n  File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/engine/training.py\", line 509, in _make_train_function\n    loss=self.total_loss)\n  File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/legacy/interfaces.py\", line 91, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/optimizers.py\", line 475, in get_updates\n    grads = self.get_gradients(loss, params)\n  File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/optimizers.py\", line 89, in get_gradients\n    grads = K.gradients(loss, params)\n  File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/backend/tensorflow_backend.py\", line 2757, in gradients\n    return tf.gradients(loss, variables, colocate_gradients_with_ops=True)\n  File \"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/tensorflow/python/ops/gradients_impl.py\", line 555, in gradients\n    (op.name, op.type))\nLookupError: No gradient defined for operation 'smpl_body25face_layer_1_7/smpl_main/Svd' (op type: Svd)\n```\n\n显卡驱动还崩了 用ubuntu自带的怎么切驱动nvidia-smi都会报一行错  \nNVIDIA-SMI has failed because it couldn't communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed \nand running.  \n然后切不懂了卡在390 有这个问题https://askubuntu.com/questions/1035409/installing-nvidia-drivers-on-18-04  \n\n\n2019.6.4 https://github.com/pmh47/dirt/issues/6 dirt inside cmakecache.txt add -DNDEBUG to CMAKE_CUDA_FLAGS:STRING\n\nhttps://github.com/pmh47/dirt/issues/23  \ntensorflow.python.framework.errors_impl.NotFoundError: /home/ty/repos/dirt/dirt/librasterise.so: undefined symbol: _ZN10tensorflow12OpDefBuilder4AttrESs\n\nshould not use conda install tensorflow & tensorflow-gpu, use pip install instead\n\nnvidia driver keeps the newest one.\n\n``` bash\n(dirt) zhangtianyi@likun-ThinkStation:~/github/dirt$ python tests/square_test.py \nTraceback (most recent call last):\n  File \"tests/square_test.py\", line 4, in <module>\n    import dirt\n  File \"/home/zhangtianyi/github/dirt/dirt/__init__.py\", line 2, in <module>\n    from .rasterise_ops import rasterise, rasterise_batch, rasterise_deferred, rasterise_batch_deferred\n  File \"/home/zhangtianyi/github/dirt/dirt/rasterise_ops.py\", line 6, in <module>\n    _rasterise_module = tf.load_op_library(_lib_path + '/librasterise.so')\n  File \"/home/zhangtianyi/anaconda3/envs/dirt/lib/python2.7/site-packages/tensorflow/python/framework/load_library.py\", line 61, in load_op_library\n    lib_handle = py_tf.TF_LoadLibrary(library_filename)\ntensorflow.python.framework.errors_impl.NotFoundError: /home/zhangtianyi/github/dirt/dirt/librasterise.so: undefined symbol: _ZN10tensorflow12OpDefBuilder4AttrESs\n\n```\n成功安装后test时出现上边的问题 -d_glibcxx_use_cxx11_abi=0改成1 gcc/g++版本从4.9换到5重装dirt就好了\n\n总结：py2.7 tf1.13.2 cuda 显卡驱动装新的\n1. setup.py里的dependence去掉用conda装\n2. cmakelists.txt cmake_flag 加-d_glibcxx_use_cxx11_abi=1\n3. change CMakeLists.txt line5 into  \n`find_package(OpenGL REQUIRED COMPONENTS OpenGL EGL)`  \ncomment line9  \nline53 into  \n`target_link_libraries(rasterise OpenGL::OpenGL OpenGL::EGL ${Tensorflow_LINK_FLAGS})`  \nAs a hack, you can try directly linking the correct library: remove EGL from line 5 of CMakeLists (so FindOpenGL no longer searches for it), and at line 52, replace OpenGL::EGL by /usr/lib/nvidia-384/libEGL.so.1.1.0 \n4. cmake ../csrc -D_OPENGL_LIB_PATH=/usr/lib/nvidia-390. 对应驱动版本\n5. cmakecache.txt 加-dndebug\n6. make\n7. cd .. \\ pip install -e .\n8. tests\n\n\n**笔记本会卡死！！！**\n\n## Neural Body Fitting: Unifying Deep Learning and Model Based Human Pose and Shape Estimation（3DV 2018）\n\n### intro\n\n已经有很多成功的工作，生成人体关键点，棒状表示模型（火柴人）（说的就是openpose）  \n这里作者提出的是基于smpl的更具挑战性的任务：estimating the parameters of a detailed statistical human body model from a single image  \n\nTraditional model-based approaches typically optimize an objective function that measures how well the model fits the image observations\n传统的需要一个差不多初始化模型，然后把初值优化到最终结果（不需要3d训练数据——带3d动作标注的图片）  \nCNN就是forward prediction models，就不需要initialization，但是需要3d姿态标注，不像2d标注好获得  \n\n他们近期的工作通过把重建出的模型投影回2d空间更新损失函数，就可以使用2d标注了  \n本文的**目的**：To analyze the importance of such components  \ncomponents: image--(CNN,3d notation trained)-->smpl model(hybird params)-->image--(reproject)-->2d notation for CNN training  \n要形成闭环（loop）  \nNBF = 一个包含统计身体模型的CNN  \n两种监督模式：full 3d sup和weak 2d sup，bottom-up top-down的方法，使得NBF既不需要初始化模型也不需要3d标注的训练数据  \n因为光照、衣服、杂乱的背景都不想要，专注于pose和shape，所以用处理后的image代替原始rgb image  \n结论：\n1. 12-body-part的分割就包含了足够的shape和pose信息\n2. 这种处理后图像的方法比起用原图，效果有竞争力，更简单，训练数据利用率更高\n3. 分割质量可以强有力预测fit质量\n\n总结：\n1. unites deep learning-based with traditional model-based methods\n2. an in-depth analysis of the necessary components to achieve good performance in hybrid architectures and provide insights for its real-world applicability\n\n### related work\n\nMost model-based approaches fit a model to image evidence through complex non-linear optimization, requiring careful initialization to avoid poor local minima.  \n用2d关键点是为了降低fitting复杂度  \nlifting to 3D from 2D information alone is an ambiguous problem  \n\n前人的工作有用rgb image的/image+2d keypoint的/2d keypoint+silhouette的  \nNBF不需要初始化模型，用semantic segmentation做图片代理输入，原因有三：\n1. 去除与3dpose无关的图像信息\n2. 比keypoint和silhouette语义信息多\n3. 允许分析精细程度（粒度）和placement对3d预测的重要程度\n\n三个数据集UP-3D，HumanEva-I，Human3.6M  \n{% pdf 19.6.25_weekly_report.pdf %}\n三个数据集[UP-3D](http://files.is.tuebingen.mpg.de/classner/up/),\n[HumanEva-I](http://humaneva.is.tue.mpg.de/datasets_human_1),\n[Human3.6M](http://vision.imar.ro/human3.6m/description.php)  \n\nup-3d有大量smpl形式的3d标注\n\n其他数据集：\n\n\n**HumanEva-I使用方法**：  \nTo be able to use HumanEva-I dataset you must do the following:  \n  Sing up and agree with the license or Login if you already have an account.  \n  Download the entire HumanEva-I dataset as either zip or tar archive depending on your system.   \n  Download critical HumanEva-I update and update the OFS files.   \n  Download the latest source code.    \n  (optional) Download background statistics   \n  (optional) Download the surface model for subject S4.   \n\n装matlab, XVID codec, DXAVI toolbox, Camera Calibration Toolbox for Matlab  \n给matlab指定了mingw作为c++编译器  \n\n``` bash\nUndefined function or variable 'dxAviOpenMex'.\n\nError in dxAviOpen (line 3)\n\t[hdl, t] = dxAviOpenMex(fname);\n\nError in testDxAvi (line 4)\n[avi_hdl, avi_inf] = dxAviOpen([pathname, filename]);\n```\n\n运行mex_cmd出现\n\n``` bash\nF:\\datasets\\HumanEva-I\\Release_Code_v1_1_beta\\TOOLBOX_dxAvi\\dxAviHelper.h:9:21: fatal error: atlbase.h: No such file or directory\n #include <atlbase.h>\n```\n\n应该是没有这个库的原因，有说是visual studio的库，打算装个vs2019 ATL库试试  \nmatlab不支持2019 mex -setup -v可以看到指搜索到vs2017  \n所以装了vs2015，atlbase就可以了  \n``` bash\nBuilding with 'Microsoft Visual C++ 2015'.\nError using mex\ndxAviOpenMex.cpp\nBaseClasses\\ctlutil.h(278): error C4430: missing type specifier - int assumed. Note: C++ does not support default-int\ng:\\grads\\3dreconstruction\\humaneva-i\\release_code_v1_1_beta\\toolbox_dxavi\\dxAviHelper.h(15): fatal error C1083: Cannot open\ninclude file: 'qedit.h': No such file or directory\n```\n\n原因在这里[link](https://github.com/facebookresearch/VideoPose3D/blob/master/DATASETS.md)\n\ngithub上找了win64编译好的.m脚本，解决。 \n\n**todo** 怎么做validation  \n\n# 实验\n\n## 复原实验\n\n1. Extreme 3D Face Reconstruction: Seeing Through Occlusions [Github](https://github.com/anhttran/extreme_3d_faces)\n   1. 环境：linux docker镜像\n   2. 依赖：\n      * our Bump-CNN\n      * our PyTorch CNN model\n      * the Basel Face Model\n      * 3DDFA Expression Model\n      * 3DMM_model\n      * dlib face prediction model\n2. Learning to Reconstruct People in Clothing from a Single RGB Camera [Github](https://github.com/thmoa/octopus)\n   1. 环境：linux tf\n   2. 依赖：\n      * [DIRT](https://github.com/pmh47/dirt)\n      * [SMPL model](http://smplify.is.tue.mpg.de/)\n      * *[pre-trained model weights](https://drive.google.com/open?id=1_CwZo4i48t1TxIlIuUX3JDo6K7QdYI5r)*\n   3. 备注：图片预处理需要\n      * PGN semantic segmentation：Linux/tensorflow [Code](https://github.com/Engineering-Course/CIHP_PGN)\n      * OpenPose body_25 and face keypoint detection：Win [.exe](https://github.com/CMU-Perceptual-Computing-Lab/openpose)\n3. Neural Body Fitting: Unifying Deep Learning and Model Based Human Pose and Shape Estimation [Github](https://github.com/mohomran/neural_body_fitting)\n   1. 环境：win/linux tensorflow-gpu==1.6.0\n   2. 依赖：\n      * [SMPL model(跟上边的还有区别)](http://smpl.is.tue.mpg.de/downloads)\n      * [segmentation model](http://transfer.d2.mpi-inf.mpg.de/mohomran/nbf/refinenet_up.tgz)\n      * [fitting model](http://transfer.d2.mpi-inf.mpg.de/mohomran/nbf/demo_up.tgz)\n   3. 备注：没training code\n4. tex2shape：\n5. hmr\n6. hmd\n7. shift-net\n\n## 数据集\n\n1. HumanEva-I\n   1. 环境：win/linux matlab\n   2. 依赖：几个toolbox其中dxavi用的github上编译好的.m\n2. UP-3D\n   1. 环境：\n   2. 依赖：\n3. Human3.6M\n   1. 注册不通过（20190716）\n\n## repos\n\n| repo name           | description                                                                                               |\n| :------------------ | :-------------------------------------------------------------------------------------------------------- |\n| VideoPose3D         | 3D human pose estimation in video with temporal convolutions and semi-supervised training                 |\n| smplify-x           | Expressive Body Capture: 3D Hands, Face, and Body from a Single Image                                     |\n| neural_body_fitting | Neural Body Fitting code repository                                                                       |\n| octopus             | Learning to Reconstruct People in Clothing from a Single RGB Camera                                       |\n| videoavatars        | Video based reconstruction of 3D people models                                                            |\n| extreme_3d_faces    | Extreme 3D Face Reconstruction: Seeing Through Occlusions                                                 |\n| 3Dpose_ssl          | 3D Human Pose Machines with Self-supervised Learning                                                      |\n| pose-hg-train       | Training and experimentation code used for \"Stacked Hourglass Networks for Human Pose Estimation\"         |\n| PRNet               | Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network (ECCV 2018)         |\n| vrn                 | Large Pose 3D Face Reconstruction from a Single Image via Direct Volumetric CNN Regression                |\n| openpose            | OpenPose: Real-time multi-person keypoint detection library for body, face, hands, and foot estimation    |\n\n# Code\n\nvscode想在不同的conda环境下都有类型提示和跳转需要在vscode里切环境  \nctrl+shift+P --> python:select interpreter --> {your env}  \n[官方文档](https://code.visualstudio.com/docs/python/environments)  \n\nimport tensorflow 没有报错也没有反应：tensorflow-gpu跟conda安装的opencv有冲突！！  \n改用`pip install opencv-python`就解决了  \n\n同文件夹下module import要加`.`  \n``` python\nimport tensorflow as tf\nfrom .batch_smpl import SMPL\nfrom .joints import joints_body25, face_landmarks\nfrom keras.engine.topology import Layer\n```\n\ngit-lfs在fork的repo上使用会有问题 \"can not upload new objects to public fork\"\n\n## python module\n\ntqdm: process bar tool\ngreenlet/gevent: 协程工具\n\n## octopus\n\n> 流程：  \n读文件（segmentation/pose） png和json文件  \nK.set_session启动tfsession  \n声明model（octopus），加载weights  \n解析segm：io.py里有解析segmentation的方法  \n解析pose  \n优化pose  \n优化shape  \n生成模型（点和面的list）  \n写入obj（write_mesh）  \n\n> opt_pose:  \n> 两组数据: data/supervision  \n> opt_pose_model.fit():\n>   *   \n\n> opt_shape:  \n> data/supervision  \n> opt_shape_model.fit()\n\n想尝试把dirt换了，用别的differentiable renderer\n\n## tex2shape\n\ndecectron2（pytorch环境）先做uv图  \ntex2shape出模型，因为显存不够影响了重建效果（用video2mesh的conda环境就可以（tensorflow+keras））  \n目前的代码是否可以训练模型，hdf5文件怎么生成（keras的hdf5文件，就是tf的ckpt，model.save就完事了，现在主要问题是fit train data）\n\n## hmr End-to-end Recovery of Human Shape and Pose\n\n有train code，可他妈太妙了  \n数据预处理步骤：\n* 数据集lsp --> tfrecord\n* \n\n## datasets\n\n- [LSP](http://sam.johnson.io/research/lsp_dataset.zip) and [LSP extended](http://sam.johnson.io/research/lspet_dataset.zip)\n- [COCO](http://cocodataset.org/#download) we used 2014 Train. You also need to\n  install the [COCO API](https://github.com/cocodataset/cocoapi) for python.\n- [MPII](http://human-pose.mpi-inf.mpg.de/#download)\n- [MPI-INF-3DHP](http://gvv.mpi-inf.mpg.de/3dhp-dataset/)\n- [Human3.6M](http://vision.imar.ro/human3.6m/description.php)\n- [Download link to MoSh](https://drive.google.com/file/d/1b51RMzi_5DIHeYh2KNpgEs8LVaplZSRP/view?usp=sharing)\n\n### 训练数据预处理\n\nTFRecord:数据序列化成二进制的工具\n\n## keras\n\n`keras.layers.Lambda(function, output_shape=None, mask=None, arguments=None)`  \nWraps arbitrary expression as a *Layer* object.\n\nkeras.backend: At this time, Keras has three backend implementations available: the TensorFlow backend, the Theano backend, and the CNTK backend.\n\nLambdaCallback()  \n\n## 要解决的问题\n\n1. 现有数据集的数据怎么处理到能用在smpl上 ！！（解决 hmr里解决了训练数据-->tfrecord的过程）\n2. 确定量化指标 ！！（解决 hmr有evaluation）\n3. 确定遮挡情况下的重建效果！！（hmr，tex2shape，octopus，360texture那个）\n\n## 实验室/作者汇总\n\n| 名称                | 文章                   | 链接                  |\n| :------------------ | :-------------------- | :-------------------- |\n| MPI | SMPL/Octopus/.. | https://virtualhumans.mpi-inf.mpg.de/ |\n| UCB(Angjoo Kanazawa) | 预测人体动作/动物形体重建 | https://people.eecs.berkeley.edu/~kanazawa/ |\n| 周晓巍(浙大) | .. | http://www.cad.zju.edu.cn/home/xzhou/ |\n\n## 技术要点汇总\n\n| 文章名称                | 完成任务               | 技术要点描述           |\n| :--------------------- | :-------------------- | :-------------------- |\n| end to end recovery of human shape and pose(HMR) | an end-to-end framework for reconstructing a full 3D mesh of a human body from a single RGB image 不知道速度怎么样，其他的有做到实时的了 | 不计算2d/3d joint position，使用了一种高效的mesh representation parameterized by shape and joint angles|\n| hmd | 分阶段deformation | hmr做基础模型，找到joint，anchor关键点deformation，在产生个深度图做vertex级别的deformation |\n| deephuman | 不用smpl，直接从image用cnn还原三维结构 | 用了带语义的三维信息semantic volume |\n| bodynet | 不用smpl | hmd里提到的，不用smpl，用cnn找joint找sil构建3d pose再用cnn构建volumetric shape，用smpl监督算一个3d loss。总之就是多loss联合监督回归三维体积 |\n| Deep Textured 3D Reconstruction of Human Bodies | 不用smpl | hmd里提到的 |\n| double fusion | 用的单个深度摄像头，做到实时三维人体重建 | 内外两层模型，里边是smpl外层可以根据深度信息较大幅度的拟合RGB图像 |\n| hyperfusion | 单个深度摄像头+IMUs 惯性测量 | 在处理快速动作，遮挡情况比df更好，这俩重点在于捕捉连贯动作 |\n| Learning to Reconstruct People in Clothing from a Single RGB Camera(Octopus) | 视频1-8帧做人体重建，10秒完成（说是速度快，但是其他的有做到实时的了） | 速度快归功于两点：Tpose下完成特征融合；using both, bottom-up and top-down streams（？？不理解回头看看） |\n| Tex2Shape: Detailed Full Human Body Geometry from a Single Image | 单图重建模型，用了detectron的densepose对图像预处理出IUV图，然后根据原图+IUV图出模型 | 前置条件detectron/densepose/smpl |\n| Multi-Garment Net: Learning to Dress 3D People from Images |  |  |\n| Learning to Estimate 3D Human Pose and Shape from a Single Color Image | 周晓巍 | 跟hmr差不多 hmr用了个判别器，这个用三维模型投影回二维平面做监督 |\n| Learning 3D Human Dynamics from Video | single image预测人体3D past and future motion | present a framework that can similarly learn a representation of 3D dynamics of humans from video via a simple but effective temporal encoding of image features |\n| Predicting 3D Human Dynamics from Video | 跟上边都是UCB的Predicting Human Dynamics (PHD), a neural autoregressive model that takes a video sequence of a person as input to predict the future 3D human mesh motion | \n| LiveCap:Real-time Human Performance Capture from Monocular Video | the first real-time human performance capture approach that reconstructs dense, space-time coherent deforming geometry of entire humans in general everyday clothing from just a single RGB video | 应该是预处理阶段重建模型（需要花费时间），实时添加动作。重点解决两个非线性优化问题，提出两阶段（stage）解决思路 |\n| Three-D Safari: Learning to Estimate Zebra Pose, Shape, and Texture from Images “In the Wild” | 不需要图像分割/关节点标注的动物模型重建 | SMAL |\n| PVNet: Pixel-wise Voting Network for 6DoF Pose Estimation | 对象姿态估计旨在检测对象并估计其相对于规范框架的方向和平移 |  PVNet predicts unit vectors that represent directions from each pixel of the object towards the keypoints. These directions then vote for the keypoint locations based on RANSAC//vector-field presentation |\n\n## 实验规划\n\n> 1. hmr：End-to-end Recovery of Human Shape and Pose\n> 2. octopus 有模型 有纹理贴图 用了Detailed Human Avatars from Monocular Video.的贴图方法\n> 3. tex2shape 这个有衣服的细节 试试有遮挡的情况下重建效果怎么样\n> 4. Learning 3D Human Dynamics from Video\n> 5. Multi-Garment Net: Learning to Dress 3D People from Images\n> 6. pvnet 遮挡截断情况下可以做6DoF Pose Estimation\n\n## 周计划\n\n2019.10.21\n1. 现有数据集的数据怎么处理到能用在smpl上 ！！（hmr有dataset-->tfrecord的code）\n2. 确定量化指标 ！！ （hmr：跟3d groundtruth 点对点算距离，数据集human3.6m -- 这东西不知道啥时候能下载）\n\n2019.10.28\n1. 处理输入图片准备test（图片加遮挡，截断，运动模糊）\n2. hmr、octopus、tex2shape 进行test\n3. test结果进行量化评估\n\n2019.11.4\n1. 复原结果汇总\n2. 贴图怎么上\n3. 量化指标\n\n2019.11.11\n1. 训练code跑起来\n2. 量化指标\n\n## 日报\n\n### 2019.10.28  \nhmr，tex2shape环境部署  \ntodo：处理输入图像，查看结果  \n\n### 2019.10.29\nhmr结果已出，tex2shape需要densepose预处理图片，需要看看densepose对于遮挡，截断，运动模糊的处理情况  \ntodo densepose结果查看  \n\n### 2019.10.30\ndetectron2可以用了，但是2提供的densepose的visualization mode不全，没有IUV，导致作为tex2shape的输入会有问题。还需要继续想办法  \ntodo：hmr基本上没有细节，只有pose和大致shape，接下来要主要关注tex2shape在有遮挡的情况下细节重建的效果  \n找两个带贴图repo试试，octopus/garment/360  \nevaluation没有human3.6做不了，那边注册不通过没法下载  \n\n### 2019.10.31  \n摸鱼\n\n### 2019.11.1\ndetectron2里的densepose没法出IUV的图，不太明白IUV这个图怎么用opencv出。只能在densepose结果图上做遮挡看看tex2shape的重建效果了  \n完成hmr/tex2shape的遮挡测试，todo：octopus/还有smpl加贴图\n\n### 2019.11.2/3\n休\n\n### 2019.11.4\ndirt 有个undefined symbol 大概率是跟显卡驱动 cuda版本有关系 因为笔记本上就装上了  \ndirt装不上garment也没法跑，得想办法用opendr代替dirt  \ndirt装上后有个segmentfault 明天继续看\n整理tex2shape/hmr/octopus的结果  \n明天看看贴图怎么搞，octopus用了个方法，还有garment那个的\n\n### 2019.11.5\noctopus keras.base_layer会报个参数错误  \ndensepose(tex2shape)不知道怎么出IUV  \ngarment(上贴图的)用了MPI-IS的mesh组件 需要python3\nTODO: humaneva, garment, Semantic Human Texture Stitching\n\n### 2019.11.6\n量化指标：the mean per-pixel error of 3d displacements maps  \n中文叫位移贴图/与凹凸贴图（法线贴图属于凹凸图），高度图不同  \n贴图挺顺利的，理论上所有smpl的模型都适用。贴图这边接下来要看怎么用自己的数据（从img-->pkl-->texture）\noctopus还是不行 操他妈的(keras outputs不是layer类型的，不知道为什么)（11.6更新：因为当时smpl()改成了smpl.call()，还是要走基类的__call__()的不然不是Layer类型）  \nLambda表达式是核心问题 明天看\n\n### 2019.11.7\nOctopus解决了，Lambda表达式没问题，smpl那个继承了Layer的类在调用__call__()时调用了call()，后者参数数量与基类Layer的call()参数数量不一致，导致了问题  \nhmr的训练需要groundtruth 3d，先放着吧  \n看effective C++(4/5)\n\n### 2019.11.8\n数据集MPI_inf_3dhp/MPII/COCO 下载  \n下载数据集coco/mpii/mpi_inf_3dhp  \n学习dx12\n\n### 2019.11.9/10\n休\n\n### 2019.11.11\ncoco/lsp/lsp_ext/mocap_neutrMosh/mpii/mpi_inf_3dhp --> tfrecord  \nhmr train code在tf1.14上有问题 降到1.4试试（conda最低1.4） hmr官方用的1.3//客制的有pytorch0.4的\ntrainer.py的train()有问题 --> sess.run时间太长了 1.4得调cuda版本 还是用1.14\n\n### 2019.11.12\n三个新论文 看起来实验会好做一些 train code/dataset都有：\n* PyTorch implementation of CloudWalk's recent work DenseBody https://arxiv.org/pdf/1903.10153.pdf [github](https://github.com/Lotayou/densebody_pytorch)\n* Repository for the paper \"Convolutional Mesh Regression for Single-Image Human Shape Reconstruction\" [github](https://github.com/nkolot/GraphCMR)\n* Detailed Human Shape Estimation from a Single Image by Hierarchical Mesh Deformation (CVPR2019 Oral) [github](https://github.com/zhuhao-nju/hmd)\n\n### 2019.11.13\n看看十大排序七大查找算法（3-0）  \nhmd demo没啥问题 看看train 需要upi的数据集44g 这周五再下  \nevl的用了wild dataset 1.9g//RECON and SYN test\n\n### 2019.11.14\n排序/查找算法\n\n### 2019.11.15\nupi_s1h//human36m_washed//two test dataset for hmd(eval recon and syn sets//wild set)  \n\n### 2019.11.16/17\n休\n\n### 2019.11.18\ntrain without coco & human3.6m coco需要联网用json下文件，实验室电脑没有那么多网关流量，human3.6m没数据集  \ntrain joint的时候dataloader的num有点问题 改成8035试试（worked）done  \ntrain anchor done  \neval test doing  \n跑实验的同时看一下红黑树/B树/B+树  \n\n### 2019.11.19\neval完成  \n看hmd论文 `Detailed Human Shape Estimation from a Single Image by Hierarchical Mesh Deformation`\n\n### 2019.11.20\ntex2shape的模型是有uv的 octopus/hmd都没有uv 所以没法贴图  \n加贴图那个基于octopus，需要绕着人转圈拍照片，然后做分割  \neval_wild on self trained model（10hrs）  \n明天看看遮挡情况下hmd的重建效果\n\n### 2019.11.21\nshell脚本里使用conda命令需要在conda activate前加上  \n`source ~/anaconda3/etc/profile.d/conda.sh`  \n遮挡情况下的hmd效果实验  \neval_wild on self trained model（10hrs）（昨天优点问题 再来一遍） \n\n### 2019.11.22\n确定目标 基于hmr和hmd做遮挡部分的重建  \n看hmd论文，研究hmd怎么加纹理细节的 \n\n### 2019.11.23/24\n休\n\n### 2019.11.25\nshadingnet: hmr 3d mesh --1-> depth map --2-> detailed depth map --3-> detailed 3d mesh  \nhmd里是先shadingnet根据rgb image预测一个depthmap 然后加上mesh(openmesh + hmr smpl) 投影出的depthmap  \nUnet 输入rbg groundtruth depthmap 结果泛化能力差 所以再来个shadingnet loss是前边unet的depthmap loss 还有depth map重建成rbg 跟input的loss  \n需要解决的问题就是设计网络做第二步（doing sfsnet/3dmm/..）  \n先可视化一下depthmap（done）  \n\njoint和anchor都独立与shading的，在有rgb出了joint/anchor的前提下\n\n1. rgb做修复 然后经过shading net(pretrained) 加到project depth map上看结果  \n2. 不处理的rgb 经过shading net(pretrained)生成depth map 然后在dm上做修复 最后加到project depth map上生成最终dm  \n3. 建立端到端网络直接从未处理的rgb-->修复完成的depth map，最后加上project depth map\n\nhmd的数据集刨除h36m应该有18000+ train set，现在只有9000+ 重新用脚本处理一遍\n\nnumpy 高级索引 ndarray[x,y]//ndarray[a==b]\n\n### 2019.11.26\n机器在处理数据（就是做hmd 里的 wild set）（coco做了7000+然后断开socket链接了，回头继续转）  \n问题转化为：有遮挡的rgb图生成完整的深度图的问题  \nDDRNet做的深度图重建。  \n试试[Deeper Depth Prediction with Fully Convolutional Residual Networks (FCRN)](https://github.com/iro-cp/FCRN-DepthPrediction.git)  \n还有[ddrnet](https://github.com/neycyanshi/DDRNet)  \n\n王琛的方法，需要提供人体/遮挡的数据集（考虑下怎么做这个数据集），网络是现成的  \n三维人体重建转化到深度图的inpainting这样可以吗？？  \n\n更新ubuntu grub的引导会没 需要到win7下重设\n\n### 2019.11.27\ncoco数据集的hmd预处理还是有socket error，今晚挂上代理再试一次  \n问题：有遮挡的情况下恢复深度图的detail，还是考虑深度图质量差不多的情况下，深度图生成三维模型的精度  \n见今日周报 基本确定12月的工作内容  \n\n### 2019.11.28\n固定像素位置加遮罩很容易（已完成），考虑往人体固定位置上加？  \n人体的数据集就18000+ 顶多了 看别人做inpainting的得有4/5w  \n监督数据怎么来？1. 通过hmd shading net出深度图；2. 找别的深度估计方法  \n\n### 2019.11.29\n先用shadingnet的结果做gt吧，开始处理数据集\n\n### 2019.11.30/1\neffective c++\n休\n\n### 2019.12.2\n生成depth ground truth 流程如下\nimg-->hmr result（predict_hmr_dm 批处理hmd_2 18403张train img）-->depth result（predict_hmd_dm 生成depth 到hmd_masked/train）  \n做depthmap的gt要150hrs。。？\n\n感觉没人做带遮挡的rgb到depth的映射(也就是inpainting和depth estimation的混合)  \n现有的depth estimation方法 pretrained的model对人体的效果极差 根本比不了hmd的shadingnet结果 见周报图  \nincomplete RGB --> complete depth 做不动  \nincomplete RGB --> incomplete depth --> complete depth  \n想出incomplete depth还得150hrs  \n最后可能只能在深度图上做inpainting\n\n### 2019.12.3\n写周报  \nleetcode\n\n### 2019.12.4\n人体的rgb inpainting目前都没有人做的好，主要是会拿背景的信息填充到人体遮挡区域  \n考虑使用sil，把人体抠出来，看看能不能训练一个针对人体的inpainting网络，再出深度图看效果  \n注：rgb重建的效果也不会特别好，举个例子，拿衣服去补人脸的位置，肯定效果不对。但是，转成深度图再到三维模型上，效果不一定会特别差，待试  \n想想怎么给inpainting的输入加入人体轮廓信息这个约束  \nrbg修复好了 --> 深度图效果好 --> 模型效果好  \n\n王琛表示深度图做修复能做，接下来准备等深度图数据集处理完成，进inpainting网络，训练修复深度图的网络模型。\n\n### 2019.12.5\n玩kbengine，部署linux游戏服务器，打包安卓客户端，双端联机测试  \n深度图要等到周日晚上，给王琛做\n\n### 2019.12.6/7/8\n休\n\n### 2019.12.9\ntrain depth inpainting model  \nshift-net_pytorch 深度图做出npy和png了，shift-net的图片都是256256，我这是448448，需要调整下网络\n\n### 2019.12.10\n开始训练针对深度图的shift-net，30hrs(30 epoch) 明天放到hmd里看效果  \n这次训练用的center mask(25%左右的遮挡率) 有些把人遮住太多了 下次试试随机的或者范围小一点的\n玩kbengine\n\n### 2019.12.11\n贵州电网的一个UI材质工具  \ntrain好的modeltest需要测试集的depth map，2000多张得搞一下  \nhmd的shading-net没有train code，也就是说rgb到depth这段没有源码，shift-net做inpainting已经很好了，如果有shading-net的train code，合起来或许能做 incomplete rgb --> complete depth  \nNYU的数据集看了精度肯定不够  \n\n### 2019.12.12\n出inpainting好的深度图重建出的三维模型，这个算是完成目标了，但是是分两阶段完成（不完整rgb-->不完整depth-->完整depth）  \n接下来看shadingnet怎么train的，得能跑通\n\n3d mesh --> 图像空间 初步深度信息 --》 shadingnet 增强深度信息--》  \nmesh到depth的原理 还有 ddrnet的那个loss  \n\n开题报告\n\n### 2019.12.13/14/15\n开题报告\n\n### 2019.12.16\nhmd: 训练策略（train scheme）是仿照的sfsnet  \n  先用了一个Unet，train时候输入是RGB + hmr投影出来的depth，监督数据是Kinect扫的depth（这个Unet train的时候只用到了少量数据集，然后用训练好的模型生成大量的depth，此时depth效果不好）  \n  然后是shadingnet，train的输入是hmr投影出来的depth和原始RGB，一个loss是用unet的输出监督，一个loss是photometric reconstruction loss（问题是这个reconstruct 重建了什么 就能知道重建的这个玩意儿跟什么做比较成为损失函数）\n\n重点看ddrnet怎么优化depth的，原理是什么\n\n> **阶段性总结**  \n> 1. 明确人体细节是由深度图产生的，三维重建问题转化到深度图修复问题上\n> 2. 做出了深度图数据集 18000+3000\n> 3. shift-net针对深度图训练了一个模型，可以用于深度图恢复\n> 4. tex2shape/octupus/hmr/hmd 基本可以跑对比实验了\n\n接下来的工作是做shadingnet的train  \n对比joint和anchor的train code  \nshadingnet的dataloader返回的是(src_img, depth_diff, mask)为什么要返回diff??? gt和smooth depth的差\n\n### 2019.12.17\n自己做了shadingnet的train code，网络结构Unet（hmd给的），损失函数就用MSE，输入完整rgb还有mask，监督数据depth_gt，learning rate降到0.00001  \n搞搞看能不能rgb到depth 30分钟迭代900多次就训练完了 结束条件是什么不知道 测试中  \n测试结果不好 自己train出来的结果有明显颗粒感 深度数值范围0-1之间，pretrain的+-25之间 明天看\n\n### 2019.12.18\n改开题报告 整点ddrnet的公式进去  \nshading net 用MSE train 完全不收敛啊  \n\nshadingnet dataloader ： mask就是coarse depth？！ 剪影代替的coarse depth？？ wtf  \n\n### 2019.12.19\n两个问题：背景是黄的 是因为背景到人体的过度不自然，pre的是背景是0 人体上是0左右 正负50都有  \n细节是有的 但是我的像素不连续 有细节但是数值跟pre对应不上 颜色深浅  \n换个loss看看结果变不变 完全不变 调参也不变。。\n\n### 2019.12.20\n不清楚网格的问题是不是通过调参就能解决的，或者换loss，还是不知道depth_diff干嘛用的  \n只能换loss了 自定义loss试试\n\n### 2019.12.21\n原因是输入图像和gt图像没有匹配，低级错误  \n下一步进一步调参降低loss\n\n### 2019.12.22\n1. eval pretrained model和我自己的model\n2. shift-net改下输出看结果\n   1. G & D：G把输出的channel改成1，loss得跟depth比；让D区分gtdepth和preddepth\n   2. backward_G and backward_D real_A real_B为什么有两个real？ dataloader在aligned_dataset.py里\n   3. real_A == real_B//real_A-->fake_B\n   4. fake_B--netD-->pred_fake//real_B--netD-->pred_real\n   5. set_gt_latent干什么用的\n\n> 下周开始做改进改进版shift-net的实验\n> 月底开始写论文\n\n### 2019.12.23\n改shift-net：\n  1. Gnet输入RGB，自己加遮罩，生成fake_rgb，用原始RGB监督；Dnet输入RGB和fake_rgb，输出两个判断结果的计算loss\n  2. G输入3通道输出1通道，D出入1通道输出二分类，netD和vgg16featureextractor（util）\n问题： 方框可能太大；把RGB的人挖出来比较好背景干扰太多\n还是应该输出numpy数组，监督数据如果用png出来的是三通道的rgb图，得改可视化的代码，用plt通过numpy数组生成训练过程中图像\n\n### 2019.12.24\n方框缩小，单通道输出，trainning，ETA 25号中午\n\n### 2019.12.25\ntest\n\n### 2019.12.26\nspectral_norm gan用的东西  \n现在要解决的问题：重建深度图不光滑，有明显的网格，重复结构，不知道为什么  \nG就是个encoder decoder 为什么会有网格   \n试试用sil不用深度图的a[b==0] = 0 不行 sil只有8035个  \n把unet最后一层的tanh激活函数删了结果看起来好点了 迭代30次看看效果  \n7次 看起来还原出来的部分并没有什么细节\n\n### 2019.12.27\nshift-net几个损失函数得调整，D一直为0了 content过于大  \nD的输入已经是抠出来的了，opt.overlap是什么\n\n### 2019.12.28/29\n休 \n回放系统、撤销操作  \n\n### 2019.12.30\n开会，确定一月时间安排  \n开始论文初稿，学习latex，写公式最麻烦，网络结构图，柱状图，折线图  \n\n怎么能让遮挡区域的数值乘个系数？？\n\n### 2019.12.31\nabstract完成\n\n### 2019.1.1\n开题ppt完成\n\n### 2019.1.2\nlatex画Unet\n\n### 2019.1.3\n朱青审开题报告，ppt  \n修改\n\n### 2019.1.4/5\n休\n\n### 2019.1.6\nintroduction\nrelated work\nmethod\n\n### 2019.1.7\nresult\nconclusion\n\n>  **论文结构**\n>  1. abstract\n>     \n>  2. introduction\n>     三维人体重建：分两种基于参数化模型的和非的/还是特征匹配的和模板适应的  \n>     目前方法的局限性，我的方法综述，贡献点总结\n>  3. related work  \n>     * 参数化的  \n>       * scape  \n>         * 人工标记关键点\n>           * \n>         * 卷积标记关键点  \n>       * smpl  \n>         \n>     * 非参数化的  \n>     \n>  4. methods  \n>     * SMPL，anchor/joint deformation，**vertex deformation**（our dataset, our net, loss）\n>     * Loss：G_GAN,G_L1,D,style(MSE vgg),content\n>  5. results & comparison  \n>     介绍evaluation用的数据集，评价方法，评价/对比结果  \n>     hmr/hmd/tex2shape/octopus  \n>     原图inpainting/深度图inpainting/遮挡rgb生成完整的深度图  \n>     测试150加遮罩-->(只能不带遮罩的进？？为什么)进shiftnet出深度图-->hmd_s使用深度图信息而非shadingnet信息-->结果\n>  6. conclusion\n\n\n### 2020.1.13\ndhdnet在跑recon测试集的时候方框处理的非常不好  \n现在猜测是因为训练的用深度图gt当作的sil，在A[B==0]=0这步的时候很可能把纹理信息填回方框区域内了。。现在但是理论上shiftnet自己还会加遮罩  \n目前recon测试集上只能用不加遮挡的img做输入效果还可以  \n矛盾点在于 shiftnet是在线加的遮罩啊 为什么输入图像加不加遮罩还会造成影响？？？？\n\n### 2020.1.14\nrecon只看joint 还是得看syn  \n输入图像家的遮罩试着比 shiftnet动态加的小一点 84 84 140 140-->87 87 137 137\n\n### 2020.1.15\nleetcode  \nblog 加入vuejs静态页面  \nMirror 多人游戏demo / kbe C++ 服务端  \n\n\n### 2020.3.8\nAttention机制[zhihu](https://zhuanlan.zhihu.com/p/91839581)  \n论文搜索：  \nSelf-Attention Generative Adversarial Networks (SAGAN)[code](https://github.com/heykeetae/Self-Attention-GAN)  \nA PyTorch reimplementation for paper Generative Image Inpainting with Contextual Attention [paper](https://arxiv.org/abs/1801.07892) [code](https://github.com/daa233/generative-inpainting-pytorch)\n\n### 2020.3.9\n\n[Learning 3D Human Shape and Pose from Dense Body Parts]()\n\n### 2020.5.30\n\nLosses：下降较明显的有G_L1，content；G_GAN略上升，D下降不明显  \nloss计算公式：  \n$lossD = (lossDfake + lossDreal) * 0.5$ (vanilla)  \nfake/real 是BCELoss二分类交叉熵损失函数  \n$loss G = loss G L1 + loss G L1 m + loss G GAN + style loss + content loss + tv loss$  \nloss G L1 是 $L1 loss * opt.lambda_A$  \nL1_m 是一个spatical discounting l1 loss（别的论文里提出来的）  \nloss G GAN 是BCELoss  \nstyle和content都是MSELoss  \ntv是自定义一个损失函数  \n\n目前已有的：\n* rgb特征提取-->分三阶段形变smpl模型\n* depth map到人体表面细节，形变方法（hmd提供）\n* 不完整rgb向完整depth map的转换网络模型\n* 不完整rgb到完整人体模型的端到端系统\n* 合成人体深度信息数据集\n\n后续研究方向（大论文第二章，改进算法）：\n* center mask的大小对重建质量的影响（最大多大就handle不住了）\n* 不规则mask（shiftnet做了，这个好实现）\n* attention机制对于结果的提升有多少（没概念）\n* 目前来看多loss共同作用，有些loss并没有明显收敛（是否等于没作用、贡献）--灼烧实验\n* depth信息到三维点坐标的形变（deform）关系还能改进（比如深度或者说形变的scale，还有方向，目前是垂直于视平面，可以是垂直于粗模型表面？）\n* structure from motion方向研究（全新方向，建筑行业在用）\n* 加壳，做成用户友好的应用程序\n\n### 2020.6.2\n\nICIP论文中的四个示例在recon_set中，编号为1，3，95，116  \n\n### 2020.7.8\n\n专利：\n* 技术背景\n  * 应用与不足\n  * 现有技术分析\n  * 综上\n* 发明内容\n\n\n### 2020.7.13\n\nICIP ppt  \n[mesh deformation with Laplacian coordinates](https://zhuanlan.zhihu.com/p/25804146)：一种智能化的方法，能够让用户只需设置个别离散点的新位置来表达他所想要的形变，就能自动根据所需保持的形体信息来计算出剩余离散点应有的位置\n\n## conda env\n\n  * pytorch：Python 3.7 + pytorch 1.3  detectron2/densepose/shift-net_pytorch\n  * tf2: python2 + tf1.14  hmr, tex2shape, Semantic Human Texture Stitching\n  * tf: python3 + tf1.14 + pytorch  human_dynamics, neuralgym/generative_inpainting\n  * dirt：py2.7 + tf1.13 + dirt  octopus, garment\n  * hmd(可以跟tf2合并)：py2.7 + pytorch1.0.1  hmd\n\n## 实验结果\n\n* 三通道rgb原图到三通道depth.convert('RGB')效果不好，中心预测的不好，四周也没有跟gt完全一致。\n  * 缩小遮挡范围1/2改为1/4的宽高\n  * 输入三通道rgb 输出单通道npy数组 改下可视化的代码使正常显示\n\n* human_depth: 输入三通道depth_png，输出三通道修复完成后的depth_png，这是下边实验的目标效果\n* rgb2depth_npy_2: 初试版本，1/4边长遮挡，王瑾周报\n* rgb2depth_npy_3: G去tanh()版本，网格纹理问题解决\n* rgb2depth_npy_4: 修改D输入图像范围，仅输入被遮挡区域\n\n\n## 数学理论相关\n\n[压缩感知](https://www.zhihu.com/question/28552876/answer/1268629178)中的欠定方程（undetermined equations）：\n\n\n## 目标（朱邮件内容）\n\n研究方向：**非理想条件下的单目RGB相机三维人体重建**  \n\n领域现状：目前基于相机阵列以及单目RGBD相机的三维人体重建技术已经较为成熟，仅依靠单目RGB相机的三维人体重建工作具有广阔的发展前景并且具有挑战性。以MPI、UCB、浙大为首的一些实验室已经在该研究方向上已经取得了一些成果，但是输入图像质量都比较理想，非理想条件下的重建效果并不明确。  \n\n我的工作：目前确定做非理想条件下的单目相机三维人体重建，提高重建精度包括模型细节、姿态、纹理贴图。非理想条件具体来说有以下情况：\n1. 图像中人物受到遮挡（重点）\n2. 图像中人物因高速移动产生的运动模糊\n3. 图像中人物因环境光照产生的视觉偏差\n\n工作计划：看现有方法在上述非理想条件下的重建效果（文章中没有提到的需要亲自跑实验验证）；设计改善方法，反复实验验证，得到实验数据；论文撰写。\n\n# 思路\n\n* 单图多人（人群）三维重建  \n  可能需要解决的问题：  \n  遮挡（周晓巍的PVNet解决了遮挡的问题，空间维度上的估计）  \n  分割  \n  大小/相对位置  \n  ...   \n* 跟游戏开发能关联的地方：  \n  用引擎看效果  \n  实用性  \n\n* 从视频序列中选出作用显著的帧，设计量化评价方法  \n\n* 从不同表达，面点云体素区别入手  \n\n* 增加脸部细节（手部、脚步，观察几个论文的演示视频好像都没有动作细节，骨骼的问题应该是）呢？？结合3dmm（已经有结合的了19.10.10更新）  \n\n* 考虑多模态，加入语义信息辅助重建（还得看nlp的东西，把特征映射到一个空间不知道能不能做）\n\n* **快速移动/运动模糊**的视频/照片做重建（回到图像处理的问题上，不确定目前已有的方法在视频中任务快速移动情况下的重建效果）\n\n* UCB预测人体动作（时间维度上的估计） 能怎么改进\n\n* MPI做的实时 \n\n* UCB把SMPL用到了动物（斑马）模型重建；不是smpl是smal\n\n* 光照条件对重建质量的影响\n\nUCB做了动物的模型重建，根据视频**预测**人体接下来的动作；MPI**实时**Video to Mesh  \n\n>>> shape：更有细节/遮挡、截断(空间维度预测)/  \n>>> pose：根据视频、单图预测pose（时间维度预测）/实时更新pose  \n>>> texture：单视角贴图/多视角贴图\n\n> **疑问**\n> 6D pose estimation 和 smpl/smal重建出的pose有何异同？？是一个东西吗  \n> In contrast to coordinate or\nheatmap based representations, learning such a representa-\ntion enforces the network to focus on local features of ob-\njects and spatial relations between object parts. As a result,\nthe location of an invisible part can be inferred from the vis-\nible parts. In addition, this vector-field representation is able\nto represent object keypoints that are even outside the input\nimage. All these advantages make it an ideal representation\nfor occluded or truncated objects.\n\n## 时间安排\n> VCIP 5月\n> ACM Multimedia 3月\n> ICIP 1月31日\n> > 1月15日初稿和evaluation  \n> \n> 1月开始写论文  \n> 12月实验，开题  \n> 开始编写代码，训练模型，评估实验数据\n> 11月实验  \n> 设计优化思路，实验步骤，预期的实验结果 11.18-11.29 两周\n> 现有方法在非理想情况下的表现 10.21-11.15 四周\n> 10月底规划好实验步骤，预计出的结果\n> 10月18号确定要做的目标\n\n# 信息总结\n\nfusion\nmulity domin\n多元融合\n\n显著性\n摘要\n帧对重建质量的贡献\n\n王少帆 北工大计算机学院\ndblp\n\n# todo list\n\n数据清洗 三个数据集UP-3D，HumanEva-I，Human3.6M  \n清洗的目的？目标？要做成什么样？","content":"<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><p><a href=\"https://arxiv.org/\" target=\"_blank\" rel=\"noopener\">arXiv检索</a></p>\n<ol>\n<li>1812.10558 通过视频素材实现从2d到3d的面部重建来完成测谎</li>\n<li>1812.01742 单一视角的三维重建，使用对抗训练（非人</li>\n<li>1812.05583 基于学习的ICP（迭代最近点算法）重构场景（非人</li>\n<li>1812.07603 通过视频素材的面部模型学习</li>\n<li>1812.05806 自我监督的引导方法，单图片的三维人脸重建</li>\n<li>1812.02822 学习生成模型的隐藏区域（非人</li>\n<li>1901.00049 基于轮廓的衣着人物（全身</li>\n</ol>\n<p><strong>A类</strong></p>\n<ul>\n<li>通过直接体积cnn回归从单图重建大范围三维人脸（源码lua+py</li>\n<li>使用图到图转换的无限制面部重建（源码lua</li>\n</ul>\n<p><strong>老师推荐</strong></p>\n<ul>\n<li>使用affinity field的实时多人二维姿态估计</li>\n</ul>\n<h1 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h1><h2 id=\"通用\"><a href=\"#通用\" class=\"headerlink\" title=\"通用\"></a>通用</h2><p><strong>关于三维重建</strong><br>单个图像进行三维重建的数据驱动方法：一是明确使用三维结构，二是使用其他信息推断三维结构<br>2DImage—&gt;encoder—&gt;latent representation—&gt;decoder—&gt;3DObject<br>不同方法区别在于对三维世界采取的<strong>限制</strong>：多视图一致性学习三维表示、利用关键点和轮廓注释、利用2.5D草图（法线，深度和轮廓）改善预测  </p>\n<p>encoder-decoder的<a href=\"https://blog.csdn.net/chinabing/article/details/78763454\" target=\"_blank\" rel=\"noopener\">含义</a></p>\n<p><strong>关于shape priors</strong><br>许多方法选择更好的捕捉多样的真实形状<br><strong>non-deep方法</strong>关注低维参数模型，使用CNN来学习2D渲染图像和3D形状的<strong>共同嵌入空间</strong><br>其他方法依赖<strong>生成模型</strong>去学习shape priors</p>\n<h2 id=\"博客链接\"><a href=\"#博客链接\" class=\"headerlink\" title=\"博客链接\"></a>博客链接</h2><p><a href=\"https://blog.csdn.net/yyyllla/article/details/84573393\" target=\"_blank\" rel=\"noopener\">3D人脸重建学习笔记CSDN</a><br><a href=\"https://www.jianshu.com/p/f33b3d440f7d\" target=\"_blank\" rel=\"noopener\">3D重建的学习笔记简书</a></p>\n<h2 id=\"Learning-Single-View-3D-Reconstruction-with-Adversarial-Training-1812-01742\"><a href=\"#Learning-Single-View-3D-Reconstruction-with-Adversarial-Training-1812-01742\" class=\"headerlink\" title=\"Learning Single-View 3D Reconstruction with Adversarial Training 1812.01742\"></a>Learning Single-View 3D Reconstruction with Adversarial Training 1812.01742</h2><p>传统方法用多个角度的多张照片实现三维建模<br>问题两个：一是需要大量的观察点；二是物体表面是<em>Lambertian</em>（非反射）albedos是非均匀的<br>另一种三维重建的方式是利用物体外观和形状的知识从单视图二维图像生成（假设shape priors足够丰富）<br>CAD库（computer-aided design）：<u>shapenet，pascal3d+，objectnet3d，pix3d</u>  </p>\n<p>这些方法都从渲染的图像中回归三维形状：将二位图像转化成潜在表示的<strong>编码器</strong> 以及 重建三维表示的<strong>解码器</strong><br>为了学习shape priors深度学习算法需要大量的三维对象注释，自然图像中获取三维注释很有挑战，因此使用合成图像（三维模型渲染出的图像）<br>CNN的<u>domain shift</u>问题，导致基于cnn的三维重建性能恶化  </p>\n<p>这篇文章的方法：提高重建模型性能，为了实现获取三维物体标签，他们shape priors训练出的网络有个<strong>重建损失值</strong>，给这个值引入了两个限制<br>一是受domain shift文献启示，强制让编码的二维特征不变，对应于他们所来自的domain。这样合成图像训练出的编码器在真实图像上表现更好<br>二是将编码的二维特征限制在现实物体的多种形状之中，通过对抗训练定义这两个损失值<br>总结：一个<strong>模型</strong>和<strong>损失函数</strong>，利用shape priors提高自然图像三维重建性能（两种方式使用对抗训练）<br>reconstruction adversarial network(RAN)<br><strong>只使用rgb图像信息</strong>，和易于获取的自然图像。独立于编码器和解码器，并且可以使用到其中<br>借鉴了domain confusion（作用是classification），为了让从合成图像里训练出来的模型在真实图像这边有更好的表现  </p>\n<p>具体方法：todo</p>\n<h2 id=\"通过直接体积cnn回归从单图重建大范围三维人脸\"><a href=\"#通过直接体积cnn回归从单图重建大范围三维人脸\" class=\"headerlink\" title=\"通过直接体积cnn回归从单图重建大范围三维人脸\"></a>通过直接体积cnn回归从单图重建大范围三维人脸</h2><p>目前三维人脸重建的方法多假定有多张面部图片可以使用，这使得重建面临方法上的挑战：在夸张的表情、不均匀光照上建立稠密对应关系<br>这些方法需要复杂低效的管道构建模型，拟合模型。本文建议通过在由2D图像和3D面部模型或扫描组成的适当数据集上训练卷积神经网络<br>（CNN）来解决这些限制</p>\n<h2 id=\"Extreme-3D-Face-Reconstruction-Seeing-Through-Occlusions-极端3D面部重建：遮挡透视（讲）\"><a href=\"#Extreme-3D-Face-Reconstruction-Seeing-Through-Occlusions-极端3D面部重建：遮挡透视（讲）\" class=\"headerlink\" title=\"Extreme 3D Face Reconstruction: Seeing Through Occlusions 极端3D面部重建：遮挡透视（讲）\"></a>Extreme 3D Face Reconstruction: Seeing Through Occlusions 极端3D面部重建：遮挡透视（讲）</h2><p>bumpingmapping概念的推动下，该文提出了一种分层方法。将全局形状与其中细节进行解耦。估计粗糙的3d面部形状为基础，然后将此基础与凹凸贴图表示的细节分开。<br>与本文相关的工作：<br>    reconstruction by example 这类方法用三维脸部形状去调整根据输入图片估计出的模型，降低了观看条件却损失了真实度与准确性<br>    face shape from facial landmarks 这类方法稳定但是模型都差不多，没有细节，而且不清楚遮挡landmark的情况下表现会如何<br>    SfS <em>Shape-From-shading</em> 根据光反射生成细节丰富的模型，但是受环境影响严重，需要满足其对环境的特殊要求。任何遮挡物都会生成到模型中<br>    statistical representations 最著名的方法是3DMM，这篇文改进了这个方法直接根据图片强度信息用cnn回归3DMM的参数和面部细节<br>    deep face shape estimation 深度网络一是直接用深度图重建，二是estimate 3D shapes with anemphasis on unconstrained photo 观察条件高度不变但是细节模糊  </p>\n<p><strong>准备工作</strong><br>矛盾：整体形状的高度正则化vs细节的弱正则化。解决方法：bump map representations which separate global shape from local details<br>    理解的正则化：使模型更有普适性，低正则化是让模型有更多细节、更有特点，反之是让模型更接近普适的规则（每个模型都有一只鼻子一张嘴两只眼睛）<br>给一张图片建立以下几个部分：基础形状——S，面部表情——E，6维度的自由视点——V。接下来是bump map捕捉中级特征（皱纹等非参数的），最后完成因遮挡丢失的细节。<br><strong>添加细节</strong><br>基础形状使用3DMM，3DMM用了resnet的101层网络架构。表情部分由3DDFA提供，更新的有expnet。确定视点用了deep，facepostnet。<br>中等程度细节：image to bump map，修复遮挡细节，基于软对称的模型完善。<br><a href=\"http://vis-www.cs.umass.edu/lfw/\" target=\"_blank\" rel=\"noopener\">LFW验证</a></p>\n<p>PPT用：<br>目的：现有单图三维重建局限性很高，必须在正前方、距离近、无阻挡的视点，该文设计了一种用于在极端条件下提供细节丰富的面部三维重建模型的系统。极端条件包括，头部旋转以及遮挡<br>方法：简单讲步骤，关键的创新点，值得学习的点后边会细说。<br>总的来说：先创建面部整体的基础形状，与局部细节分开，在基础形状之上建立中等程度的面部特征。这样做可以保证极端条件下整体面部形状的稳定性。其他较新的方法往往用局部细节构建整体形状。<br> 构建基础形状s，构建面部表情e，构建视点v：<em>凹凸图可以分离整体形状和局部细节</em><br>这仨东西分别是干什么用的：<em>基础形状使用3DMM，3DMM用了resnet的101层网络架构。表情部分由3DDFA提供，更新的有expnet。确定视点用了deep，facepostnet。</em><br>image to bump map转换<br>凹凸图训练集：用深度编码-解码框架生成凹凸图<br>学习建立凹凸图：定义了自己的网络损失函数，可以在不牺牲高频细节的情况下抑制噪声<br>还原遮挡细节<br>给予范例的空洞填充方法<br>搜索参考集<br>混合细节<br>更复杂的修补<br>基于软对称的模型补全  </p>\n<p>贡献：解决<strong>对foundation的高度正则化</strong> VS <strong>对detail的低正则化</strong> 两者的矛盾  </p>\n<p>注：<br>    bump map使用灰度值来提供高度信息，normal map使用xyz轴所对应的rgb信息<br>    <a href=\"https://github.com/vdumoulin/conv_arithmetic\" target=\"_blank\" rel=\"noopener\">卷积与反卷积</a></p>\n<p>跑demo流程：<br>    NVIDIA-docker启动container，如果跑代码没有driver重新run一个，用readme里的run命令。<br>    之后会出现860m只支持cuda5.0的报错，需要<a href=\"https://github.com/pytorch/pytorch#from-source\" target=\"_blank\" rel=\"noopener\">从源码编译pytorch</a>。首先docker里装anaconda<br>        wget <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2018.12-Linux-x86_64.sh\" target=\"_blank\" rel=\"noopener\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2018.12-Linux-x86_64.sh</a><br>        应该不用在docker里装cuda和cudnn，直接安装pytorch的依赖然后安装pytorch应该就可以<br>        在1080上不会出现上边的报错，完全按照README走就行。</p>\n<p><a href=\"extreme_3d_face.pptx\">PPT</a></p>\n<iframe src=\"https://view.officeapps.live.com/op/view.aspx?src=https://taye310.github.io/2019/01/04/%E5%85%B3%E4%BA%8E%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%9A%84%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0/extreme_3d_face.pptx\" width=\"800\" height=\"600\" frameborder=\"1\"></iframe>\n\n<h2 id=\"Learning-to-Estimate-3D-Human-Pose-and-Shape-from-a-Single-Color-Image-讲-DOI-10-1109-CVPR-2018-00055\"><a href=\"#Learning-to-Estimate-3D-Human-Pose-and-Shape-from-a-Single-Color-Image-讲-DOI-10-1109-CVPR-2018-00055\" class=\"headerlink\" title=\"Learning to Estimate 3D Human Pose and Shape from a Single Color Image(讲) DOI:10.1109/CVPR.2018.00055\"></a>Learning to Estimate 3D Human Pose and Shape from a Single Color Image(讲) DOI:10.1109/CVPR.2018.00055</h2><p>SCAPE:  shape  completion  and  animationof people<br>SMPL: A skinned multi-person linear model<br>SMPL是一种参数化人体模型，与非参数化模型的区别在于，参数化的可以用函数映射的方式表达出来，或者说是可以解析的？非参数化则认为是通过实验记录到的模型，不存在解析表达式。  </p>\n<p>Stacked Hourglass Networks<br><a href=\"https://blog.csdn.net/wangzi371312/article/details/81174452\" target=\"_blank\" rel=\"noopener\">资料一</a><br><a href=\"https://blog.csdn.net/shenxiaolu1984/article/details/51428392\" target=\"_blank\" rel=\"noopener\">资料二</a></p>\n<p><a href=\"https://blog.csdn.net/dengheCSDN/article/details/77848246\" target=\"_blank\" rel=\"noopener\">feature map</a><br>channel:<br>卷积核个数、特征图个数、通道个数关系</p>\n<p><a href=\"Learning to Estimate 3D Human Pose and Shape from a Single Color Image.pptx\">PPT</a></p>\n<iframe src=\"https://view.officeapps.live.com/op/view.aspx?src=https://taye310.github.io/2019/01/04/%E5%85%B3%E4%BA%8E%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%9A%84%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0/Learning to Estimate 3D Human Pose and Shape from a Single Color Image.pptx\" width=\"800\" height=\"600\" frameborder=\"1\"></iframe>\n\n<h2 id=\"O-CNN-Octree-based-Convolutional-Neural-Networks-for-3D-Shape-Analysis\"><a href=\"#O-CNN-Octree-based-Convolutional-Neural-Networks-for-3D-Shape-Analysis\" class=\"headerlink\" title=\"O-CNN: Octree-based Convolutional Neural Networks for 3D Shape Analysis\"></a>O-CNN: Octree-based Convolutional Neural Networks for 3D Shape Analysis</h2><p>还有adaptive o-cnn<br>The main technical challenge of the O-CNN is to parallelize the O-CNN computations defined on the sparse octants so that they can be efficiently executed on the GPU<br>We train this O-CNN model with 3D shape datasets and refine the O-CNN models with different back-ends for three shape analysis tasks, including object classification, shape retrieval, and shape segmentation.</p>\n<h2 id=\"Pixel2Mesh（讲）\"><a href=\"#Pixel2Mesh（讲）\" class=\"headerlink\" title=\"Pixel2Mesh（讲）\"></a>Pixel2Mesh（讲）</h2><h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><p>编译tensorflow math_functions.hpp找不到。需要软链接这个玩意<br>ln -s /usr/local/cuda/include/crt/math_functions.hpp /usr/local/cuda/include/math_functions.hpp  </p>\n<p>关于eigen和cuda<a href=\"https://blog.csdn.net/O1_1O/article/details/80066236\" target=\"_blank\" rel=\"noopener\">资料</a><br>makefile怎么写。<br>hdf5 HDF（Hierarchical Data Format）是一种设计用于存储和组织大量数据的文件格式</p>\n<p><strong>CUDACC_VER</strong> is no longer supported.的报错看来要更新<a href=\"https://blog.csdn.net/luojie140/article/details/80159227\" target=\"_blank\" rel=\"noopener\">eigen3</a>才能解决<br>github上新版eigen考到anaconda的eigen和support里就可以成功编译cuda了</p>\n<p>图卷积神经网络<a href=\"http://tkipf.github.io/graph-convolutional-networks/\" target=\"_blank\" rel=\"noopener\">资料</a><br>图卷积神经网络<a href=\"https://cloud.tencent.com/developer/news/330322\" target=\"_blank\" rel=\"noopener\">材料</a><br><strong>所有的卷积都是在探讨如何对局部数据按照某一个操作聚合，不同的操作方式就对应于不同的卷积。</strong>学习卷积核的过程其实是学习局部聚合参数的过程</p>\n<p><a href=\"pixel2mesh.pptx\">PPT</a></p>\n<iframe src=\"https://view.officeapps.live.com/op/view.aspx?src=https://taye310.github.io/2019/01/04/%E5%85%B3%E4%BA%8E%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%9A%84%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0/pixel2mesh.pptx\" width=\"800\" height=\"600\" frameborder=\"1\"></iframe>\n\n<h2 id=\"SMPL-A-Skinned-Multi-Person-Linear-Model-多篇基础，15年\"><a href=\"#SMPL-A-Skinned-Multi-Person-Linear-Model-多篇基础，15年\" class=\"headerlink\" title=\"SMPL: A Skinned Multi-Person Linear Model(多篇基础，15年)\"></a>SMPL: A Skinned Multi-Person Linear Model(多篇基础，15年)</h2><h2 id=\"Video-Based-Reconstruction-of-3D-People-Models-讲，没用网络-DOI-10-1109-CVPR-2018-00875-video2mesh\"><a href=\"#Video-Based-Reconstruction-of-3D-People-Models-讲，没用网络-DOI-10-1109-CVPR-2018-00875-video2mesh\" class=\"headerlink\" title=\"Video Based Reconstruction of 3D People Models(讲，没用网络) DOI:10.1109/CVPR.2018.00875 (video2mesh)\"></a>Video Based Reconstruction of 3D People Models(讲，没用网络) DOI:10.1109/CVPR.2018.00875 (video2mesh)</h2><p>第五页第一张图解决了人体非刚性的问题<br>但是问题在于人必须转身后摆出相同的姿势 不允许姿势变化<br>第二张图 可以随意动 不同时刻的深度图非张性的注册并融合到一个template上<br>存在 phantom surface的问题 运动的快会四肢胳膊 两个头<br>第三个 加了一个static的人体模型作为约束 运动速度可以更快  </p>\n<p>第一个使用rgb相机 并且支持用户运动的重建方法<br>主要思想 和visual hull相似 不同角度拍摄剪影进行重建<br>visual hull的基本原理 几个角度拍摄 分割出前景得到silhouette<br>然后从相机坐标到silhouette的每一个点可以做一条射线 形成的曲面成为silhouette cone<br>用这些cone作为约束就可以重建出三维模型 可以类比为雕刻的过程<br>去掉cone之外的部分 最终剩下的部分就是人体的形状  </p>\n<p>标准的vh的问题是只能用于静态的物体 这篇的主要是讲怎么把vh用到动态的物体<br>第八页 每帧姿势都不一样 要做的就是去除由于运动对cone造成的变化 称为unpose的过程<br>用unpose的cone做三维重建  </p>\n<p>使用的人体的三维表达：smpl 参数化模型 T是template的mean shape，Bs是体型变化造成的模型变化<br>Bp是pose的变化带来的变化<br>问题在于没有办法model衣服头发面部特征 基础上加了D offset用于表达smpl表达不了的信息  </p>\n<p>四个步骤<br>1 前景分割 获取silhouette cone， tracking获取人体模型的姿态<br>2 利用pose信息做unpose操作 转到Tpose姿态下<br>3 人体重建 包含衣服 头发 人脸的人体模型<br>4 多视角图像生成人体贴图  </p>\n<p>1 基于cnn的方法 2d drawn detection 图像分割的方法 前景分割生成silhouette<br>优化第12页的能量函数 进行pose tracking //简单来说就是求最优的pose和shape的参数 和模型匹配到检测到的<br>2d drawn detection和silhouette上//<br>2 第一步得到的cone进行unpose 每一条射线进行unpose转到canonical pose下<br>//两个数学表达式 射线的转换//<br>任何一点vi 和 任何一条射线ri<br>3 利用unpose后的cone做三维重建 称为consensus shape，相比较SMPL/视频表现出的是可以对衣服进行重建<br>过程可以通过优化一个能量公式实现<br>Edata：模型上的点到unpose ray的距离<br>三个正则项：lap保证局部光滑，body保证重建出的与smpl差距不大，symm保证左右对称<br>4 有了几何信息后 生成appearance信息 生成texture map 第一步有每一帧的pose，精确的将模型覆盖到图像上<br>通过//重投影获得贴图//  </p>\n<p>用sfs（之前的文章有提到）可以提供更多细节，本文方法可以提高的地方<br>对<strong>能量函数</strong>的理解：构建能量函数就是我们用方程的最小值来描述我们想要达到的实际效果。<a href=\"https://blog.csdn.net/a6333230/article/details/80070586\" target=\"_blank\" rel=\"noopener\">资料</a></p>\n<p>第一步最费时间 一帧一分钟 model和silhouette的匹配费时间<br>穿裙子解决不了 改变不了smplmodel的拓扑结构 拉不过去<br>基于cnn的分割已经接近于完美了 用的别人的方法 不是重点<br>给纹理图上色：consensus shape 结合第一步的pose 精确匹配到每一帧的图像上 back projection  </p>\n\n\n\t<div class=\"row\">\n    <embed src=\"videobasedreconstructionof3dpeoplemodelsGAMES201850徐维鹏.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n<p><a href=\"videobasedreconstructionof3dpeoplemodelsGAMES201850徐维鹏.pdf\">ppt</a></p>\n<h2 id=\"Learning-to-Reconstruct-People-in-Clothing-from-a-Single-RGB-Camera（2019-4video2mesh延伸论文，同一实验室）octopus\"><a href=\"#Learning-to-Reconstruct-People-in-Clothing-from-a-Single-RGB-Camera（2019-4video2mesh延伸论文，同一实验室）octopus\" class=\"headerlink\" title=\"Learning to Reconstruct People in Clothing from a Single RGB Camera（2019.4video2mesh延伸论文，同一实验室）octopus\"></a>Learning to Reconstruct People in Clothing from a Single RGB Camera（2019.4video2mesh延伸论文，同一实验室）octopus</h2><p>安装dirt遇到的问题：<a href=\"https://github.com/pmh47/dirt/issues/23\" target=\"_blank\" rel=\"noopener\">https://github.com/pmh47/dirt/issues/23</a><br>已经尝试过cuda10.1/10.0/9.2 cudnn都是对应版本，tensorflow单独测试成功<br>更改gcc/g++版本：<a href=\"https://blog.csdn.net/u012925946/article/details/84584830\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012925946/article/details/84584830</a></p>\n<p>最终安装dirt解决方法是：<br>ubuntu 18.04，cuda 8.0，cudnn 6.0，tf 1.4.0，driver 396.54<br>注意conda install 的 cudatoolkit和cudnn不能取代本机安装的cuda和cudnn，也就是说本机要安cuda，cudnn，conda装tf时要装cudatoolkit，cudnn  </p>\n<p>先装tensorflow再装-gpu 才能启用gpu 前者版本不能比后者高，libcudnn.so.x报错需要在conda里安装tf，tf-gpu。注意版本匹配</p>\n<p>跑Octopus的实验时需要<br>scipy&gt;=1.0.0<br>numpy&gt;=1.16<br>Keras&gt;=2.2.0<br>tensorflow_gpu&gt;=1.11.0<br>dirt<br>否则会报：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(video2mesh) ty@ty-GE60-2PF:~/repos/octopus$ bash run_batch_demo.sh </span><br><span class=\"line\">Using TensorFlow backend.</span><br><span class=\"line\">2019-05-29 15:18:24.784883: I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA</span><br><span class=\"line\">2019-05-29 15:18:24.835566: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:892] successful NUMA node <span class=\"built_in\">read</span> from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class=\"line\">2019-05-29 15:18:24.835835: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1030] Found device 0 with properties: </span><br><span class=\"line\">name: GeForce GTX 860M major: 5 minor: 0 memoryClockRate(GHz): 1.0195</span><br><span class=\"line\">pciBusID: 0000:01:00.0</span><br><span class=\"line\">totalMemory: 1.96GiB freeMemory: 1.08GiB</span><br><span class=\"line\">2019-05-29 15:18:24.835855: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -&gt; (device: 0, name: GeForce GTX 860M, pci bus id: 0000:01:00.0, compute capability: 5.0)</span><br><span class=\"line\">Processing sample...</span><br><span class=\"line\">&gt; Optimizing <span class=\"keyword\">for</span> pose...</span><br><span class=\"line\">  0%|          | 0/10 [00:00&lt;?, ?it/s]</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"infer_batch.py\"</span>, line 87, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    main(args.weights, args.num, args.batch_file, args.opt_steps_pose, args.opt_steps_shape)</span><br><span class=\"line\">  File <span class=\"string\">\"infer_batch.py\"</span>, line 46, <span class=\"keyword\">in</span> main</span><br><span class=\"line\">    model.opt_pose(segmentations, joints_2d, opt_steps=opt_pose_steps)</span><br><span class=\"line\">  File <span class=\"string\">\"/home/ty/repos/octopus/model/octopus.py\"</span>, line 290, <span class=\"keyword\">in</span> opt_pose</span><br><span class=\"line\">    callbacks=[LambdaCallback(on_batch_end=lambda e, l: pbar.update(1))]</span><br><span class=\"line\">  File <span class=\"string\">\"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/engine/training.py\"</span>, line 1010, <span class=\"keyword\">in</span> fit</span><br><span class=\"line\">    self._make_train_function()</span><br><span class=\"line\">  File <span class=\"string\">\"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/engine/training.py\"</span>, line 509, <span class=\"keyword\">in</span> _make_train_function</span><br><span class=\"line\">    loss=self.total_loss)</span><br><span class=\"line\">  File <span class=\"string\">\"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/legacy/interfaces.py\"</span>, line 91, <span class=\"keyword\">in</span> wrapper</span><br><span class=\"line\">    <span class=\"built_in\">return</span> func(*args, **kwargs)</span><br><span class=\"line\">  File <span class=\"string\">\"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/optimizers.py\"</span>, line 475, <span class=\"keyword\">in</span> get_updates</span><br><span class=\"line\">    grads = self.get_gradients(loss, params)</span><br><span class=\"line\">  File <span class=\"string\">\"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/optimizers.py\"</span>, line 89, <span class=\"keyword\">in</span> get_gradients</span><br><span class=\"line\">    grads = K.gradients(loss, params)</span><br><span class=\"line\">  File <span class=\"string\">\"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/keras/backend/tensorflow_backend.py\"</span>, line 2757, <span class=\"keyword\">in</span> gradients</span><br><span class=\"line\">    <span class=\"built_in\">return</span> tf.gradients(loss, variables, colocate_gradients_with_ops=True)</span><br><span class=\"line\">  File <span class=\"string\">\"/home/ty/anaconda3/envs/video2mesh/lib/python2.7/site-packages/tensorflow/python/ops/gradients_impl.py\"</span>, line 555, <span class=\"keyword\">in</span> gradients</span><br><span class=\"line\">    (op.name, op.type))</span><br><span class=\"line\">LookupError: No gradient defined <span class=\"keyword\">for</span> operation <span class=\"string\">'smpl_body25face_layer_1_7/smpl_main/Svd'</span> (op <span class=\"built_in\">type</span>: Svd)</span><br></pre></td></tr></table></figure></p>\n<p>显卡驱动还崩了 用ubuntu自带的怎么切驱动nvidia-smi都会报一行错<br>NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed<br>and running.<br>然后切不懂了卡在390 有这个问题<a href=\"https://askubuntu.com/questions/1035409/installing-nvidia-drivers-on-18-04\" target=\"_blank\" rel=\"noopener\">https://askubuntu.com/questions/1035409/installing-nvidia-drivers-on-18-04</a>  </p>\n<p>2019.6.4 <a href=\"https://github.com/pmh47/dirt/issues/6\" target=\"_blank\" rel=\"noopener\">https://github.com/pmh47/dirt/issues/6</a> dirt inside cmakecache.txt add -DNDEBUG to CMAKE_CUDA_FLAGS:STRING</p>\n<p><a href=\"https://github.com/pmh47/dirt/issues/23\" target=\"_blank\" rel=\"noopener\">https://github.com/pmh47/dirt/issues/23</a><br>tensorflow.python.framework.errors_impl.NotFoundError: /home/ty/repos/dirt/dirt/librasterise.so: undefined symbol: _ZN10tensorflow12OpDefBuilder4AttrESs</p>\n<p>should not use conda install tensorflow &amp; tensorflow-gpu, use pip install instead</p>\n<p>nvidia driver keeps the newest one.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(dirt) zhangtianyi@likun-ThinkStation:~/github/dirt$ python tests/square_test.py </span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"tests/square_test.py\"</span>, line 4, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    import dirt</span><br><span class=\"line\">  File <span class=\"string\">\"/home/zhangtianyi/github/dirt/dirt/__init__.py\"</span>, line 2, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from .rasterise_ops import rasterise, rasterise_batch, rasterise_deferred, rasterise_batch_deferred</span><br><span class=\"line\">  File <span class=\"string\">\"/home/zhangtianyi/github/dirt/dirt/rasterise_ops.py\"</span>, line 6, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    _rasterise_module = tf.load_op_library(_lib_path + <span class=\"string\">'/librasterise.so'</span>)</span><br><span class=\"line\">  File <span class=\"string\">\"/home/zhangtianyi/anaconda3/envs/dirt/lib/python2.7/site-packages/tensorflow/python/framework/load_library.py\"</span>, line 61, <span class=\"keyword\">in</span> load_op_library</span><br><span class=\"line\">    lib_handle = py_tf.TF_LoadLibrary(library_filename)</span><br><span class=\"line\">tensorflow.python.framework.errors_impl.NotFoundError: /home/zhangtianyi/github/dirt/dirt/librasterise.so: undefined symbol: _ZN10tensorflow12OpDefBuilder4AttrESs</span><br></pre></td></tr></table></figure>\n<p>成功安装后test时出现上边的问题 -d_glibcxx_use_cxx11_abi=0改成1 gcc/g++版本从4.9换到5重装dirt就好了</p>\n<p>总结：py2.7 tf1.13.2 cuda 显卡驱动装新的</p>\n<ol>\n<li>setup.py里的dependence去掉用conda装</li>\n<li>cmakelists.txt cmake_flag 加-d_glibcxx_use_cxx11_abi=1</li>\n<li>change CMakeLists.txt line5 into<br><code>find_package(OpenGL REQUIRED COMPONENTS OpenGL EGL)</code><br>comment line9<br>line53 into<br><code>target_link_libraries(rasterise OpenGL::OpenGL OpenGL::EGL ${Tensorflow_LINK_FLAGS})</code><br>As a hack, you can try directly linking the correct library: remove EGL from line 5 of CMakeLists (so FindOpenGL no longer searches for it), and at line 52, replace OpenGL::EGL by /usr/lib/nvidia-384/libEGL.so.1.1.0 </li>\n<li>cmake ../csrc -D_OPENGL_LIB_PATH=/usr/lib/nvidia-390. 对应驱动版本</li>\n<li>cmakecache.txt 加-dndebug</li>\n<li>make</li>\n<li>cd .. \\ pip install -e .</li>\n<li>tests</li>\n</ol>\n<p><strong>笔记本会卡死！！！</strong></p>\n<h2 id=\"Neural-Body-Fitting-Unifying-Deep-Learning-and-Model-Based-Human-Pose-and-Shape-Estimation（3DV-2018）\"><a href=\"#Neural-Body-Fitting-Unifying-Deep-Learning-and-Model-Based-Human-Pose-and-Shape-Estimation（3DV-2018）\" class=\"headerlink\" title=\"Neural Body Fitting: Unifying Deep Learning and Model Based Human Pose and Shape Estimation（3DV 2018）\"></a>Neural Body Fitting: Unifying Deep Learning and Model Based Human Pose and Shape Estimation（3DV 2018）</h2><h3 id=\"intro\"><a href=\"#intro\" class=\"headerlink\" title=\"intro\"></a>intro</h3><p>已经有很多成功的工作，生成人体关键点，棒状表示模型（火柴人）（说的就是openpose）<br>这里作者提出的是基于smpl的更具挑战性的任务：estimating the parameters of a detailed statistical human body model from a single image  </p>\n<p>Traditional model-based approaches typically optimize an objective function that measures how well the model fits the image observations<br>传统的需要一个差不多初始化模型，然后把初值优化到最终结果（不需要3d训练数据——带3d动作标注的图片）<br>CNN就是forward prediction models，就不需要initialization，但是需要3d姿态标注，不像2d标注好获得  </p>\n<p>他们近期的工作通过把重建出的模型投影回2d空间更新损失函数，就可以使用2d标注了<br>本文的<strong>目的</strong>：To analyze the importance of such components<br>components: image—(CNN,3d notation trained)—&gt;smpl model(hybird params)—&gt;image—(reproject)—&gt;2d notation for CNN training<br>要形成闭环（loop）<br>NBF = 一个包含统计身体模型的CNN<br>两种监督模式：full 3d sup和weak 2d sup，bottom-up top-down的方法，使得NBF既不需要初始化模型也不需要3d标注的训练数据<br>因为光照、衣服、杂乱的背景都不想要，专注于pose和shape，所以用处理后的image代替原始rgb image<br>结论：</p>\n<ol>\n<li>12-body-part的分割就包含了足够的shape和pose信息</li>\n<li>这种处理后图像的方法比起用原图，效果有竞争力，更简单，训练数据利用率更高</li>\n<li>分割质量可以强有力预测fit质量</li>\n</ol>\n<p>总结：</p>\n<ol>\n<li>unites deep learning-based with traditional model-based methods</li>\n<li>an in-depth analysis of the necessary components to achieve good performance in hybrid architectures and provide insights for its real-world applicability</li>\n</ol>\n<h3 id=\"related-work\"><a href=\"#related-work\" class=\"headerlink\" title=\"related work\"></a>related work</h3><p>Most model-based approaches fit a model to image evidence through complex non-linear optimization, requiring careful initialization to avoid poor local minima.<br>用2d关键点是为了降低fitting复杂度<br>lifting to 3D from 2D information alone is an ambiguous problem  </p>\n<p>前人的工作有用rgb image的/image+2d keypoint的/2d keypoint+silhouette的<br>NBF不需要初始化模型，用semantic segmentation做图片代理输入，原因有三：</p>\n<ol>\n<li>去除与3dpose无关的图像信息</li>\n<li>比keypoint和silhouette语义信息多</li>\n<li>允许分析精细程度（粒度）和placement对3d预测的重要程度</li>\n</ol>\n<p>三个数据集UP-3D，HumanEva-I，Human3.6M<br>\n\n\t<div class=\"row\">\n    <embed src=\"19.6.25_weekly_report.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n<br>三个数据集<a href=\"http://files.is.tuebingen.mpg.de/classner/up/\" target=\"_blank\" rel=\"noopener\">UP-3D</a>,<br><a href=\"http://humaneva.is.tue.mpg.de/datasets_human_1\" target=\"_blank\" rel=\"noopener\">HumanEva-I</a>,<br><a href=\"http://vision.imar.ro/human3.6m/description.php\" target=\"_blank\" rel=\"noopener\">Human3.6M</a>  </p>\n<p>up-3d有大量smpl形式的3d标注</p>\n<p>其他数据集：</p>\n<p><strong>HumanEva-I使用方法</strong>：<br>To be able to use HumanEva-I dataset you must do the following:<br>  Sing up and agree with the license or Login if you already have an account.<br>  Download the entire HumanEva-I dataset as either zip or tar archive depending on your system.<br>  Download critical HumanEva-I update and update the OFS files.<br>  Download the latest source code.<br>  (optional) Download background statistics<br>  (optional) Download the surface model for subject S4.   </p>\n<p>装matlab, XVID codec, DXAVI toolbox, Camera Calibration Toolbox for Matlab<br>给matlab指定了mingw作为c++编译器  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined <span class=\"keyword\">function</span> or variable <span class=\"string\">'dxAviOpenMex'</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">Error <span class=\"keyword\">in</span> dxAviOpen (line 3)</span><br><span class=\"line\">\t[hdl, t] = dxAviOpenMex(fname);</span><br><span class=\"line\"></span><br><span class=\"line\">Error <span class=\"keyword\">in</span> testDxAvi (line 4)</span><br><span class=\"line\">[avi_hdl, avi_inf] = dxAviOpen([pathname, filename]);</span><br></pre></td></tr></table></figure>\n<p>运行mex_cmd出现</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F:\\datasets\\HumanEva-I\\Release_Code_v1_1_beta\\TOOLBOX_dxAvi\\dxAviHelper.h:9:21: fatal error: atlbase.h: No such file or directory</span><br><span class=\"line\"> <span class=\"comment\">#include &lt;atlbase.h&gt;</span></span><br></pre></td></tr></table></figure>\n<p>应该是没有这个库的原因，有说是visual studio的库，打算装个vs2019 ATL库试试<br>matlab不支持2019 mex -setup -v可以看到指搜索到vs2017<br>所以装了vs2015，atlbase就可以了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Building with <span class=\"string\">'Microsoft Visual C++ 2015'</span>.</span><br><span class=\"line\">Error using mex</span><br><span class=\"line\">dxAviOpenMex.cpp</span><br><span class=\"line\">BaseClasses\\ctlutil.h(278): error C4430: missing <span class=\"built_in\">type</span> specifier - int assumed. Note: C++ does not support default-int</span><br><span class=\"line\">g:\\grads\\3dreconstruction\\humaneva-i\\release_code_v1_1_beta\\toolbox_dxavi\\dxAviHelper.h(15): fatal error C1083: Cannot open</span><br><span class=\"line\">include file: <span class=\"string\">'qedit.h'</span>: No such file or directory</span><br></pre></td></tr></table></figure></p>\n<p>原因在这里<a href=\"https://github.com/facebookresearch/VideoPose3D/blob/master/DATASETS.md\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<p>github上找了win64编译好的.m脚本，解决。 </p>\n<p><strong>todo</strong> 怎么做validation  </p>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><h2 id=\"复原实验\"><a href=\"#复原实验\" class=\"headerlink\" title=\"复原实验\"></a>复原实验</h2><ol>\n<li>Extreme 3D Face Reconstruction: Seeing Through Occlusions <a href=\"https://github.com/anhttran/extreme_3d_faces\" target=\"_blank\" rel=\"noopener\">Github</a><ol>\n<li>环境：linux docker镜像</li>\n<li>依赖：<ul>\n<li>our Bump-CNN</li>\n<li>our PyTorch CNN model</li>\n<li>the Basel Face Model</li>\n<li>3DDFA Expression Model</li>\n<li>3DMM_model</li>\n<li>dlib face prediction model</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>Learning to Reconstruct People in Clothing from a Single RGB Camera <a href=\"https://github.com/thmoa/octopus\" target=\"_blank\" rel=\"noopener\">Github</a><ol>\n<li>环境：linux tf</li>\n<li>依赖：<ul>\n<li><a href=\"https://github.com/pmh47/dirt\" target=\"_blank\" rel=\"noopener\">DIRT</a></li>\n<li><a href=\"http://smplify.is.tue.mpg.de/\" target=\"_blank\" rel=\"noopener\">SMPL model</a></li>\n<li><em><a href=\"https://drive.google.com/open?id=1_CwZo4i48t1TxIlIuUX3JDo6K7QdYI5r\" target=\"_blank\" rel=\"noopener\">pre-trained model weights</a></em></li>\n</ul>\n</li>\n<li>备注：图片预处理需要<ul>\n<li>PGN semantic segmentation：Linux/tensorflow <a href=\"https://github.com/Engineering-Course/CIHP_PGN\" target=\"_blank\" rel=\"noopener\">Code</a></li>\n<li>OpenPose body_25 and face keypoint detection：Win <a href=\"https://github.com/CMU-Perceptual-Computing-Lab/openpose\" target=\"_blank\" rel=\"noopener\">.exe</a></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>Neural Body Fitting: Unifying Deep Learning and Model Based Human Pose and Shape Estimation <a href=\"https://github.com/mohomran/neural_body_fitting\" target=\"_blank\" rel=\"noopener\">Github</a><ol>\n<li>环境：win/linux tensorflow-gpu==1.6.0</li>\n<li>依赖：<ul>\n<li><a href=\"http://smpl.is.tue.mpg.de/downloads\" target=\"_blank\" rel=\"noopener\">SMPL model(跟上边的还有区别)</a></li>\n<li><a href=\"http://transfer.d2.mpi-inf.mpg.de/mohomran/nbf/refinenet_up.tgz\" target=\"_blank\" rel=\"noopener\">segmentation model</a></li>\n<li><a href=\"http://transfer.d2.mpi-inf.mpg.de/mohomran/nbf/demo_up.tgz\" target=\"_blank\" rel=\"noopener\">fitting model</a></li>\n</ul>\n</li>\n<li>备注：没training code</li>\n</ol>\n</li>\n<li>tex2shape：</li>\n<li>hmr</li>\n<li>hmd</li>\n<li>shift-net</li>\n</ol>\n<h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><ol>\n<li>HumanEva-I<ol>\n<li>环境：win/linux matlab</li>\n<li>依赖：几个toolbox其中dxavi用的github上编译好的.m</li>\n</ol>\n</li>\n<li>UP-3D<ol>\n<li>环境：</li>\n<li>依赖：</li>\n</ol>\n</li>\n<li>Human3.6M<ol>\n<li>注册不通过（20190716）</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"repos\"><a href=\"#repos\" class=\"headerlink\" title=\"repos\"></a>repos</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">repo name</th>\n<th style=\"text-align:left\">description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">VideoPose3D</td>\n<td style=\"text-align:left\">3D human pose estimation in video with temporal convolutions and semi-supervised training</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">smplify-x</td>\n<td style=\"text-align:left\">Expressive Body Capture: 3D Hands, Face, and Body from a Single Image</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">neural_body_fitting</td>\n<td style=\"text-align:left\">Neural Body Fitting code repository</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">octopus</td>\n<td style=\"text-align:left\">Learning to Reconstruct People in Clothing from a Single RGB Camera</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">videoavatars</td>\n<td style=\"text-align:left\">Video based reconstruction of 3D people models</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">extreme_3d_faces</td>\n<td style=\"text-align:left\">Extreme 3D Face Reconstruction: Seeing Through Occlusions</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3Dpose_ssl</td>\n<td style=\"text-align:left\">3D Human Pose Machines with Self-supervised Learning</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pose-hg-train</td>\n<td style=\"text-align:left\">Training and experimentation code used for “Stacked Hourglass Networks for Human Pose Estimation”</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PRNet</td>\n<td style=\"text-align:left\">Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network (ECCV 2018)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">vrn</td>\n<td style=\"text-align:left\">Large Pose 3D Face Reconstruction from a Single Image via Direct Volumetric CNN Regression</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">openpose</td>\n<td style=\"text-align:left\">OpenPose: Real-time multi-person keypoint detection library for body, face, hands, and foot estimation</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><p>vscode想在不同的conda环境下都有类型提示和跳转需要在vscode里切环境<br>ctrl+shift+P —&gt; python:select interpreter —&gt; {your env}<br><a href=\"https://code.visualstudio.com/docs/python/environments\" target=\"_blank\" rel=\"noopener\">官方文档</a>  </p>\n<p>import tensorflow 没有报错也没有反应：tensorflow-gpu跟conda安装的opencv有冲突！！<br>改用<code>pip install opencv-python</code>就解决了  </p>\n<p>同文件夹下module import要加<code>.</code><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">from</span> .batch_smpl <span class=\"keyword\">import</span> SMPL</span><br><span class=\"line\"><span class=\"keyword\">from</span> .joints <span class=\"keyword\">import</span> joints_body25, face_landmarks</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras.engine.topology <span class=\"keyword\">import</span> Layer</span><br></pre></td></tr></table></figure></p>\n<p>git-lfs在fork的repo上使用会有问题 “can not upload new objects to public fork”</p>\n<h2 id=\"python-module\"><a href=\"#python-module\" class=\"headerlink\" title=\"python module\"></a>python module</h2><p>tqdm: process bar tool<br>greenlet/gevent: 协程工具</p>\n<h2 id=\"octopus\"><a href=\"#octopus\" class=\"headerlink\" title=\"octopus\"></a>octopus</h2><blockquote>\n<p>流程：<br>读文件（segmentation/pose） png和json文件<br>K.set_session启动tfsession<br>声明model（octopus），加载weights<br>解析segm：io.py里有解析segmentation的方法<br>解析pose<br>优化pose<br>优化shape<br>生成模型（点和面的list）<br>写入obj（write_mesh）  </p>\n<p>opt_pose:<br>两组数据: data/supervision<br>opt_pose_model.fit():</p>\n<ul>\n<li></li>\n</ul>\n<p>opt_shape:<br>data/supervision<br>opt_shape_model.fit()</p>\n</blockquote>\n<p>想尝试把dirt换了，用别的differentiable renderer</p>\n<h2 id=\"tex2shape\"><a href=\"#tex2shape\" class=\"headerlink\" title=\"tex2shape\"></a>tex2shape</h2><p>decectron2（pytorch环境）先做uv图<br>tex2shape出模型，因为显存不够影响了重建效果（用video2mesh的conda环境就可以（tensorflow+keras））<br>目前的代码是否可以训练模型，hdf5文件怎么生成（keras的hdf5文件，就是tf的ckpt，model.save就完事了，现在主要问题是fit train data）</p>\n<h2 id=\"hmr-End-to-end-Recovery-of-Human-Shape-and-Pose\"><a href=\"#hmr-End-to-end-Recovery-of-Human-Shape-and-Pose\" class=\"headerlink\" title=\"hmr End-to-end Recovery of Human Shape and Pose\"></a>hmr End-to-end Recovery of Human Shape and Pose</h2><p>有train code，可他妈太妙了<br>数据预处理步骤：</p>\n<ul>\n<li>数据集lsp —&gt; tfrecord</li>\n<li></li>\n</ul>\n<h2 id=\"datasets\"><a href=\"#datasets\" class=\"headerlink\" title=\"datasets\"></a>datasets</h2><ul>\n<li><a href=\"http://sam.johnson.io/research/lsp_dataset.zip\" target=\"_blank\" rel=\"noopener\">LSP</a> and <a href=\"http://sam.johnson.io/research/lspet_dataset.zip\" target=\"_blank\" rel=\"noopener\">LSP extended</a></li>\n<li><a href=\"http://cocodataset.org/#download\" target=\"_blank\" rel=\"noopener\">COCO</a> we used 2014 Train. You also need to<br>install the <a href=\"https://github.com/cocodataset/cocoapi\" target=\"_blank\" rel=\"noopener\">COCO API</a> for python.</li>\n<li><a href=\"http://human-pose.mpi-inf.mpg.de/#download\" target=\"_blank\" rel=\"noopener\">MPII</a></li>\n<li><a href=\"http://gvv.mpi-inf.mpg.de/3dhp-dataset/\" target=\"_blank\" rel=\"noopener\">MPI-INF-3DHP</a></li>\n<li><a href=\"http://vision.imar.ro/human3.6m/description.php\" target=\"_blank\" rel=\"noopener\">Human3.6M</a></li>\n<li><a href=\"https://drive.google.com/file/d/1b51RMzi_5DIHeYh2KNpgEs8LVaplZSRP/view?usp=sharing\" target=\"_blank\" rel=\"noopener\">Download link to MoSh</a></li>\n</ul>\n<h3 id=\"训练数据预处理\"><a href=\"#训练数据预处理\" class=\"headerlink\" title=\"训练数据预处理\"></a>训练数据预处理</h3><p>TFRecord:数据序列化成二进制的工具</p>\n<h2 id=\"keras\"><a href=\"#keras\" class=\"headerlink\" title=\"keras\"></a>keras</h2><p><code>keras.layers.Lambda(function, output_shape=None, mask=None, arguments=None)</code><br>Wraps arbitrary expression as a <em>Layer</em> object.</p>\n<p>keras.backend: At this time, Keras has three backend implementations available: the TensorFlow backend, the Theano backend, and the CNTK backend.</p>\n<p>LambdaCallback()  </p>\n<h2 id=\"要解决的问题\"><a href=\"#要解决的问题\" class=\"headerlink\" title=\"要解决的问题\"></a>要解决的问题</h2><ol>\n<li>现有数据集的数据怎么处理到能用在smpl上 ！！（解决 hmr里解决了训练数据—&gt;tfrecord的过程）</li>\n<li>确定量化指标 ！！（解决 hmr有evaluation）</li>\n<li>确定遮挡情况下的重建效果！！（hmr，tex2shape，octopus，360texture那个）</li>\n</ol>\n<h2 id=\"实验室-作者汇总\"><a href=\"#实验室-作者汇总\" class=\"headerlink\" title=\"实验室/作者汇总\"></a>实验室/作者汇总</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">文章</th>\n<th style=\"text-align:left\">链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">MPI</td>\n<td style=\"text-align:left\">SMPL/Octopus/..</td>\n<td style=\"text-align:left\"><a href=\"https://virtualhumans.mpi-inf.mpg.de/\" target=\"_blank\" rel=\"noopener\">https://virtualhumans.mpi-inf.mpg.de/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UCB(Angjoo Kanazawa)</td>\n<td style=\"text-align:left\">预测人体动作/动物形体重建</td>\n<td style=\"text-align:left\"><a href=\"https://people.eecs.berkeley.edu/~kanazawa/\" target=\"_blank\" rel=\"noopener\">https://people.eecs.berkeley.edu/~kanazawa/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">周晓巍(浙大)</td>\n<td style=\"text-align:left\">..</td>\n<td style=\"text-align:left\"><a href=\"http://www.cad.zju.edu.cn/home/xzhou/\" target=\"_blank\" rel=\"noopener\">http://www.cad.zju.edu.cn/home/xzhou/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"技术要点汇总\"><a href=\"#技术要点汇总\" class=\"headerlink\" title=\"技术要点汇总\"></a>技术要点汇总</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">文章名称</th>\n<th style=\"text-align:left\">完成任务</th>\n<th style=\"text-align:left\">技术要点描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">end to end recovery of human shape and pose(HMR)</td>\n<td style=\"text-align:left\">an end-to-end framework for reconstructing a full 3D mesh of a human body from a single RGB image 不知道速度怎么样，其他的有做到实时的了</td>\n<td style=\"text-align:left\">不计算2d/3d joint position，使用了一种高效的mesh representation parameterized by shape and joint angles</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">hmd</td>\n<td style=\"text-align:left\">分阶段deformation</td>\n<td style=\"text-align:left\">hmr做基础模型，找到joint，anchor关键点deformation，在产生个深度图做vertex级别的deformation</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">deephuman</td>\n<td style=\"text-align:left\">不用smpl，直接从image用cnn还原三维结构</td>\n<td style=\"text-align:left\">用了带语义的三维信息semantic volume</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">bodynet</td>\n<td style=\"text-align:left\">不用smpl</td>\n<td style=\"text-align:left\">hmd里提到的，不用smpl，用cnn找joint找sil构建3d pose再用cnn构建volumetric shape，用smpl监督算一个3d loss。总之就是多loss联合监督回归三维体积</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Deep Textured 3D Reconstruction of Human Bodies</td>\n<td style=\"text-align:left\">不用smpl</td>\n<td style=\"text-align:left\">hmd里提到的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">double fusion</td>\n<td style=\"text-align:left\">用的单个深度摄像头，做到实时三维人体重建</td>\n<td style=\"text-align:left\">内外两层模型，里边是smpl外层可以根据深度信息较大幅度的拟合RGB图像</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">hyperfusion</td>\n<td style=\"text-align:left\">单个深度摄像头+IMUs 惯性测量</td>\n<td style=\"text-align:left\">在处理快速动作，遮挡情况比df更好，这俩重点在于捕捉连贯动作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Learning to Reconstruct People in Clothing from a Single RGB Camera(Octopus)</td>\n<td style=\"text-align:left\">视频1-8帧做人体重建，10秒完成（说是速度快，但是其他的有做到实时的了）</td>\n<td style=\"text-align:left\">速度快归功于两点：Tpose下完成特征融合；using both, bottom-up and top-down streams（？？不理解回头看看）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Tex2Shape: Detailed Full Human Body Geometry from a Single Image</td>\n<td style=\"text-align:left\">单图重建模型，用了detectron的densepose对图像预处理出IUV图，然后根据原图+IUV图出模型</td>\n<td style=\"text-align:left\">前置条件detectron/densepose/smpl</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Multi-Garment Net: Learning to Dress 3D People from Images</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Learning to Estimate 3D Human Pose and Shape from a Single Color Image</td>\n<td style=\"text-align:left\">周晓巍</td>\n<td style=\"text-align:left\">跟hmr差不多 hmr用了个判别器，这个用三维模型投影回二维平面做监督</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Learning 3D Human Dynamics from Video</td>\n<td style=\"text-align:left\">single image预测人体3D past and future motion</td>\n<td style=\"text-align:left\">present a framework that can similarly learn a representation of 3D dynamics of humans from video via a simple but effective temporal encoding of image features</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Predicting 3D Human Dynamics from Video</td>\n<td style=\"text-align:left\">跟上边都是UCB的Predicting Human Dynamics (PHD), a neural autoregressive model that takes a video sequence of a person as input to predict the future 3D human mesh motion</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LiveCap:Real-time Human Performance Capture from Monocular Video</td>\n<td style=\"text-align:left\">the first real-time human performance capture approach that reconstructs dense, space-time coherent deforming geometry of entire humans in general everyday clothing from just a single RGB video</td>\n<td style=\"text-align:left\">应该是预处理阶段重建模型（需要花费时间），实时添加动作。重点解决两个非线性优化问题，提出两阶段（stage）解决思路</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Three-D Safari: Learning to Estimate Zebra Pose, Shape, and Texture from Images “In the Wild”</td>\n<td style=\"text-align:left\">不需要图像分割/关节点标注的动物模型重建</td>\n<td style=\"text-align:left\">SMAL</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVNet: Pixel-wise Voting Network for 6DoF Pose Estimation</td>\n<td style=\"text-align:left\">对象姿态估计旨在检测对象并估计其相对于规范框架的方向和平移</td>\n<td style=\"text-align:left\">PVNet predicts unit vectors that represent directions from each pixel of the object towards the keypoints. These directions then vote for the keypoint locations based on RANSAC//vector-field presentation</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"实验规划\"><a href=\"#实验规划\" class=\"headerlink\" title=\"实验规划\"></a>实验规划</h2><blockquote>\n<ol>\n<li>hmr：End-to-end Recovery of Human Shape and Pose</li>\n<li>octopus 有模型 有纹理贴图 用了Detailed Human Avatars from Monocular Video.的贴图方法</li>\n<li>tex2shape 这个有衣服的细节 试试有遮挡的情况下重建效果怎么样</li>\n<li>Learning 3D Human Dynamics from Video</li>\n<li>Multi-Garment Net: Learning to Dress 3D People from Images</li>\n<li>pvnet 遮挡截断情况下可以做6DoF Pose Estimation</li>\n</ol>\n</blockquote>\n<h2 id=\"周计划\"><a href=\"#周计划\" class=\"headerlink\" title=\"周计划\"></a>周计划</h2><p>2019.10.21</p>\n<ol>\n<li>现有数据集的数据怎么处理到能用在smpl上 ！！（hmr有dataset—&gt;tfrecord的code）</li>\n<li>确定量化指标 ！！ （hmr：跟3d groundtruth 点对点算距离，数据集human3.6m — 这东西不知道啥时候能下载）</li>\n</ol>\n<p>2019.10.28</p>\n<ol>\n<li>处理输入图片准备test（图片加遮挡，截断，运动模糊）</li>\n<li>hmr、octopus、tex2shape 进行test</li>\n<li>test结果进行量化评估</li>\n</ol>\n<p>2019.11.4</p>\n<ol>\n<li>复原结果汇总</li>\n<li>贴图怎么上</li>\n<li>量化指标</li>\n</ol>\n<p>2019.11.11</p>\n<ol>\n<li>训练code跑起来</li>\n<li>量化指标</li>\n</ol>\n<h2 id=\"日报\"><a href=\"#日报\" class=\"headerlink\" title=\"日报\"></a>日报</h2><h3 id=\"2019-10-28\"><a href=\"#2019-10-28\" class=\"headerlink\" title=\"2019.10.28\"></a>2019.10.28</h3><p>hmr，tex2shape环境部署<br>todo：处理输入图像，查看结果  </p>\n<h3 id=\"2019-10-29\"><a href=\"#2019-10-29\" class=\"headerlink\" title=\"2019.10.29\"></a>2019.10.29</h3><p>hmr结果已出，tex2shape需要densepose预处理图片，需要看看densepose对于遮挡，截断，运动模糊的处理情况<br>todo densepose结果查看  </p>\n<h3 id=\"2019-10-30\"><a href=\"#2019-10-30\" class=\"headerlink\" title=\"2019.10.30\"></a>2019.10.30</h3><p>detectron2可以用了，但是2提供的densepose的visualization mode不全，没有IUV，导致作为tex2shape的输入会有问题。还需要继续想办法<br>todo：hmr基本上没有细节，只有pose和大致shape，接下来要主要关注tex2shape在有遮挡的情况下细节重建的效果<br>找两个带贴图repo试试，octopus/garment/360<br>evaluation没有human3.6做不了，那边注册不通过没法下载  </p>\n<h3 id=\"2019-10-31\"><a href=\"#2019-10-31\" class=\"headerlink\" title=\"2019.10.31\"></a>2019.10.31</h3><p>摸鱼</p>\n<h3 id=\"2019-11-1\"><a href=\"#2019-11-1\" class=\"headerlink\" title=\"2019.11.1\"></a>2019.11.1</h3><p>detectron2里的densepose没法出IUV的图，不太明白IUV这个图怎么用opencv出。只能在densepose结果图上做遮挡看看tex2shape的重建效果了<br>完成hmr/tex2shape的遮挡测试，todo：octopus/还有smpl加贴图</p>\n<h3 id=\"2019-11-2-3\"><a href=\"#2019-11-2-3\" class=\"headerlink\" title=\"2019.11.2/3\"></a>2019.11.2/3</h3><p>休</p>\n<h3 id=\"2019-11-4\"><a href=\"#2019-11-4\" class=\"headerlink\" title=\"2019.11.4\"></a>2019.11.4</h3><p>dirt 有个undefined symbol 大概率是跟显卡驱动 cuda版本有关系 因为笔记本上就装上了<br>dirt装不上garment也没法跑，得想办法用opendr代替dirt<br>dirt装上后有个segmentfault 明天继续看<br>整理tex2shape/hmr/octopus的结果<br>明天看看贴图怎么搞，octopus用了个方法，还有garment那个的</p>\n<h3 id=\"2019-11-5\"><a href=\"#2019-11-5\" class=\"headerlink\" title=\"2019.11.5\"></a>2019.11.5</h3><p>octopus keras.base_layer会报个参数错误<br>densepose(tex2shape)不知道怎么出IUV<br>garment(上贴图的)用了MPI-IS的mesh组件 需要python3<br>TODO: humaneva, garment, Semantic Human Texture Stitching</p>\n<h3 id=\"2019-11-6\"><a href=\"#2019-11-6\" class=\"headerlink\" title=\"2019.11.6\"></a>2019.11.6</h3><p>量化指标：the mean per-pixel error of 3d displacements maps<br>中文叫位移贴图/与凹凸贴图（法线贴图属于凹凸图），高度图不同<br>贴图挺顺利的，理论上所有smpl的模型都适用。贴图这边接下来要看怎么用自己的数据（从img—&gt;pkl—&gt;texture）<br>octopus还是不行 操他妈的(keras outputs不是layer类型的，不知道为什么)（11.6更新：因为当时smpl()改成了smpl.call()，还是要走基类的<strong>call</strong>()的不然不是Layer类型）<br>Lambda表达式是核心问题 明天看</p>\n<h3 id=\"2019-11-7\"><a href=\"#2019-11-7\" class=\"headerlink\" title=\"2019.11.7\"></a>2019.11.7</h3><p>Octopus解决了，Lambda表达式没问题，smpl那个继承了Layer的类在调用<strong>call</strong>()时调用了call()，后者参数数量与基类Layer的call()参数数量不一致，导致了问题<br>hmr的训练需要groundtruth 3d，先放着吧<br>看effective C++(4/5)</p>\n<h3 id=\"2019-11-8\"><a href=\"#2019-11-8\" class=\"headerlink\" title=\"2019.11.8\"></a>2019.11.8</h3><p>数据集MPI_inf_3dhp/MPII/COCO 下载<br>下载数据集coco/mpii/mpi_inf_3dhp<br>学习dx12</p>\n<h3 id=\"2019-11-9-10\"><a href=\"#2019-11-9-10\" class=\"headerlink\" title=\"2019.11.9/10\"></a>2019.11.9/10</h3><p>休</p>\n<h3 id=\"2019-11-11\"><a href=\"#2019-11-11\" class=\"headerlink\" title=\"2019.11.11\"></a>2019.11.11</h3><p>coco/lsp/lsp_ext/mocap_neutrMosh/mpii/mpi_inf_3dhp —&gt; tfrecord<br>hmr train code在tf1.14上有问题 降到1.4试试（conda最低1.4） hmr官方用的1.3//客制的有pytorch0.4的<br>trainer.py的train()有问题 —&gt; sess.run时间太长了 1.4得调cuda版本 还是用1.14</p>\n<h3 id=\"2019-11-12\"><a href=\"#2019-11-12\" class=\"headerlink\" title=\"2019.11.12\"></a>2019.11.12</h3><p>三个新论文 看起来实验会好做一些 train code/dataset都有：</p>\n<ul>\n<li>PyTorch implementation of CloudWalk’s recent work DenseBody <a href=\"https://arxiv.org/pdf/1903.10153.pdf\" target=\"_blank\" rel=\"noopener\">https://arxiv.org/pdf/1903.10153.pdf</a> <a href=\"https://github.com/Lotayou/densebody_pytorch\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li>Repository for the paper “Convolutional Mesh Regression for Single-Image Human Shape Reconstruction” <a href=\"https://github.com/nkolot/GraphCMR\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li>Detailed Human Shape Estimation from a Single Image by Hierarchical Mesh Deformation (CVPR2019 Oral) <a href=\"https://github.com/zhuhao-nju/hmd\" target=\"_blank\" rel=\"noopener\">github</a></li>\n</ul>\n<h3 id=\"2019-11-13\"><a href=\"#2019-11-13\" class=\"headerlink\" title=\"2019.11.13\"></a>2019.11.13</h3><p>看看十大排序七大查找算法（3-0）<br>hmd demo没啥问题 看看train 需要upi的数据集44g 这周五再下<br>evl的用了wild dataset 1.9g//RECON and SYN test</p>\n<h3 id=\"2019-11-14\"><a href=\"#2019-11-14\" class=\"headerlink\" title=\"2019.11.14\"></a>2019.11.14</h3><p>排序/查找算法</p>\n<h3 id=\"2019-11-15\"><a href=\"#2019-11-15\" class=\"headerlink\" title=\"2019.11.15\"></a>2019.11.15</h3><p>upi_s1h//human36m_washed//two test dataset for hmd(eval recon and syn sets//wild set)  </p>\n<h3 id=\"2019-11-16-17\"><a href=\"#2019-11-16-17\" class=\"headerlink\" title=\"2019.11.16/17\"></a>2019.11.16/17</h3><p>休</p>\n<h3 id=\"2019-11-18\"><a href=\"#2019-11-18\" class=\"headerlink\" title=\"2019.11.18\"></a>2019.11.18</h3><p>train without coco &amp; human3.6m coco需要联网用json下文件，实验室电脑没有那么多网关流量，human3.6m没数据集<br>train joint的时候dataloader的num有点问题 改成8035试试（worked）done<br>train anchor done<br>eval test doing<br>跑实验的同时看一下红黑树/B树/B+树  </p>\n<h3 id=\"2019-11-19\"><a href=\"#2019-11-19\" class=\"headerlink\" title=\"2019.11.19\"></a>2019.11.19</h3><p>eval完成<br>看hmd论文 <code>Detailed Human Shape Estimation from a Single Image by Hierarchical Mesh Deformation</code></p>\n<h3 id=\"2019-11-20\"><a href=\"#2019-11-20\" class=\"headerlink\" title=\"2019.11.20\"></a>2019.11.20</h3><p>tex2shape的模型是有uv的 octopus/hmd都没有uv 所以没法贴图<br>加贴图那个基于octopus，需要绕着人转圈拍照片，然后做分割<br>eval_wild on self trained model（10hrs）<br>明天看看遮挡情况下hmd的重建效果</p>\n<h3 id=\"2019-11-21\"><a href=\"#2019-11-21\" class=\"headerlink\" title=\"2019.11.21\"></a>2019.11.21</h3><p>shell脚本里使用conda命令需要在conda activate前加上<br><code>source ~/anaconda3/etc/profile.d/conda.sh</code><br>遮挡情况下的hmd效果实验<br>eval_wild on self trained model（10hrs）（昨天优点问题 再来一遍） </p>\n<h3 id=\"2019-11-22\"><a href=\"#2019-11-22\" class=\"headerlink\" title=\"2019.11.22\"></a>2019.11.22</h3><p>确定目标 基于hmr和hmd做遮挡部分的重建<br>看hmd论文，研究hmd怎么加纹理细节的 </p>\n<h3 id=\"2019-11-23-24\"><a href=\"#2019-11-23-24\" class=\"headerlink\" title=\"2019.11.23/24\"></a>2019.11.23/24</h3><p>休</p>\n<h3 id=\"2019-11-25\"><a href=\"#2019-11-25\" class=\"headerlink\" title=\"2019.11.25\"></a>2019.11.25</h3><p>shadingnet: hmr 3d mesh —1-&gt; depth map —2-&gt; detailed depth map —3-&gt; detailed 3d mesh<br>hmd里是先shadingnet根据rgb image预测一个depthmap 然后加上mesh(openmesh + hmr smpl) 投影出的depthmap<br>Unet 输入rbg groundtruth depthmap 结果泛化能力差 所以再来个shadingnet loss是前边unet的depthmap loss 还有depth map重建成rbg 跟input的loss<br>需要解决的问题就是设计网络做第二步（doing sfsnet/3dmm/..）<br>先可视化一下depthmap（done）  </p>\n<p>joint和anchor都独立与shading的，在有rgb出了joint/anchor的前提下</p>\n<ol>\n<li>rgb做修复 然后经过shading net(pretrained) 加到project depth map上看结果  </li>\n<li>不处理的rgb 经过shading net(pretrained)生成depth map 然后在dm上做修复 最后加到project depth map上生成最终dm  </li>\n<li>建立端到端网络直接从未处理的rgb—&gt;修复完成的depth map，最后加上project depth map</li>\n</ol>\n<p>hmd的数据集刨除h36m应该有18000+ train set，现在只有9000+ 重新用脚本处理一遍</p>\n<p>numpy 高级索引 ndarray[x,y]//ndarray[a==b]</p>\n<h3 id=\"2019-11-26\"><a href=\"#2019-11-26\" class=\"headerlink\" title=\"2019.11.26\"></a>2019.11.26</h3><p>机器在处理数据（就是做hmd 里的 wild set）（coco做了7000+然后断开socket链接了，回头继续转）<br>问题转化为：有遮挡的rgb图生成完整的深度图的问题<br>DDRNet做的深度图重建。<br>试试<a href=\"https://github.com/iro-cp/FCRN-DepthPrediction.git\" target=\"_blank\" rel=\"noopener\">Deeper Depth Prediction with Fully Convolutional Residual Networks (FCRN)</a><br>还有<a href=\"https://github.com/neycyanshi/DDRNet\" target=\"_blank\" rel=\"noopener\">ddrnet</a>  </p>\n<p>王琛的方法，需要提供人体/遮挡的数据集（考虑下怎么做这个数据集），网络是现成的<br>三维人体重建转化到深度图的inpainting这样可以吗？？  </p>\n<p>更新ubuntu grub的引导会没 需要到win7下重设</p>\n<h3 id=\"2019-11-27\"><a href=\"#2019-11-27\" class=\"headerlink\" title=\"2019.11.27\"></a>2019.11.27</h3><p>coco数据集的hmd预处理还是有socket error，今晚挂上代理再试一次<br>问题：有遮挡的情况下恢复深度图的detail，还是考虑深度图质量差不多的情况下，深度图生成三维模型的精度<br>见今日周报 基本确定12月的工作内容  </p>\n<h3 id=\"2019-11-28\"><a href=\"#2019-11-28\" class=\"headerlink\" title=\"2019.11.28\"></a>2019.11.28</h3><p>固定像素位置加遮罩很容易（已完成），考虑往人体固定位置上加？<br>人体的数据集就18000+ 顶多了 看别人做inpainting的得有4/5w<br>监督数据怎么来？1. 通过hmd shading net出深度图；2. 找别的深度估计方法  </p>\n<h3 id=\"2019-11-29\"><a href=\"#2019-11-29\" class=\"headerlink\" title=\"2019.11.29\"></a>2019.11.29</h3><p>先用shadingnet的结果做gt吧，开始处理数据集</p>\n<h3 id=\"2019-11-30-1\"><a href=\"#2019-11-30-1\" class=\"headerlink\" title=\"2019.11.30/1\"></a>2019.11.30/1</h3><p>effective c++<br>休</p>\n<h3 id=\"2019-12-2\"><a href=\"#2019-12-2\" class=\"headerlink\" title=\"2019.12.2\"></a>2019.12.2</h3><p>生成depth ground truth 流程如下<br>img—&gt;hmr result（predict_hmr_dm 批处理hmd_2 18403张train img）—&gt;depth result（predict_hmd_dm 生成depth 到hmd_masked/train）<br>做depthmap的gt要150hrs。。？</p>\n<p>感觉没人做带遮挡的rgb到depth的映射(也就是inpainting和depth estimation的混合)<br>现有的depth estimation方法 pretrained的model对人体的效果极差 根本比不了hmd的shadingnet结果 见周报图<br>incomplete RGB —&gt; complete depth 做不动<br>incomplete RGB —&gt; incomplete depth —&gt; complete depth<br>想出incomplete depth还得150hrs<br>最后可能只能在深度图上做inpainting</p>\n<h3 id=\"2019-12-3\"><a href=\"#2019-12-3\" class=\"headerlink\" title=\"2019.12.3\"></a>2019.12.3</h3><p>写周报<br>leetcode</p>\n<h3 id=\"2019-12-4\"><a href=\"#2019-12-4\" class=\"headerlink\" title=\"2019.12.4\"></a>2019.12.4</h3><p>人体的rgb inpainting目前都没有人做的好，主要是会拿背景的信息填充到人体遮挡区域<br>考虑使用sil，把人体抠出来，看看能不能训练一个针对人体的inpainting网络，再出深度图看效果<br>注：rgb重建的效果也不会特别好，举个例子，拿衣服去补人脸的位置，肯定效果不对。但是，转成深度图再到三维模型上，效果不一定会特别差，待试<br>想想怎么给inpainting的输入加入人体轮廓信息这个约束<br>rbg修复好了 —&gt; 深度图效果好 —&gt; 模型效果好  </p>\n<p>王琛表示深度图做修复能做，接下来准备等深度图数据集处理完成，进inpainting网络，训练修复深度图的网络模型。</p>\n<h3 id=\"2019-12-5\"><a href=\"#2019-12-5\" class=\"headerlink\" title=\"2019.12.5\"></a>2019.12.5</h3><p>玩kbengine，部署linux游戏服务器，打包安卓客户端，双端联机测试<br>深度图要等到周日晚上，给王琛做</p>\n<h3 id=\"2019-12-6-7-8\"><a href=\"#2019-12-6-7-8\" class=\"headerlink\" title=\"2019.12.6/7/8\"></a>2019.12.6/7/8</h3><p>休</p>\n<h3 id=\"2019-12-9\"><a href=\"#2019-12-9\" class=\"headerlink\" title=\"2019.12.9\"></a>2019.12.9</h3><p>train depth inpainting model<br>shift-net_pytorch 深度图做出npy和png了，shift-net的图片都是256256，我这是448448，需要调整下网络</p>\n<h3 id=\"2019-12-10\"><a href=\"#2019-12-10\" class=\"headerlink\" title=\"2019.12.10\"></a>2019.12.10</h3><p>开始训练针对深度图的shift-net，30hrs(30 epoch) 明天放到hmd里看效果<br>这次训练用的center mask(25%左右的遮挡率) 有些把人遮住太多了 下次试试随机的或者范围小一点的<br>玩kbengine</p>\n<h3 id=\"2019-12-11\"><a href=\"#2019-12-11\" class=\"headerlink\" title=\"2019.12.11\"></a>2019.12.11</h3><p>贵州电网的一个UI材质工具<br>train好的modeltest需要测试集的depth map，2000多张得搞一下<br>hmd的shading-net没有train code，也就是说rgb到depth这段没有源码，shift-net做inpainting已经很好了，如果有shading-net的train code，合起来或许能做 incomplete rgb —&gt; complete depth<br>NYU的数据集看了精度肯定不够  </p>\n<h3 id=\"2019-12-12\"><a href=\"#2019-12-12\" class=\"headerlink\" title=\"2019.12.12\"></a>2019.12.12</h3><p>出inpainting好的深度图重建出的三维模型，这个算是完成目标了，但是是分两阶段完成（不完整rgb—&gt;不完整depth—&gt;完整depth）<br>接下来看shadingnet怎么train的，得能跑通</p>\n<p>3d mesh —&gt; 图像空间 初步深度信息 —》 shadingnet 增强深度信息—》<br>mesh到depth的原理 还有 ddrnet的那个loss  </p>\n<p>开题报告</p>\n<h3 id=\"2019-12-13-14-15\"><a href=\"#2019-12-13-14-15\" class=\"headerlink\" title=\"2019.12.13/14/15\"></a>2019.12.13/14/15</h3><p>开题报告</p>\n<h3 id=\"2019-12-16\"><a href=\"#2019-12-16\" class=\"headerlink\" title=\"2019.12.16\"></a>2019.12.16</h3><p>hmd: 训练策略（train scheme）是仿照的sfsnet<br>  先用了一个Unet，train时候输入是RGB + hmr投影出来的depth，监督数据是Kinect扫的depth（这个Unet train的时候只用到了少量数据集，然后用训练好的模型生成大量的depth，此时depth效果不好）<br>  然后是shadingnet，train的输入是hmr投影出来的depth和原始RGB，一个loss是用unet的输出监督，一个loss是photometric reconstruction loss（问题是这个reconstruct 重建了什么 就能知道重建的这个玩意儿跟什么做比较成为损失函数）</p>\n<p>重点看ddrnet怎么优化depth的，原理是什么</p>\n<blockquote>\n<p><strong>阶段性总结</strong>  </p>\n<ol>\n<li>明确人体细节是由深度图产生的，三维重建问题转化到深度图修复问题上</li>\n<li>做出了深度图数据集 18000+3000</li>\n<li>shift-net针对深度图训练了一个模型，可以用于深度图恢复</li>\n<li>tex2shape/octupus/hmr/hmd 基本可以跑对比实验了</li>\n</ol>\n</blockquote>\n<p>接下来的工作是做shadingnet的train<br>对比joint和anchor的train code<br>shadingnet的dataloader返回的是(src_img, depth_diff, mask)为什么要返回diff??? gt和smooth depth的差</p>\n<h3 id=\"2019-12-17\"><a href=\"#2019-12-17\" class=\"headerlink\" title=\"2019.12.17\"></a>2019.12.17</h3><p>自己做了shadingnet的train code，网络结构Unet（hmd给的），损失函数就用MSE，输入完整rgb还有mask，监督数据depth_gt，learning rate降到0.00001<br>搞搞看能不能rgb到depth 30分钟迭代900多次就训练完了 结束条件是什么不知道 测试中<br>测试结果不好 自己train出来的结果有明显颗粒感 深度数值范围0-1之间，pretrain的+-25之间 明天看</p>\n<h3 id=\"2019-12-18\"><a href=\"#2019-12-18\" class=\"headerlink\" title=\"2019.12.18\"></a>2019.12.18</h3><p>改开题报告 整点ddrnet的公式进去<br>shading net 用MSE train 完全不收敛啊  </p>\n<p>shadingnet dataloader ： mask就是coarse depth？！ 剪影代替的coarse depth？？ wtf  </p>\n<h3 id=\"2019-12-19\"><a href=\"#2019-12-19\" class=\"headerlink\" title=\"2019.12.19\"></a>2019.12.19</h3><p>两个问题：背景是黄的 是因为背景到人体的过度不自然，pre的是背景是0 人体上是0左右 正负50都有<br>细节是有的 但是我的像素不连续 有细节但是数值跟pre对应不上 颜色深浅<br>换个loss看看结果变不变 完全不变 调参也不变。。</p>\n<h3 id=\"2019-12-20\"><a href=\"#2019-12-20\" class=\"headerlink\" title=\"2019.12.20\"></a>2019.12.20</h3><p>不清楚网格的问题是不是通过调参就能解决的，或者换loss，还是不知道depth_diff干嘛用的<br>只能换loss了 自定义loss试试</p>\n<h3 id=\"2019-12-21\"><a href=\"#2019-12-21\" class=\"headerlink\" title=\"2019.12.21\"></a>2019.12.21</h3><p>原因是输入图像和gt图像没有匹配，低级错误<br>下一步进一步调参降低loss</p>\n<h3 id=\"2019-12-22\"><a href=\"#2019-12-22\" class=\"headerlink\" title=\"2019.12.22\"></a>2019.12.22</h3><ol>\n<li>eval pretrained model和我自己的model</li>\n<li>shift-net改下输出看结果<ol>\n<li>G &amp; D：G把输出的channel改成1，loss得跟depth比；让D区分gtdepth和preddepth</li>\n<li>backward_G and backward_D real_A real_B为什么有两个real？ dataloader在aligned_dataset.py里</li>\n<li>real_A == real_B//real_A—&gt;fake_B</li>\n<li>fake_B—netD—&gt;pred_fake//real_B—netD—&gt;pred_real</li>\n<li>set_gt_latent干什么用的</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>下周开始做改进改进版shift-net的实验<br>月底开始写论文</p>\n</blockquote>\n<h3 id=\"2019-12-23\"><a href=\"#2019-12-23\" class=\"headerlink\" title=\"2019.12.23\"></a>2019.12.23</h3><p>改shift-net：</p>\n<ol>\n<li>Gnet输入RGB，自己加遮罩，生成fake_rgb，用原始RGB监督；Dnet输入RGB和fake_rgb，输出两个判断结果的计算loss</li>\n<li>G输入3通道输出1通道，D出入1通道输出二分类，netD和vgg16featureextractor（util）<br>问题： 方框可能太大；把RGB的人挖出来比较好背景干扰太多<br>还是应该输出numpy数组，监督数据如果用png出来的是三通道的rgb图，得改可视化的代码，用plt通过numpy数组生成训练过程中图像</li>\n</ol>\n<h3 id=\"2019-12-24\"><a href=\"#2019-12-24\" class=\"headerlink\" title=\"2019.12.24\"></a>2019.12.24</h3><p>方框缩小，单通道输出，trainning，ETA 25号中午</p>\n<h3 id=\"2019-12-25\"><a href=\"#2019-12-25\" class=\"headerlink\" title=\"2019.12.25\"></a>2019.12.25</h3><p>test</p>\n<h3 id=\"2019-12-26\"><a href=\"#2019-12-26\" class=\"headerlink\" title=\"2019.12.26\"></a>2019.12.26</h3><p>spectral_norm gan用的东西<br>现在要解决的问题：重建深度图不光滑，有明显的网格，重复结构，不知道为什么<br>G就是个encoder decoder 为什么会有网格<br>试试用sil不用深度图的a[b==0] = 0 不行 sil只有8035个<br>把unet最后一层的tanh激活函数删了结果看起来好点了 迭代30次看看效果<br>7次 看起来还原出来的部分并没有什么细节</p>\n<h3 id=\"2019-12-27\"><a href=\"#2019-12-27\" class=\"headerlink\" title=\"2019.12.27\"></a>2019.12.27</h3><p>shift-net几个损失函数得调整，D一直为0了 content过于大<br>D的输入已经是抠出来的了，opt.overlap是什么</p>\n<h3 id=\"2019-12-28-29\"><a href=\"#2019-12-28-29\" class=\"headerlink\" title=\"2019.12.28/29\"></a>2019.12.28/29</h3><p>休<br>回放系统、撤销操作  </p>\n<h3 id=\"2019-12-30\"><a href=\"#2019-12-30\" class=\"headerlink\" title=\"2019.12.30\"></a>2019.12.30</h3><p>开会，确定一月时间安排<br>开始论文初稿，学习latex，写公式最麻烦，网络结构图，柱状图，折线图  </p>\n<p>怎么能让遮挡区域的数值乘个系数？？</p>\n<h3 id=\"2019-12-31\"><a href=\"#2019-12-31\" class=\"headerlink\" title=\"2019.12.31\"></a>2019.12.31</h3><p>abstract完成</p>\n<h3 id=\"2019-1-1\"><a href=\"#2019-1-1\" class=\"headerlink\" title=\"2019.1.1\"></a>2019.1.1</h3><p>开题ppt完成</p>\n<h3 id=\"2019-1-2\"><a href=\"#2019-1-2\" class=\"headerlink\" title=\"2019.1.2\"></a>2019.1.2</h3><p>latex画Unet</p>\n<h3 id=\"2019-1-3\"><a href=\"#2019-1-3\" class=\"headerlink\" title=\"2019.1.3\"></a>2019.1.3</h3><p>朱青审开题报告，ppt<br>修改</p>\n<h3 id=\"2019-1-4-5\"><a href=\"#2019-1-4-5\" class=\"headerlink\" title=\"2019.1.4/5\"></a>2019.1.4/5</h3><p>休</p>\n<h3 id=\"2019-1-6\"><a href=\"#2019-1-6\" class=\"headerlink\" title=\"2019.1.6\"></a>2019.1.6</h3><p>introduction<br>related work<br>method</p>\n<h3 id=\"2019-1-7\"><a href=\"#2019-1-7\" class=\"headerlink\" title=\"2019.1.7\"></a>2019.1.7</h3><p>result<br>conclusion</p>\n<blockquote>\n<p> <strong>论文结构</strong></p>\n<ol>\n<li><p>abstract</p>\n</li>\n<li><p>introduction<br>三维人体重建：分两种基于参数化模型的和非的/还是特征匹配的和模板适应的<br>目前方法的局限性，我的方法综述，贡献点总结</p>\n</li>\n<li><p>related work  </p>\n<ul>\n<li><p>参数化的  </p>\n<ul>\n<li>scape  <ul>\n<li>人工标记关键点<br>* </li>\n<li>卷积标记关键点  </li>\n</ul>\n</li>\n<li>smpl  </li>\n</ul>\n</li>\n<li><p>非参数化的  </p>\n</li>\n</ul>\n</li>\n<li><p>methods  </p>\n<ul>\n<li>SMPL，anchor/joint deformation，<strong>vertex deformation</strong>（our dataset, our net, loss）</li>\n<li>Loss：G_GAN,G_L1,D,style(MSE vgg),content</li>\n</ul>\n</li>\n<li>results &amp; comparison<br>介绍evaluation用的数据集，评价方法，评价/对比结果<br>hmr/hmd/tex2shape/octopus<br>原图inpainting/深度图inpainting/遮挡rgb生成完整的深度图<br>测试150加遮罩—&gt;(只能不带遮罩的进？？为什么)进shiftnet出深度图—&gt;hmd_s使用深度图信息而非shadingnet信息—&gt;结果</li>\n<li>conclusion</li>\n</ol>\n</blockquote>\n<h3 id=\"2020-1-13\"><a href=\"#2020-1-13\" class=\"headerlink\" title=\"2020.1.13\"></a>2020.1.13</h3><p>dhdnet在跑recon测试集的时候方框处理的非常不好<br>现在猜测是因为训练的用深度图gt当作的sil，在A[B==0]=0这步的时候很可能把纹理信息填回方框区域内了。。现在但是理论上shiftnet自己还会加遮罩<br>目前recon测试集上只能用不加遮挡的img做输入效果还可以<br>矛盾点在于 shiftnet是在线加的遮罩啊 为什么输入图像加不加遮罩还会造成影响？？？？</p>\n<h3 id=\"2020-1-14\"><a href=\"#2020-1-14\" class=\"headerlink\" title=\"2020.1.14\"></a>2020.1.14</h3><p>recon只看joint 还是得看syn<br>输入图像家的遮罩试着比 shiftnet动态加的小一点 84 84 140 140—&gt;87 87 137 137</p>\n<h3 id=\"2020-1-15\"><a href=\"#2020-1-15\" class=\"headerlink\" title=\"2020.1.15\"></a>2020.1.15</h3><p>leetcode<br>blog 加入vuejs静态页面<br>Mirror 多人游戏demo / kbe C++ 服务端  </p>\n<h3 id=\"2020-3-8\"><a href=\"#2020-3-8\" class=\"headerlink\" title=\"2020.3.8\"></a>2020.3.8</h3><p>Attention机制<a href=\"https://zhuanlan.zhihu.com/p/91839581\" target=\"_blank\" rel=\"noopener\">zhihu</a><br>论文搜索：<br>Self-Attention Generative Adversarial Networks (SAGAN)<a href=\"https://github.com/heykeetae/Self-Attention-GAN\" target=\"_blank\" rel=\"noopener\">code</a><br>A PyTorch reimplementation for paper Generative Image Inpainting with Contextual Attention <a href=\"https://arxiv.org/abs/1801.07892\" target=\"_blank\" rel=\"noopener\">paper</a> <a href=\"https://github.com/daa233/generative-inpainting-pytorch\" target=\"_blank\" rel=\"noopener\">code</a></p>\n<h3 id=\"2020-3-9\"><a href=\"#2020-3-9\" class=\"headerlink\" title=\"2020.3.9\"></a>2020.3.9</h3><p><a href=\"\">Learning 3D Human Shape and Pose from Dense Body Parts</a></p>\n<h3 id=\"2020-5-30\"><a href=\"#2020-5-30\" class=\"headerlink\" title=\"2020.5.30\"></a>2020.5.30</h3><p>Losses：下降较明显的有G_L1，content；G_GAN略上升，D下降不明显<br>loss计算公式：<br>$lossD = (lossDfake + lossDreal) <em> 0.5$ (vanilla)<br>fake/real 是BCELoss二分类交叉熵损失函数<br>$loss G = loss G L1 + loss G L1 m + loss G GAN + style loss + content loss + tv loss$<br>loss G L1 是 $L1 loss </em> opt.lambda_A$<br>L1_m 是一个spatical discounting l1 loss（别的论文里提出来的）<br>loss G GAN 是BCELoss<br>style和content都是MSELoss<br>tv是自定义一个损失函数  </p>\n<p>目前已有的：</p>\n<ul>\n<li>rgb特征提取—&gt;分三阶段形变smpl模型</li>\n<li>depth map到人体表面细节，形变方法（hmd提供）</li>\n<li>不完整rgb向完整depth map的转换网络模型</li>\n<li>不完整rgb到完整人体模型的端到端系统</li>\n<li>合成人体深度信息数据集</li>\n</ul>\n<p>后续研究方向（大论文第二章，改进算法）：</p>\n<ul>\n<li>center mask的大小对重建质量的影响（最大多大就handle不住了）</li>\n<li>不规则mask（shiftnet做了，这个好实现）</li>\n<li>attention机制对于结果的提升有多少（没概念）</li>\n<li>目前来看多loss共同作用，有些loss并没有明显收敛（是否等于没作用、贡献）—灼烧实验</li>\n<li>depth信息到三维点坐标的形变（deform）关系还能改进（比如深度或者说形变的scale，还有方向，目前是垂直于视平面，可以是垂直于粗模型表面？）</li>\n<li>structure from motion方向研究（全新方向，建筑行业在用）</li>\n<li>加壳，做成用户友好的应用程序</li>\n</ul>\n<h3 id=\"2020-6-2\"><a href=\"#2020-6-2\" class=\"headerlink\" title=\"2020.6.2\"></a>2020.6.2</h3><p>ICIP论文中的四个示例在recon_set中，编号为1，3，95，116  </p>\n<h3 id=\"2020-7-8\"><a href=\"#2020-7-8\" class=\"headerlink\" title=\"2020.7.8\"></a>2020.7.8</h3><p>专利：</p>\n<ul>\n<li>技术背景<ul>\n<li>应用与不足</li>\n<li>现有技术分析</li>\n<li>综上</li>\n</ul>\n</li>\n<li>发明内容</li>\n</ul>\n<h3 id=\"2020-7-13\"><a href=\"#2020-7-13\" class=\"headerlink\" title=\"2020.7.13\"></a>2020.7.13</h3><p>ICIP ppt<br><a href=\"https://zhuanlan.zhihu.com/p/25804146\" target=\"_blank\" rel=\"noopener\">mesh deformation with Laplacian coordinates</a>：一种智能化的方法，能够让用户只需设置个别离散点的新位置来表达他所想要的形变，就能自动根据所需保持的形体信息来计算出剩余离散点应有的位置</p>\n<h2 id=\"conda-env\"><a href=\"#conda-env\" class=\"headerlink\" title=\"conda env\"></a>conda env</h2><ul>\n<li>pytorch：Python 3.7 + pytorch 1.3  detectron2/densepose/shift-net_pytorch</li>\n<li>tf2: python2 + tf1.14  hmr, tex2shape, Semantic Human Texture Stitching</li>\n<li>tf: python3 + tf1.14 + pytorch  human_dynamics, neuralgym/generative_inpainting</li>\n<li>dirt：py2.7 + tf1.13 + dirt  octopus, garment</li>\n<li>hmd(可以跟tf2合并)：py2.7 + pytorch1.0.1  hmd</li>\n</ul>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><ul>\n<li><p>三通道rgb原图到三通道depth.convert(‘RGB’)效果不好，中心预测的不好，四周也没有跟gt完全一致。</p>\n<ul>\n<li>缩小遮挡范围1/2改为1/4的宽高</li>\n<li>输入三通道rgb 输出单通道npy数组 改下可视化的代码使正常显示</li>\n</ul>\n</li>\n<li><p>human_depth: 输入三通道depth_png，输出三通道修复完成后的depth_png，这是下边实验的目标效果</p>\n</li>\n<li>rgb2depth_npy_2: 初试版本，1/4边长遮挡，王瑾周报</li>\n<li>rgb2depth_npy_3: G去tanh()版本，网格纹理问题解决</li>\n<li>rgb2depth_npy_4: 修改D输入图像范围，仅输入被遮挡区域</li>\n</ul>\n<h2 id=\"数学理论相关\"><a href=\"#数学理论相关\" class=\"headerlink\" title=\"数学理论相关\"></a>数学理论相关</h2><p><a href=\"https://www.zhihu.com/question/28552876/answer/1268629178\" target=\"_blank\" rel=\"noopener\">压缩感知</a>中的欠定方程（undetermined equations）：</p>\n<h2 id=\"目标（朱邮件内容）\"><a href=\"#目标（朱邮件内容）\" class=\"headerlink\" title=\"目标（朱邮件内容）\"></a>目标（朱邮件内容）</h2><p>研究方向：<strong>非理想条件下的单目RGB相机三维人体重建</strong>  </p>\n<p>领域现状：目前基于相机阵列以及单目RGBD相机的三维人体重建技术已经较为成熟，仅依靠单目RGB相机的三维人体重建工作具有广阔的发展前景并且具有挑战性。以MPI、UCB、浙大为首的一些实验室已经在该研究方向上已经取得了一些成果，但是输入图像质量都比较理想，非理想条件下的重建效果并不明确。  </p>\n<p>我的工作：目前确定做非理想条件下的单目相机三维人体重建，提高重建精度包括模型细节、姿态、纹理贴图。非理想条件具体来说有以下情况：</p>\n<ol>\n<li>图像中人物受到遮挡（重点）</li>\n<li>图像中人物因高速移动产生的运动模糊</li>\n<li>图像中人物因环境光照产生的视觉偏差</li>\n</ol>\n<p>工作计划：看现有方法在上述非理想条件下的重建效果（文章中没有提到的需要亲自跑实验验证）；设计改善方法，反复实验验证，得到实验数据；论文撰写。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li>单图多人（人群）三维重建<br>可能需要解决的问题：<br>遮挡（周晓巍的PVNet解决了遮挡的问题，空间维度上的估计）<br>分割<br>大小/相对位置<br>…   </li>\n<li><p>跟游戏开发能关联的地方：<br>用引擎看效果<br>实用性  </p>\n</li>\n<li><p>从视频序列中选出作用显著的帧，设计量化评价方法  </p>\n</li>\n<li><p>从不同表达，面点云体素区别入手  </p>\n</li>\n<li><p>增加脸部细节（手部、脚步，观察几个论文的演示视频好像都没有动作细节，骨骼的问题应该是）呢？？结合3dmm（已经有结合的了19.10.10更新）  </p>\n</li>\n<li><p>考虑多模态，加入语义信息辅助重建（还得看nlp的东西，把特征映射到一个空间不知道能不能做）</p>\n</li>\n<li><p><strong>快速移动/运动模糊</strong>的视频/照片做重建（回到图像处理的问题上，不确定目前已有的方法在视频中任务快速移动情况下的重建效果）</p>\n</li>\n<li><p>UCB预测人体动作（时间维度上的估计） 能怎么改进</p>\n</li>\n<li><p>MPI做的实时 </p>\n</li>\n<li><p>UCB把SMPL用到了动物（斑马）模型重建；不是smpl是smal</p>\n</li>\n<li><p>光照条件对重建质量的影响</p>\n</li>\n</ul>\n<p>UCB做了动物的模型重建，根据视频<strong>预测</strong>人体接下来的动作；MPI<strong>实时</strong>Video to Mesh  </p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>shape：更有细节/遮挡、截断(空间维度预测)/<br>pose：根据视频、单图预测pose（时间维度预测）/实时更新pose<br>texture：单视角贴图/多视角贴图</p>\n</blockquote>\n</blockquote>\n<p><strong>疑问</strong><br>6D pose estimation 和 smpl/smal重建出的pose有何异同？？是一个东西吗<br>In contrast to coordinate or<br>heatmap based representations, learning such a representa-<br>tion enforces the network to focus on local features of ob-<br>jects and spatial relations between object parts. As a result,<br>the location of an invisible part can be inferred from the vis-<br>ible parts. In addition, this vector-field representation is able<br>to represent object keypoints that are even outside the input<br>image. All these advantages make it an ideal representation<br>for occluded or truncated objects.</p>\n</blockquote>\n<h2 id=\"时间安排\"><a href=\"#时间安排\" class=\"headerlink\" title=\"时间安排\"></a>时间安排</h2><blockquote>\n<p>VCIP 5月<br>ACM Multimedia 3月<br>ICIP 1月31日</p>\n<blockquote>\n<p>1月15日初稿和evaluation  </p>\n</blockquote>\n<p>1月开始写论文<br>12月实验，开题<br>开始编写代码，训练模型，评估实验数据<br>11月实验<br>设计优化思路，实验步骤，预期的实验结果 11.18-11.29 两周<br>现有方法在非理想情况下的表现 10.21-11.15 四周<br>10月底规划好实验步骤，预计出的结果<br>10月18号确定要做的目标</p>\n</blockquote>\n<h1 id=\"信息总结\"><a href=\"#信息总结\" class=\"headerlink\" title=\"信息总结\"></a>信息总结</h1><p>fusion<br>mulity domin<br>多元融合</p>\n<p>显著性<br>摘要<br>帧对重建质量的贡献</p>\n<p>王少帆 北工大计算机学院<br>dblp</p>\n<h1 id=\"todo-list\"><a href=\"#todo-list\" class=\"headerlink\" title=\"todo list\"></a>todo list</h1><p>数据清洗 三个数据集UP-3D，HumanEva-I，Human3.6M<br>清洗的目的？目标？要做成什么样？</p>\n","slug":"关于三维重建的文献综述","updated":"2020-07-13T15:32:40.346Z","comments":true,"link":"","permalink":"/2019/01/04/关于三维重建的文献综述/","excerpt":"","categories":[{"name":"论文综述","slug":"论文综述","permalink":"/categories/论文综述/"}],"tags":[{"name":"3D model reconstruction","slug":"3D-model-reconstruction","permalink":"/tags/3D-model-reconstruction/"},{"name":"文献综述","slug":"文献综述","permalink":"/tags/文献综述/"}]},{"title":"CS294-112 Fa18","date":"2018-12-21T06:19:30.000Z","path":"2018/12/21/CS294-112_Fa18/","text":"Deep reinforcement learningWeek One2018.12.6 Introduction and Course Overview Slide why now? reinforcement learning can be naturally integrated with artificial neural networks to obtain high-quality generalization experience replay : material instructive training instances provided by human teachers hierarchical learning non-Markovian environments by having a memory of their past what can DL&amp;RL do well now? Acquire high degree of proficiency in domains governed by simple, known rules Learn simple skills with raw sensory inputs, given enough experience Learn from imitating enough humanprovided expert behavior challenges Humans can learn incredibly quickly Humans can reuse past knowledge Not clear what the reward function should be Not clear what the role of prediction should be Week Two2018.12.13 Goals: understand definitions &amp; notation understand basic imitation learning algorithms understand their strengths &amp; weeknesses Sequential decision-making 顺序决策经典监督学习模式(imitation learning)不能完成自动驾驶的原因： 就算只犯一点点错误（预测结果与训练集数据不同）都会导致后续预测的偏差被逐渐放大 markovian behaviorDAgger. for markovian behavior we can use RNN, Recurrent Neural Networksfor multimodal behavior output mixture of gaussians latent variable models autoregressive discretization cost function for imitation homework1 因为mujoco有visual c++的依赖 还得安vs studio 准备装个linux虚拟机再做 Week Three2018.12.20tensorflow tutorial Week Four2018.12.21 作业1下周该做完了 markov 决策过程的定义 rl问题的定义 rl算法剖析 rl算法的类型简介 markov decision process是rl的基础markov chain-&gt;mdpS:state A:action O:observation T:transition e:emission probability r:reward function-&gt;r:SA-&gt;Robjectives: 公式in slidestate-action marginal—&gt;finite*stationary distribution—&gt;infiniteeigenvalue:特征值问题 algorithms","raw":"---\ntitle: CS294-112 Fa18\ndate: 2018-12-21 14:19:30\ntags: \n    - reinforcement learning\n    - berkeley course\n    - Sergey Levine\n---\n\n# Deep reinforcement learning  \n\n## Week One\n\n2018.12.6  \n\nIntroduction and Course Overview [Slide](http://rail.eecs.berkeley.edu/deeprlcourse/static/slides/lec-1.pdf)  \n\n* why now?\n    reinforcement learning can be naturally integrated with artificial neural networks to obtain high-quality generalization  \n    experience replay : [material](https://datascience.stackexchange.com/questions/20535/what-is-experience-replay-and-what-are-its-benefits)  \n    instructive training instances provided by human teachers  \n    hierarchical learning  \n    non-Markovian environments by having a memory of their past  \n\n* what can DL&RL do well now?\n    Acquire high degree of proficiency in domains governed by simple, known rules  \n    Learn simple skills with raw sensory inputs, given enough experience  \n    Learn from imitating enough humanprovided expert behavior  \n\n* challenges\n    Humans can learn incredibly quickly  \n    Humans can reuse past knowledge  \n    Not clear what the reward function should be  \n    Not clear what the role of prediction should be  \n\n## Week Two\n\n2018.12.13  \n\nGoals:\n\n* understand definitions & notation  \n* understand basic imitation learning algorithms\n* understand their strengths & weeknesses\n\nSequential decision-making 顺序决策\n经典监督学习模式(imitation learning)不能完成自动驾驶的原因：  \n\n* 就算只犯一点点错误（预测结果与训练集数据不同）都会导致后续预测的偏差被逐渐放大  \n\nmarkovian behavior  \nDAgger.  \n\nfor markovian behavior we can use RNN, Recurrent Neural Networks  \nfor multimodal behavior  \n\n1. output mixture of gaussians  \n2. latent variable models  \n3. autoregressive discretization  \n\ncost function for imitation  \n  \n* [homework1](http://rail.eecs.berkeley.edu/deeprlcourse/static/homeworks/hw1.pdf) 因为mujoco有visual c++的依赖 还得安vs studio 准备装个linux虚拟机再做  \n  \n## Week Three  \n  \n2018.12.20  \ntensorflow tutorial  \n  \n## Week Four  \n  \n2018.12.21  \n  \n作业1下周该做完了  \n  \n1. markov 决策过程的定义\n2. rl问题的定义\n3. rl算法剖析\n4. rl算法的类型简介  \n\nmarkov decision process是rl的基础\nmarkov chain->mdp  \nS:state A:action O:observation T:transition e:emission probability r:reward function->r:S*A->R  \nobjectives:  \n    公式in slide  \nstate-action marginal-->finite  \n**stationary distribution**-->infinite  \neigenvalue:特征值问题  \n  \n**algorithms**  \n","content":"<h1 id=\"Deep-reinforcement-learning\"><a href=\"#Deep-reinforcement-learning\" class=\"headerlink\" title=\"Deep reinforcement learning\"></a>Deep reinforcement learning</h1><h2 id=\"Week-One\"><a href=\"#Week-One\" class=\"headerlink\" title=\"Week One\"></a>Week One</h2><p>2018.12.6  </p>\n<p>Introduction and Course Overview <a href=\"http://rail.eecs.berkeley.edu/deeprlcourse/static/slides/lec-1.pdf\" target=\"_blank\" rel=\"noopener\">Slide</a>  </p>\n<ul>\n<li><p>why now?<br>  reinforcement learning can be naturally integrated with artificial neural networks to obtain high-quality generalization<br>  experience replay : <a href=\"https://datascience.stackexchange.com/questions/20535/what-is-experience-replay-and-what-are-its-benefits\" target=\"_blank\" rel=\"noopener\">material</a><br>  instructive training instances provided by human teachers<br>  hierarchical learning<br>  non-Markovian environments by having a memory of their past  </p>\n</li>\n<li><p>what can DL&amp;RL do well now?<br>  Acquire high degree of proficiency in domains governed by simple, known rules<br>  Learn simple skills with raw sensory inputs, given enough experience<br>  Learn from imitating enough humanprovided expert behavior  </p>\n</li>\n<li><p>challenges<br>  Humans can learn incredibly quickly<br>  Humans can reuse past knowledge<br>  Not clear what the reward function should be<br>  Not clear what the role of prediction should be  </p>\n</li>\n</ul>\n<h2 id=\"Week-Two\"><a href=\"#Week-Two\" class=\"headerlink\" title=\"Week Two\"></a>Week Two</h2><p>2018.12.13  </p>\n<p>Goals:</p>\n<ul>\n<li>understand definitions &amp; notation  </li>\n<li>understand basic imitation learning algorithms</li>\n<li>understand their strengths &amp; weeknesses</li>\n</ul>\n<p>Sequential decision-making 顺序决策<br>经典监督学习模式(imitation learning)不能完成自动驾驶的原因：  </p>\n<ul>\n<li>就算只犯一点点错误（预测结果与训练集数据不同）都会导致后续预测的偏差被逐渐放大  </li>\n</ul>\n<p>markovian behavior<br>DAgger.  </p>\n<p>for markovian behavior we can use RNN, Recurrent Neural Networks<br>for multimodal behavior  </p>\n<ol>\n<li>output mixture of gaussians  </li>\n<li>latent variable models  </li>\n<li>autoregressive discretization  </li>\n</ol>\n<p>cost function for imitation  </p>\n<ul>\n<li><a href=\"http://rail.eecs.berkeley.edu/deeprlcourse/static/homeworks/hw1.pdf\" target=\"_blank\" rel=\"noopener\">homework1</a> 因为mujoco有visual c++的依赖 还得安vs studio 准备装个linux虚拟机再做  </li>\n</ul>\n<h2 id=\"Week-Three\"><a href=\"#Week-Three\" class=\"headerlink\" title=\"Week Three\"></a>Week Three</h2><p>2018.12.20<br>tensorflow tutorial  </p>\n<h2 id=\"Week-Four\"><a href=\"#Week-Four\" class=\"headerlink\" title=\"Week Four\"></a>Week Four</h2><p>2018.12.21  </p>\n<p>作业1下周该做完了  </p>\n<ol>\n<li>markov 决策过程的定义</li>\n<li>rl问题的定义</li>\n<li>rl算法剖析</li>\n<li>rl算法的类型简介  </li>\n</ol>\n<p>markov decision process是rl的基础<br>markov chain-&gt;mdp<br>S:state A:action O:observation T:transition e:emission probability r:reward function-&gt;r:S<em>A-&gt;R<br>objectives:<br>    公式in slide<br>state-action marginal—&gt;finite<br><em>*stationary distribution</em></em>—&gt;infinite<br>eigenvalue:特征值问题  </p>\n<p><strong>algorithms</strong>  </p>\n","slug":"CS294-112_Fa18","updated":"2019-05-04T11:31:57.264Z","comments":true,"link":"","permalink":"/2018/12/21/CS294-112_Fa18/","excerpt":"","categories":[],"tags":[{"name":"reinforcement learning","slug":"reinforcement-learning","permalink":"/tags/reinforcement-learning/"},{"name":"berkeley course","slug":"berkeley-course","permalink":"/tags/berkeley-course/"},{"name":"Sergey Levine","slug":"Sergey-Levine","permalink":"/tags/Sergey-Levine/"}]},{"title":"git+sourcetree+腾讯云项目管理教程","date":"2018-12-20T02:36:46.000Z","path":"2018/12/20/git-sourcetree-腾讯云项目管理教程/","text":"注册腾讯云开发者平台 就是以前的coding.net 中文界面对国内开发者很友好，个人感觉可以代替github，新功能很有趣 进入项目-&gt;设置-&gt;成员管理可以添加项目成员，相当于github的organization 项目、仓库设置中可以转移项目所有权，免费将项目仓库设为私有，github私有仓库有月租 下载、安装git 注意配置环境变量 git GUI 推荐sourcetree，注册登录账号可能需要翻墙 2，3网上教程都很多这里就不写了 git lfs(large file storage) 当项目中有大小超过2m的文件时，建议使用lfs lfs使用教程(unity项目例子)LFS","raw":"---\ntitle: git+sourcetree+腾讯云项目管理教程\ndate: 2018-12-20 10:36:46\ntags:\n    - 腾讯云\n    - git\n    - sourcetree\n    - 版本控制\n    - 项目管理\n---\n\n1. 注册[腾讯云开发者平台](https://dev.tencent.com/)  \n    就是以前的coding.net  \n    *中文界面对国内开发者很友好，个人感觉可以代替github，新功能很有趣*  \n    进入项目->设置->成员管理可以添加项目成员，相当于github的organization  \n    项目、仓库设置中可以转移项目所有权，免费将项目仓库设为私有，github私有仓库有月租  \n2. 下载、安装git  \n    *注意配置环境变量*  \n3. git GUI  \n    推荐sourcetree，注册登录账号可能需要翻墙  \n    *2，3网上教程都很多这里就不写了*  \n4. git lfs(large file storage)  \n    当项目中有大小超过2m的文件时，建议使用lfs\n    lfs使用教程(unity项目例子)[LFS](https://blog.csdn.net/yaoyutian/article/details/78872102)","content":"<ol>\n<li>注册<a href=\"https://dev.tencent.com/\" target=\"_blank\" rel=\"noopener\">腾讯云开发者平台</a><br> 就是以前的coding.net<br> <em>中文界面对国内开发者很友好，个人感觉可以代替github，新功能很有趣</em><br> 进入项目-&gt;设置-&gt;成员管理可以添加项目成员，相当于github的organization<br> 项目、仓库设置中可以转移项目所有权，免费将项目仓库设为私有，github私有仓库有月租  </li>\n<li>下载、安装git<br> <em>注意配置环境变量</em>  </li>\n<li>git GUI<br> 推荐sourcetree，注册登录账号可能需要翻墙<br> <em>2，3网上教程都很多这里就不写了</em>  </li>\n<li>git lfs(large file storage)<br> 当项目中有大小超过2m的文件时，建议使用lfs<br> lfs使用教程(unity项目例子)<a href=\"https://blog.csdn.net/yaoyutian/article/details/78872102\" target=\"_blank\" rel=\"noopener\">LFS</a></li>\n</ol>\n","slug":"git-sourcetree-腾讯云项目管理教程","updated":"2019-05-04T11:31:57.270Z","comments":true,"link":"","permalink":"/2018/12/20/git-sourcetree-腾讯云项目管理教程/","excerpt":"","categories":[],"tags":[{"name":"腾讯云","slug":"腾讯云","permalink":"/tags/腾讯云/"},{"name":"git","slug":"git","permalink":"/tags/git/"},{"name":"sourcetree","slug":"sourcetree","permalink":"/tags/sourcetree/"},{"name":"版本控制","slug":"版本控制","permalink":"/tags/版本控制/"},{"name":"项目管理","slug":"项目管理","permalink":"/tags/项目管理/"}]},{"title":"deeplearning.ai","date":"2018-12-18T02:08:59.000Z","path":"2018/12/18/deeplearning-ai/","text":"Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimizationtrain/dev/test data set 在过去通常 60/20/20% 的比例，总样本数在10,000大数据时代通常在 98/1/1 或者后两个更小的比例，总样本在1,000,000 high bias&amp;high variance判断网络模型高偏差还是高方差还是两者都有的方法： 训练集上的错误率过高就是高偏差（例：人错误率，也称base error 1%，模型训练集上错误率15%，模型在开发集上错误率16%） 开发集上的错误率比训练集上的错误率高过多是高方差（例：人错误率14%，模型训练集上错误率15%，模型在开发集上错误率30%） 高偏差—&gt;更大的网络高方差—&gt;更多的数据—&gt;可能导致偏差变高—&gt;高偏差 Regularization正则化为的是避免过拟合L2 正则化 最常用 也被称为weight decayL1 正则化实际上，可以将Logistic Regression看做是仅含有一个神经元的单层的神经网络！正则化是如何避免overfitting的，换句话说怎么减小方差（variance）的？使得w变小—&gt;z变小—&gt;导致激活函数所取范围接近线性—&gt;避免overfitting，即避免高维非线性 What is L2-regularization actually doing?: L2-regularization relies on the assumption that a model with small weights is simpler than a model with large weights. Thus, by penalizing the square values of the weights in the cost function you drive all the weights to smaller values. It becomes too costly for the cost to have large weights! This leads to a smoother model in which the output changes more slowly as the input changes. Dropput 正则化：inverted dropout///keep-prob 一层的unit个数越多过拟合的可能越大，所以keep probability可以设置的小一些dropout在计算机视觉中经常用 因为输入是像素会非常多 对训练数据，例如图片进行翻转可以double训练数据数量 还有旋转、剪裁 几乎没有花费Early stoppingnormalizing training sets 为的是加速梯度下降算法，增加优化的步长如果网络层数非常大，会导致梯度下降传递的值指数型增大或减小，为避免，应当合理的初始化weight，使其接近1 12.27gradient checking 反向传递函数容易有bug又不易察觉，梯度检查就是检查导数算的对不对，可以增加对反向传递函数实现的正确性的信心Debugging: Gradient Checking 参考资料","raw":"---\ntitle: deeplearning.ai\ndate: 2018-12-18 10:08:59\ntags:\n    - Andrew Ng\n    - Deeplearning\n    - AI\n---\n\n# Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimization\n\ntrain/dev/test data set 在过去通常 60/20/20% 的比例，总样本数在10,000  \n大数据时代通常在 98/1/1 或者后两个更小的比例，总样本在1,000,000  \n  \nhigh bias&high variance  \n判断网络模型高偏差还是高方差还是两者都有的方法：  \n    训练集上的错误率过高就是高偏差（例：人错误率，也称base error 1%，模型训练集上错误率15%，模型在开发集上错误率16%）  \n    开发集上的错误率比训练集上的错误率高过多是高方差（例：人错误率14%，模型训练集上错误率15%，模型在开发集上错误率30%）  \n  \n高偏差-->更大的网络  \n高方差-->更多的数据-->可能导致偏差变高-->高偏差  \n\n## Regularization正则化\n\n为的是避免过拟合  \nL2 正则化 最常用 也被称为weight decay  \nL1 正则化  \n**实际上，可以将Logistic Regression看做是仅含有一个神经元的单层的神经网络！**  \n正则化是如何避免overfitting的，换句话说怎么减小方差（variance）的？  \n使得w变小-->z变小-->导致激活函数所取范围接近线性-->避免overfitting，即避免高维非线性  \n  \nWhat is L2-regularization actually doing?:  \n\nL2-regularization relies on the assumption that a model with small weights is simpler than a model with large weights. Thus, by penalizing the square values of the weights in the cost function you drive all the weights to smaller values. It becomes too costly for the cost to have large weights! This leads to a smoother model in which the output changes more slowly as the input changes.   \n  \nDropput 正则化：  \ninverted dropout///keep-prob 一层的unit个数越多过拟合的可能越大，所以keep probability可以设置的小一些  \ndropout在计算机视觉中经常用 因为输入是像素会非常多  \n  \n对训练数据，例如图片进行翻转可以double训练数据数量 还有旋转、剪裁 几乎没有花费  \nEarly stopping  \nnormalizing training sets 为的是加速梯度下降算法，增加优化的步长  \n如果网络层数非常大，会导致梯度下降传递的值指数型增大或减小，为避免，应当合理的初始化weight，使其接近1  \n  \n12.27  \ngradient checking 反向传递函数容易有bug又不易察觉，梯度检查就是检查导数算的对不对，可以增加对反向传递函数实现的正确性的信心  \nDebugging: Gradient Checking [参考资料](http://ufldl.stanford.edu/tutorial/supervised/DebuggingGradientChecking/)  \n","content":"<h1 id=\"Improving-Deep-Neural-Networks-Hyperparameter-tuning-Regularization-and-Optimization\"><a href=\"#Improving-Deep-Neural-Networks-Hyperparameter-tuning-Regularization-and-Optimization\" class=\"headerlink\" title=\"Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimization\"></a>Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimization</h1><p>train/dev/test data set 在过去通常 60/20/20% 的比例，总样本数在10,000<br>大数据时代通常在 98/1/1 或者后两个更小的比例，总样本在1,000,000  </p>\n<p>high bias&amp;high variance<br>判断网络模型高偏差还是高方差还是两者都有的方法：<br>    训练集上的错误率过高就是高偏差（例：人错误率，也称base error 1%，模型训练集上错误率15%，模型在开发集上错误率16%）<br>    开发集上的错误率比训练集上的错误率高过多是高方差（例：人错误率14%，模型训练集上错误率15%，模型在开发集上错误率30%）  </p>\n<p>高偏差—&gt;更大的网络<br>高方差—&gt;更多的数据—&gt;可能导致偏差变高—&gt;高偏差  </p>\n<h2 id=\"Regularization正则化\"><a href=\"#Regularization正则化\" class=\"headerlink\" title=\"Regularization正则化\"></a>Regularization正则化</h2><p>为的是避免过拟合<br>L2 正则化 最常用 也被称为weight decay<br>L1 正则化<br><strong>实际上，可以将Logistic Regression看做是仅含有一个神经元的单层的神经网络！</strong><br>正则化是如何避免overfitting的，换句话说怎么减小方差（variance）的？<br>使得w变小—&gt;z变小—&gt;导致激活函数所取范围接近线性—&gt;避免overfitting，即避免高维非线性  </p>\n<p>What is L2-regularization actually doing?:  </p>\n<p>L2-regularization relies on the assumption that a model with small weights is simpler than a model with large weights. Thus, by penalizing the square values of the weights in the cost function you drive all the weights to smaller values. It becomes too costly for the cost to have large weights! This leads to a smoother model in which the output changes more slowly as the input changes.   </p>\n<p>Dropput 正则化：<br>inverted dropout///keep-prob 一层的unit个数越多过拟合的可能越大，所以keep probability可以设置的小一些<br>dropout在计算机视觉中经常用 因为输入是像素会非常多  </p>\n<p>对训练数据，例如图片进行翻转可以double训练数据数量 还有旋转、剪裁 几乎没有花费<br>Early stopping<br>normalizing training sets 为的是加速梯度下降算法，增加优化的步长<br>如果网络层数非常大，会导致梯度下降传递的值指数型增大或减小，为避免，应当合理的初始化weight，使其接近1  </p>\n<p>12.27<br>gradient checking 反向传递函数容易有bug又不易察觉，梯度检查就是检查导数算的对不对，可以增加对反向传递函数实现的正确性的信心<br>Debugging: Gradient Checking <a href=\"http://ufldl.stanford.edu/tutorial/supervised/DebuggingGradientChecking/\" target=\"_blank\" rel=\"noopener\">参考资料</a>  </p>\n","slug":"deeplearning-ai","updated":"2019-05-04T11:31:57.269Z","comments":true,"link":"","permalink":"/2018/12/18/deeplearning-ai/","excerpt":"","categories":[],"tags":[{"name":"Andrew Ng","slug":"Andrew-Ng","permalink":"/tags/Andrew-Ng/"},{"name":"Deeplearning","slug":"Deeplearning","permalink":"/tags/Deeplearning/"},{"name":"AI","slug":"AI","permalink":"/tags/AI/"}]},{"title":"pytorch入门教程","date":"2018-11-19T13:02:00.000Z","path":"2018/11/19/pytorch入门教程/","text":"任务目标对Cifar-10图像数据集，用卷积神经网络进行分类，统计正确率。学会安装pytorch开源深度学习框架并调用它的接口。直接采用pytorch针对Cifar-10数据集已训练好的网络模型，只做测试。 实验过程准备阶段开发环境：windows10+anaconda+vscode，python3.6，pytorch0.4.1。首先安装anaconda，内置的环境配置功能，Spyder、JupterNotebook工具都能提高学习和开发效率；因为要使用GPU加速训练，选择合适的CUDA版本进行安装，我使用的是9.2版本。根据自己的环境在pytorch官网查找对应的安装命令： conda install pytorch cuda92 -c pytorch pip3 install torchvision 图像分类Torchvision提供了数据集的下载API，可以很方便的下载Cifar-10数据集并分为训练集和测试集；成功载入数据后，开始搭建神经网络，定义神经网络的层次结构以及正向传递函数；初始化一个网络对象并载入GPU（使用CPU训练可以省略这个步骤）；下面定义训练函数，损失函数选择交叉熵损失函数，优化函数选择梯度下降算法，训练的每一次迭代中使用损失函数进行反向传递，优化器更新参数；下面进入测试阶段，统计10000张测试图片的正确率，统计每一类图片（1000张）的正确率。 Pytorch APITorchvision.datasets 数据集Torch.nn 神经网络模块Torch.optim 用于实现多种优化算法的包 torch.utils.data.DataLoader 载入数据（需要注意的是该方法第四个参数决定是否使用多线程载入数据，而windows上的python对于多线程的支持与linux不同）nn.conv2d() 卷积层nn.maxpool2d() 池化层nn.zeropad2d() 填充边界nn.linear() 线性变化nn.CrossEntropyLoss() 交叉熵损失函数optim.SGD 梯度下降算法torch.max() 返回张量中最大的值 保存和载入模型保存模型torch.save(net.state_dict(), ‘./MyTrainedModel/pretrained.pth’)载入模型net.load_state_dict(torch.load(‘./MyTrainedModel/pretrained.pth’))net.eval()","raw":"---\ntitle: pytorch入门教程\ndate: 2018-11-19 21:02:00\ntags:\n    - pytorch\n    - 深度学习\n    - cifar-10\n---\n\n### 任务目标\n对Cifar-10图像数据集，用卷积神经网络进行分类，统计正确率。\n学会安装pytorch开源深度学习框架并调用它的接口。\n直接采用pytorch针对Cifar-10数据集已训练好的网络模型，只做测试。\n\n### 实验过程\n\n**准备阶段**\n开发环境：windows10+anaconda+vscode，python3.6，pytorch0.4.1。 \n首先安装anaconda，内置的环境配置功能，Spyder、JupterNotebook工具都能提高学习和开发效率； \n因为要使用GPU加速训练，选择合适的CUDA版本进行安装，我使用的是9.2版本。 \n根据自己的环境在pytorch官网查找对应的安装命令： \n\tconda install pytorch cuda92 -c pytorch \n\tpip3 install torchvision \n\n**图像分类**\nTorchvision提供了数据集的下载API，可以很方便的下载Cifar-10数据集并分为训练集和测试集； \n成功载入数据后，开始搭建神经网络，定义神经网络的层次结构以及正向传递函数； \n初始化一个网络对象并载入GPU（使用CPU训练可以省略这个步骤）； \n下面定义训练函数，损失函数选择交叉熵损失函数，优化函数选择梯度下降算法，训练的每一次迭代中使用损失函数进行反向传递，优化器更新参数； \n下面进入测试阶段，统计10000张测试图片的正确率，统计每一类图片（1000张）的正确率。 \n\n**Pytorch API**\nTorchvision.datasets\t数据集 \nTorch.nn\t\t神经网络模块 \nTorch.optim\t用于实现多种优化算法的包 \n\ntorch.utils.data.DataLoader\t载入数据（需要注意的是该方法第四个参数决定是否使用多线程载入数据，而windows上的python对于多线程的支持与linux不同） \nnn.conv2d()\t卷积层 \nnn.maxpool2d()\t\t池化层 \nnn.zeropad2d()\t\t填充边界 \nnn.linear()\t\t\t线性变化 \nnn.CrossEntropyLoss()\t交叉熵损失函数 \noptim.SGD\t\t\t梯度下降算法 \ntorch.max()\t\t\t返回张量中最大的值 \n\n**保存和载入模型**\n保存模型 \ntorch.save(net.state_dict(), './MyTrainedModel/pretrained.pth') \n载入模型 \nnet.load_state_dict(torch.load('./MyTrainedModel/pretrained.pth')) \nnet.eval() ","content":"<h3 id=\"任务目标\"><a href=\"#任务目标\" class=\"headerlink\" title=\"任务目标\"></a>任务目标</h3><p>对Cifar-10图像数据集，用卷积神经网络进行分类，统计正确率。<br>学会安装pytorch开源深度学习框架并调用它的接口。<br>直接采用pytorch针对Cifar-10数据集已训练好的网络模型，只做测试。</p>\n<h3 id=\"实验过程\"><a href=\"#实验过程\" class=\"headerlink\" title=\"实验过程\"></a>实验过程</h3><p><strong>准备阶段</strong><br>开发环境：windows10+anaconda+vscode，python3.6，pytorch0.4.1。<br>首先安装anaconda，内置的环境配置功能，Spyder、JupterNotebook工具都能提高学习和开发效率；<br>因为要使用GPU加速训练，选择合适的CUDA版本进行安装，我使用的是9.2版本。<br>根据自己的环境在pytorch官网查找对应的安装命令：<br>    conda install pytorch cuda92 -c pytorch<br>    pip3 install torchvision </p>\n<p><strong>图像分类</strong><br>Torchvision提供了数据集的下载API，可以很方便的下载Cifar-10数据集并分为训练集和测试集；<br>成功载入数据后，开始搭建神经网络，定义神经网络的层次结构以及正向传递函数；<br>初始化一个网络对象并载入GPU（使用CPU训练可以省略这个步骤）；<br>下面定义训练函数，损失函数选择交叉熵损失函数，优化函数选择梯度下降算法，训练的每一次迭代中使用损失函数进行反向传递，优化器更新参数；<br>下面进入测试阶段，统计10000张测试图片的正确率，统计每一类图片（1000张）的正确率。 </p>\n<p><strong>Pytorch API</strong><br>Torchvision.datasets    数据集<br>Torch.nn        神经网络模块<br>Torch.optim    用于实现多种优化算法的包 </p>\n<p>torch.utils.data.DataLoader    载入数据（需要注意的是该方法第四个参数决定是否使用多线程载入数据，而windows上的python对于多线程的支持与linux不同）<br>nn.conv2d()    卷积层<br>nn.maxpool2d()        池化层<br>nn.zeropad2d()        填充边界<br>nn.linear()            线性变化<br>nn.CrossEntropyLoss()    交叉熵损失函数<br>optim.SGD            梯度下降算法<br>torch.max()            返回张量中最大的值 </p>\n<p><strong>保存和载入模型</strong><br>保存模型<br>torch.save(net.state_dict(), ‘./MyTrainedModel/pretrained.pth’)<br>载入模型<br>net.load_state_dict(torch.load(‘./MyTrainedModel/pretrained.pth’))<br>net.eval() </p>\n","slug":"pytorch入门教程","updated":"2019-05-04T11:31:57.271Z","comments":true,"link":"","permalink":"/2018/11/19/pytorch入门教程/","excerpt":"","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"pytorch","slug":"pytorch","permalink":"/tags/pytorch/"},{"name":"cifar-10","slug":"cifar-10","permalink":"/tags/cifar-10/"}]},{"title":"网络与信息安全总结","date":"2018-11-04T08:10:17.000Z","path":"2018/11/04/网络与信息安全总结/","text":"五种块加密操作模式总结 Electronic Code Book(ECB) ECB模式是最直接的块加密方法，将明文分成若干n-bit的块，然后分别进行块加密。过程如下所示：加密：yi = e(xi) 其中xi等大小为n解密：xi = e^-1(yi)因此ECB模式的速度很快，此外，该模式下各块可以并行操作无需同步，也就是说解密方可以在得到所有块之前就开始进行解密。同时一个字节的错误（丢失）只会影响到其所在块。缺点在于，只要其加密密钥不变，相同明文生成的密文也将一致，最直观的例子就是使用ECB模式加密位图，可以很明显的看出原图的样子，这导致该模式易受到攻击。 Cipher Block Chaining(CBC) CBC模式不同于ECB模式，该模式下所有块被看作是一条完整的消息。CBC模式使用初始向量(Initialization Vector)保证加密的不确定性。第一个块的明文与IV进行与或运算，然后通过块加密算法进行加密。生成的密文作为下一个块的IV，以此类推，这个过程被称为反馈机制。过程如下所示：加密： y1 = e(xi XOR IV) yi = e(xi XOR yi-1), 以此类推解密： x1 = (e^-1(yi) XOR IV) xi = (e^-1(yi) XOR yi-1), 以此类推CBC模式最为常用，合理选择IV的情况下可以很大程度抵御攻击，但缺点是其不支持并行。 Cipher Feedback(CFB) CFB模式对IV进行加密，再与明文进行与或运算，生成的密文作为下一块的IV。CFB与OFB模式都将块加密当作流加密处理。加密过程不能并行，解密过程可以。同时如果一个密文损坏，将有两个明文块受损。过程如下所示：加密：y1=e(IV) XOR x1yi=(e(yi-1) XOR xi)，以此类推解密：x1=(e(IV) XOR y1)xi=(e(yi-1) XOR yi)，以此类推 Output Feedback(OFB) 与CFB模式类似，区别在于作为下一块IV的数据由与明文与或运算后的密文变为运算之前的密文。如果一个明文或者密文损坏，只有一个相应的密文或者明文损坏，并可以使用校正算法恢复损坏部分的先前值。过程如下：加密：s1= e(IV); y1=(s1 XOR x1)si = e(si-1); yi=(si XOR xi)，以此类推解密：s1= e(IV); x1=(s1 XOR y1)si = e(si-1); xi=(si XOR yi)，以此类推 Counter(CTR) CTR模式使块加密类似于流加密，每块采用一个随机数加计数器作为IV，经过加密运算后与明文进行与或运算后生成密文。优点在于加密解密都可以并行，明文密文一个损坏只影响一个相应输出，并可以使用校正算法恢复。过程如下：加密：yi = (e(IV || CTRi) XOR xi)解密：xi = (e(IV || CTRi) XOR yi) 定性分析与比较：ECB模式是最直接的使用块加密算法的方式，该模式速度快但是安全程度低；CBC弥补了ECB模式安全性上的缺陷，安全性高，但是其加密过程不支持并行，会导致效率较低；CFB和OFB模式极为相似，两个模式的加密与解密过程一致并且可以减少代码行数，但是与CBC相同，加密过程不支持并行，使得效率较低，安全性高；最后的CTR模式支持并行，理论上效率最高，安全性高，在实际中也使用最为广泛。 参考资料pdf加密文本、图片的脚本","raw":"---\ntitle: 网络与信息安全总结\ndate: 2018-11-04 16:10:17\ntags: \n    - 研究生课程\n    - 信息安全\n    - 加密\n    - 随机数\n    - 数字签名\n---\n\n# 五种块加密操作模式总结\n\n1. Electronic Code Book(ECB)\n\nECB模式是最直接的块加密方法，将明文分成若干n-bit的块，然后分别进行块加密。过程如下所示：\n加密：  \nyi = e(xi) 其中xi等大小为n  \n解密：  \nxi = e^-1(yi)  \n因此ECB模式的速度很快，此外，该模式下各块可以并行操作无需同步，也就是说解密方可以在得到所有块之前就开始进行解密。同时一个字节的错误（丢失）只会影响到其所在块。缺点在于，只要其加密密钥不变，相同明文生成的密文也将一致，最直观的例子就是使用ECB模式加密位图，可以很明显的看出原图的样子，这导致该模式易受到攻击。\n\n2. Cipher Block Chaining(CBC)\n\nCBC模式不同于ECB模式，该模式下所有块被看作是一条完整的消息。CBC模式使用初始向量(Initialization Vector)保证加密的不确定性。第一个块的明文与IV进行与或运算，然后通过块加密算法进行加密。生成的密文作为下一个块的IV，以此类推，这个过程被称为反馈机制。过程如下所示：\n加密：  \n    y1 = e(xi XOR IV)  \n    yi = e(xi XOR yi-1), 以此类推  \n解密：  \n    x1 = (e^-1(yi) XOR IV)  \n    xi = (e^-1(yi) XOR yi-1), 以此类推  \nCBC模式最为常用，合理选择IV的情况下可以很大程度抵御攻击，但缺点是其不支持并行。\n\n3. Cipher Feedback(CFB)\n\nCFB模式对IV进行加密，再与明文进行与或运算，生成的密文作为下一块的IV。CFB与OFB模式都将块加密当作流加密处理。加密过程不能并行，解密过程可以。同时如果一个密文损坏，将有两个明文块受损。过程如下所示：\n加密：  \ny1=e(IV) XOR x1  \nyi=(e(yi-1) XOR xi)，以此类推  \n解密：  \nx1=(e(IV) XOR y1)  \nxi=(e(yi-1) XOR yi)，以此类推  \n\n4. Output Feedback(OFB)\n\n与CFB模式类似，区别在于作为下一块IV的数据由与明文与或运算后的密文变为运算之前的密文。如果一个明文或者密文损坏，只有一个相应的密文或者明文损坏，并可以使用校正算法恢复损坏部分的先前值。过程如下：\n加密：  \ns1= e(IV); y1=(s1 XOR x1)  \nsi = e(si-1); yi=(si XOR xi)，以此类推  \n解密：  \ns1= e(IV); x1=(s1 XOR y1)  \nsi = e(si-1); xi=(si XOR yi)，以此类推  \n\n5. Counter(CTR)\n\nCTR模式使块加密类似于流加密，每块采用一个随机数加计数器作为IV，经过加密运算后与明文进行与或运算后生成密文。优点在于加密解密都可以并行，明文密文一个损坏只影响一个相应输出，并可以使用校正算法恢复。过程如下：\n加密：  \nyi = (e(IV || CTRi) XOR xi)  \n解密：  \nxi = (e(IV || CTRi) XOR yi)  \n\n**定性分析与比较：**\nECB模式是最直接的使用块加密算法的方式，该模式速度快但是安全程度低；CBC弥补了ECB模式安全性上的缺陷，安全性高，但是其加密过程不支持并行，会导致效率较低；CFB和OFB模式极为相似，两个模式的加密与解密过程一致并且可以减少代码行数，但是与CBC相同，加密过程不支持并行，使得效率较低，安全性高；最后的CTR模式支持并行，理论上效率最高，安全性高，在实际中也使用最为广泛。\n\n参考资料[pdf](ref.pdf)\n加密[文本](text.py)、[图片](pic.py)的脚本","content":"<h1 id=\"五种块加密操作模式总结\"><a href=\"#五种块加密操作模式总结\" class=\"headerlink\" title=\"五种块加密操作模式总结\"></a>五种块加密操作模式总结</h1><ol>\n<li>Electronic Code Book(ECB)</li>\n</ol>\n<p>ECB模式是最直接的块加密方法，将明文分成若干n-bit的块，然后分别进行块加密。过程如下所示：<br>加密：<br>yi = e(xi) 其中xi等大小为n<br>解密：<br>xi = e^-1(yi)<br>因此ECB模式的速度很快，此外，该模式下各块可以并行操作无需同步，也就是说解密方可以在得到所有块之前就开始进行解密。同时一个字节的错误（丢失）只会影响到其所在块。缺点在于，只要其加密密钥不变，相同明文生成的密文也将一致，最直观的例子就是使用ECB模式加密位图，可以很明显的看出原图的样子，这导致该模式易受到攻击。</p>\n<ol>\n<li>Cipher Block Chaining(CBC)</li>\n</ol>\n<p>CBC模式不同于ECB模式，该模式下所有块被看作是一条完整的消息。CBC模式使用初始向量(Initialization Vector)保证加密的不确定性。第一个块的明文与IV进行与或运算，然后通过块加密算法进行加密。生成的密文作为下一个块的IV，以此类推，这个过程被称为反馈机制。过程如下所示：<br>加密：<br>    y1 = e(xi XOR IV)<br>    yi = e(xi XOR yi-1), 以此类推<br>解密：<br>    x1 = (e^-1(yi) XOR IV)<br>    xi = (e^-1(yi) XOR yi-1), 以此类推<br>CBC模式最为常用，合理选择IV的情况下可以很大程度抵御攻击，但缺点是其不支持并行。</p>\n<ol>\n<li>Cipher Feedback(CFB)</li>\n</ol>\n<p>CFB模式对IV进行加密，再与明文进行与或运算，生成的密文作为下一块的IV。CFB与OFB模式都将块加密当作流加密处理。加密过程不能并行，解密过程可以。同时如果一个密文损坏，将有两个明文块受损。过程如下所示：<br>加密：<br>y1=e(IV) XOR x1<br>yi=(e(yi-1) XOR xi)，以此类推<br>解密：<br>x1=(e(IV) XOR y1)<br>xi=(e(yi-1) XOR yi)，以此类推  </p>\n<ol>\n<li>Output Feedback(OFB)</li>\n</ol>\n<p>与CFB模式类似，区别在于作为下一块IV的数据由与明文与或运算后的密文变为运算之前的密文。如果一个明文或者密文损坏，只有一个相应的密文或者明文损坏，并可以使用校正算法恢复损坏部分的先前值。过程如下：<br>加密：<br>s1= e(IV); y1=(s1 XOR x1)<br>si = e(si-1); yi=(si XOR xi)，以此类推<br>解密：<br>s1= e(IV); x1=(s1 XOR y1)<br>si = e(si-1); xi=(si XOR yi)，以此类推  </p>\n<ol>\n<li>Counter(CTR)</li>\n</ol>\n<p>CTR模式使块加密类似于流加密，每块采用一个随机数加计数器作为IV，经过加密运算后与明文进行与或运算后生成密文。优点在于加密解密都可以并行，明文密文一个损坏只影响一个相应输出，并可以使用校正算法恢复。过程如下：<br>加密：<br>yi = (e(IV || CTRi) XOR xi)<br>解密：<br>xi = (e(IV || CTRi) XOR yi)  </p>\n<p><strong>定性分析与比较：</strong><br>ECB模式是最直接的使用块加密算法的方式，该模式速度快但是安全程度低；CBC弥补了ECB模式安全性上的缺陷，安全性高，但是其加密过程不支持并行，会导致效率较低；CFB和OFB模式极为相似，两个模式的加密与解密过程一致并且可以减少代码行数，但是与CBC相同，加密过程不支持并行，使得效率较低，安全性高；最后的CTR模式支持并行，理论上效率最高，安全性高，在实际中也使用最为广泛。</p>\n<p>参考资料<a href=\"ref.pdf\">pdf</a><br>加密<a href=\"text.py\">文本</a>、<a href=\"pic.py\">图片</a>的脚本</p>\n","slug":"网络与信息安全总结","updated":"2019-05-04T11:31:57.320Z","comments":true,"link":"","permalink":"/2018/11/04/网络与信息安全总结/","excerpt":"","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"/tags/信息安全/"},{"name":"研究生课程","slug":"研究生课程","permalink":"/tags/研究生课程/"},{"name":"加密","slug":"加密","permalink":"/tags/加密/"},{"name":"随机数","slug":"随机数","permalink":"/tags/随机数/"},{"name":"数字签名","slug":"数字签名","permalink":"/tags/数字签名/"}]},{"title":"IPhoneX的叉","date":"2018-10-23T00:02:23.000Z","path":"2018/10/23/LostMyIPhone/","text":"钓鱼网站攻击记录XSScross site script网页里有input都可以插入html代码，一般是返回服务器的cookie，找到服务器管理员的相关信息。也可以从url插入代码 burpsuite功能强大的web攻击集成环境，community版本提供大部分功能，但是需要手动设置参数，企业版提供scanner扫描漏洞。 已知的钓鱼网站防护 限制input长度 将input的值使用document.* 方法转为%..%..样式的字符串，使其无法在html中编译 限制ip，每次进入网页的url都有唯一编码，看起来是md5加密的，一旦提交过信息封ip","raw":"---\ntitle: IPhoneX的叉\ndate: 2018-10-23 08:02:23\ntags: \n    - 信息安全\n    - XSS\n    - 钓鱼网站\n    - burpsuite\n---\n\n# 钓鱼网站攻击记录\n\n## XSS\n\n_cross site script_\n网页里有input都可以插入html代码，一般是返回服务器的cookie，找到服务器管理员的相关信息。\n也可以从url插入代码\n\n## burpsuite\n\n功能强大的web攻击集成环境，community版本提供大部分功能，但是需要手动设置参数，企业版提供scanner扫描漏洞。\n\n## 已知的钓鱼网站防护\n\n1. 限制input长度\n2. 将input的值使用document.* 方法转为%..%..样式的字符串，使其无法在html中编译\n3. 限制ip，每次进入网页的url都有唯一编码，看起来是md5加密的，一旦提交过信息封ip\n","content":"<h1 id=\"钓鱼网站攻击记录\"><a href=\"#钓鱼网站攻击记录\" class=\"headerlink\" title=\"钓鱼网站攻击记录\"></a>钓鱼网站攻击记录</h1><h2 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h2><p><em>cross site script</em><br>网页里有input都可以插入html代码，一般是返回服务器的cookie，找到服务器管理员的相关信息。<br>也可以从url插入代码</p>\n<h2 id=\"burpsuite\"><a href=\"#burpsuite\" class=\"headerlink\" title=\"burpsuite\"></a>burpsuite</h2><p>功能强大的web攻击集成环境，community版本提供大部分功能，但是需要手动设置参数，企业版提供scanner扫描漏洞。</p>\n<h2 id=\"已知的钓鱼网站防护\"><a href=\"#已知的钓鱼网站防护\" class=\"headerlink\" title=\"已知的钓鱼网站防护\"></a>已知的钓鱼网站防护</h2><ol>\n<li>限制input长度</li>\n<li>将input的值使用document.* 方法转为%..%..样式的字符串，使其无法在html中编译</li>\n<li>限制ip，每次进入网页的url都有唯一编码，看起来是md5加密的，一旦提交过信息封ip</li>\n</ol>\n","slug":"LostMyIPhone","updated":"2019-06-06T14:26:27.996Z","comments":true,"link":"","permalink":"/2018/10/23/LostMyIPhone/","excerpt":"","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"/tags/信息安全/"},{"name":"XSS","slug":"XSS","permalink":"/tags/XSS/"},{"name":"钓鱼网站","slug":"钓鱼网站","permalink":"/tags/钓鱼网站/"},{"name":"burpsuite","slug":"burpsuite","permalink":"/tags/burpsuite/"}]},{"title":"核聚变","date":"2018-05-06T04:12:37.000Z","path":"2018/05/06/核聚变/","text":"先说说嘉宾女流、女王盐、羽毛、伯爵、谷歌…永远都是前后脚差一步，就是见不到。五仁叔还是随和，下午抽时间进行了集中签名合影。因为只计划去一天，如果时间再充裕些应该去wegame，ps展区蹲他们一波。有些遗憾。吹哥Jonathan Blow被安排在了6号压轴出场，5号其实也在现场，只不过在采访间，不对外开放，由女流进行采访。这部分确实去现场还不如在家看直播。然后是Mr.Quin，没想到秦川现在这么火，一同来的朋友进场第一件事就是光顾quin先生的店铺，黑魂3-21期居然也在五月五号晚更新了，两万人同时观看，惊了。能消费的物品基本上就是T-shirt、抱枕、挂件，讲真确实无法激起我这种非秦国人消费的欲望。一姐——王妙一也在现场，《Will美好世界》有提供试玩，对她和她的作品知道的不多，不过能感受到她很愿意与玩家互动，交流看法。据她所言，新游戏已经在构思了，但是离发布应该还有很长的时间。 周边、贩卖区、消费相关上边提到了秦先生的店铺，这里展开评价下。印象比较深刻的是官方推出的LootBox——200块，两件T、两个马克杯、挂件、贴纸一些。肯定比单买要便宜，还有抽奖性质，有可能获得额外礼品。不好的地方在于L以上的号码10点之前就抢没了，每天限量，早起抢不到就只能第二天了；而且T、杯子的样式完全看脸，如果不喜欢随机到的样式，购物体验不会很好。然后是机核的吉考斯工业，专卖8周年的机组服装、包、挂件，价格略贵（最后附价格照片），但是蛮好看的。其他的..小店，漫画书，育碧的模型有一些，光顾的人不算多。关于饮食中午二楼提供盒饭，30一份至少看着干净，毕竟大家是来玩的。水的话自带比较方便。 游戏试玩PlayStation完爆Xbox，独立游戏真的多，游戏大厂表现平平。索尼有战神4和底特律变人，微软是Forza和古墓丽影崛起。育碧提供了起源和彩六。战马工作室也来了！看起来很重视中国市场啊，制作人一直在展区，很热情的跟大家互动。游戏很迷，大概是短短15分钟没法展现它的魅力吧。 红蓝对抗四个红蓝对抗——马车、GangBeasts、炸弹人、OverCooked都是初体验，但是全胜，还是有点膨胀的，平均排队时间15分钟上下。地狱挑战有火车、猎天使魔女2、马里奥制造和俄罗斯方块..如果不提前练习，确实很难完成挑战。最后红队微弱优势赢下第一天的红蓝对抗，临走是听见工作人员对着对讲机说有人中了switch，是真的牛逼疯了（3500个红队玩家抽4台switch，挂奖卡挂出“牛比疯了”就是switch）。 总的来说，第一次核聚变体验还是不错的，走的很累，对于没有switch的我玩了个够（在场的玩家感觉三个人里就有一个有switch）。大佬们露脸都不提前通知的，体验有点差，不知道是官方故意（怕拥堵）还是没有照顾到我们这些运气不好的玩家。真的想消费，但真的没什么特喜欢的（摊手。不过托机核的福，已经下单战神4了:)。","raw":"---\ntitle: 核聚变\ndate: 2018-05-06 12:12:37\ntags: \n    - 机核\n    - 游戏展\ncategories: 随笔\n---\n\n### 先说说嘉宾\n\n女流、女王盐、羽毛、伯爵、谷歌...永远都是前后脚差一步，就是见不到。五仁叔还是随和，下午抽时间进行了集中签名合影。因为只计划去一天，如果时间再充裕些应该去wegame，ps展区蹲他们一波。有些遗憾。吹哥Jonathan Blow被安排在了6号压轴出场，5号其实也在现场，只不过在采访间，不对外开放，由女流进行采访。这部分确实去现场还不如在家看直播。\n然后是Mr.Quin，没想到秦川现在这么火，一同来的朋友进场第一件事就是光顾quin先生的店铺，黑魂3-21期居然也在五月五号晚更新了，两万人同时观看，惊了。能消费的物品基本上就是T-shirt、抱枕、挂件，讲真确实无法激起我这种非秦国人消费的欲望。  \n一姐——王妙一也在现场，《Will美好世界》有提供试玩，对她和她的作品知道的不多，不过能感受到她很愿意与玩家互动，交流看法。据她所言，新游戏已经在构思了，但是离发布应该还有很长的时间。  \n\n### 周边、贩卖区、消费相关\n\n上边提到了秦先生的店铺，这里展开评价下。印象比较深刻的是官方推出的LootBox——200块，两件T、两个马克杯、挂件、贴纸一些。肯定比单买要便宜，还有抽奖性质，有可能获得额外礼品。不好的地方在于L以上的号码10点之前就抢没了，每天限量，早起抢不到就只能第二天了；而且T、杯子的样式完全看脸，如果不喜欢随机到的样式，购物体验不会很好。然后是机核的吉考斯工业，专卖8周年的机组服装、包、挂件，价格略贵（最后附价格照片），但是蛮好看的。其他的..小店，漫画书，育碧的模型有一些，光顾的人不算多。  \n关于饮食中午二楼提供盒饭，30一份至少看着干净，毕竟大家是来玩的。水的话自带比较方便。\n\n### 游戏试玩\n\nPlayStation完爆Xbox，独立游戏真的多，游戏大厂表现平平。    \n索尼有战神4和底特律变人，微软是Forza和古墓丽影崛起。育碧提供了起源和彩六。  \n战马工作室也来了！看起来很重视中国市场啊，制作人一直在展区，很热情的跟大家互动。游戏很迷，大概是短短15分钟没法展现它的魅力吧。\n\n### 红蓝对抗\n\n四个红蓝对抗——马车、GangBeasts、炸弹人、OverCooked都是初体验，但是全胜，还是有点膨胀的，平均排队时间15分钟上下。地狱挑战有火车、猎天使魔女2、马里奥制造和俄罗斯方块..如果不提前练习，确实很难完成挑战。最后红队微弱优势赢下第一天的红蓝对抗，临走是听见工作人员对着对讲机说有人中了switch，是真的牛逼疯了（3500个红队玩家抽4台switch，挂奖卡挂出“牛比疯了”就是switch）。  \n\n总的来说，第一次核聚变体验还是不错的，走的很累，对于没有switch的我玩了个够（在场的玩家感觉三个人里就有一个有switch）。大佬们露脸都不提前通知的，体验有点差，不知道是官方故意（怕拥堵）还是没有照顾到我们这些运气不好的玩家。真的想消费，但真的没什么特喜欢的（摊手。不过  \n**托机核的福，已经下单战神4了:)。**  \n\n![门票](核聚变/微信图片_20180506143855.jpg)\n{% asset_img 微信图片_201805061438551.jpg 红蓝对抗 %}\n{% asset_img 微信图片_201805061438552.jpg 地狱挑战 %}\n{% asset_img 微信图片_201805061438553.jpg 部分标价 %}\n{% asset_img 微信图片_201805061438554.jpg 玩家地区 %}\n{% asset_img 微信图片_201805061438555.jpg OW %}\n{% asset_img 微信图片_201805061438556.jpg overcooked %}\n{% asset_img 微信图片_201805061438557.jpg 战马 %}\n{% asset_img 微信图片_201805061438558.jpg 战神 %}\n{% asset_img 微信图片_201805061438559.jpg 底特律1 %}\n{% asset_img 微信图片_2018050614385510.jpg 底特律2 %}\n{% asset_img 微信图片_2018050614385511.jpg 大门 %}\n{% asset_img 微信图片_2018050614385512.jpg 场馆 %}","content":"<h3 id=\"先说说嘉宾\"><a href=\"#先说说嘉宾\" class=\"headerlink\" title=\"先说说嘉宾\"></a>先说说嘉宾</h3><p>女流、女王盐、羽毛、伯爵、谷歌…永远都是前后脚差一步，就是见不到。五仁叔还是随和，下午抽时间进行了集中签名合影。因为只计划去一天，如果时间再充裕些应该去wegame，ps展区蹲他们一波。有些遗憾。吹哥Jonathan Blow被安排在了6号压轴出场，5号其实也在现场，只不过在采访间，不对外开放，由女流进行采访。这部分确实去现场还不如在家看直播。<br>然后是Mr.Quin，没想到秦川现在这么火，一同来的朋友进场第一件事就是光顾quin先生的店铺，黑魂3-21期居然也在五月五号晚更新了，两万人同时观看，惊了。能消费的物品基本上就是T-shirt、抱枕、挂件，讲真确实无法激起我这种非秦国人消费的欲望。<br>一姐——王妙一也在现场，《Will美好世界》有提供试玩，对她和她的作品知道的不多，不过能感受到她很愿意与玩家互动，交流看法。据她所言，新游戏已经在构思了，但是离发布应该还有很长的时间。  </p>\n<h3 id=\"周边、贩卖区、消费相关\"><a href=\"#周边、贩卖区、消费相关\" class=\"headerlink\" title=\"周边、贩卖区、消费相关\"></a>周边、贩卖区、消费相关</h3><p>上边提到了秦先生的店铺，这里展开评价下。印象比较深刻的是官方推出的LootBox——200块，两件T、两个马克杯、挂件、贴纸一些。肯定比单买要便宜，还有抽奖性质，有可能获得额外礼品。不好的地方在于L以上的号码10点之前就抢没了，每天限量，早起抢不到就只能第二天了；而且T、杯子的样式完全看脸，如果不喜欢随机到的样式，购物体验不会很好。然后是机核的吉考斯工业，专卖8周年的机组服装、包、挂件，价格略贵（最后附价格照片），但是蛮好看的。其他的..小店，漫画书，育碧的模型有一些，光顾的人不算多。<br>关于饮食中午二楼提供盒饭，30一份至少看着干净，毕竟大家是来玩的。水的话自带比较方便。</p>\n<h3 id=\"游戏试玩\"><a href=\"#游戏试玩\" class=\"headerlink\" title=\"游戏试玩\"></a>游戏试玩</h3><p>PlayStation完爆Xbox，独立游戏真的多，游戏大厂表现平平。<br>索尼有战神4和底特律变人，微软是Forza和古墓丽影崛起。育碧提供了起源和彩六。<br>战马工作室也来了！看起来很重视中国市场啊，制作人一直在展区，很热情的跟大家互动。游戏很迷，大概是短短15分钟没法展现它的魅力吧。</p>\n<h3 id=\"红蓝对抗\"><a href=\"#红蓝对抗\" class=\"headerlink\" title=\"红蓝对抗\"></a>红蓝对抗</h3><p>四个红蓝对抗——马车、GangBeasts、炸弹人、OverCooked都是初体验，但是全胜，还是有点膨胀的，平均排队时间15分钟上下。地狱挑战有火车、猎天使魔女2、马里奥制造和俄罗斯方块..如果不提前练习，确实很难完成挑战。最后红队微弱优势赢下第一天的红蓝对抗，临走是听见工作人员对着对讲机说有人中了switch，是真的牛逼疯了（3500个红队玩家抽4台switch，挂奖卡挂出“牛比疯了”就是switch）。  </p>\n<p>总的来说，第一次核聚变体验还是不错的，走的很累，对于没有switch的我玩了个够（在场的玩家感觉三个人里就有一个有switch）。大佬们露脸都不提前通知的，体验有点差，不知道是官方故意（怕拥堵）还是没有照顾到我们这些运气不好的玩家。真的想消费，但真的没什么特喜欢的（摊手。不过<br><strong>托机核的福，已经下单战神4了:)。</strong>  </p>\n<p><img src=\"核聚变/微信图片_20180506143855.jpg\" alt=\"门票\"><br><br><br><br><br><br><br><br><br><br><br><br></p>\n","slug":"核聚变","updated":"2019-06-06T14:26:28.010Z","comments":true,"link":"","permalink":"/2018/05/06/核聚变/","excerpt":"","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"机核","slug":"机核","permalink":"/tags/机核/"},{"name":"游戏展","slug":"游戏展","permalink":"/tags/游戏展/"}]},{"title":"中国什么时候能有3A游戏","date":"2018-04-18T14:32:50.000Z","path":"2018/04/18/中国什么时候能有3A游戏/","text":"16号，《Will:美好世界》的制作人王妙一发了一篇文章《为什么中国不会有3A游戏》，一时间游戏圈里不少人讨论。其实对国内3A这事，在我17年大三下找实习的时候就有考虑过，今天梳理记录下。 文中提到真实渲染瓶颈——次时代游戏画面已经不足以成为游戏宣传的噱头或者说买点；然后是市场选择——手游实在是太方便，太容易做（相对于策划、美术、技术都要做到A的3A游戏），太容易挣钱了。 渲染瓶颈这点对我而言确实是新思路。作为一名玩家我喜欢拥有更真实的画面，更真实的细节的游戏，但仔细想想，近年来游戏画质的进步速度确实已经放缓看COD系列这种年货便可知。如今我们选择游戏，更多的是玩法（PUBG，爆红大逃杀），剧情（巫师3），关卡设计（塞尔达），甚至是观光看高还原度的风景（GTA，看门狗，farcry）。3A在近几年失去了渲染画面这个卖点。 然后是市场选择其实就是玩家选择，玩不玩你的游戏，给不给你花钱买账。说到底还是因为玩家的素质，国内愿意买主机的少，愿意为3A配一台1W块上下的电脑的人更少。不过，2017年好在一款PUBG横空出世，推动了国内中高档PC硬件的普及，这是3A游戏的一大利好。PUBG迟早要过劲儿，因为外挂，因为土豆服务器，因为BUG等等。谁能接住这些为了PUBG买了高端PC的玩家呢？R6能回温，Steam上游戏开发者各种感谢中国玩家和游戏主播都说明想玩好游戏的玩家数量在增加，而且这些玩家愿意为玩好游戏花钱了。中国3A，有戏。 这篇blog的title是中国什么时候能有3A，跟王 的不一样，是因为我相信中国能做3A，只是时间问题。可能因为玩家素质的问题，要等到我们90这一代的孩子出来玩游戏；也可能给贪玩蓝月充钱的油腻中年人受他孩子的影响想尝试真正的好游戏，这可能只用五年。中国第一款3A，划时代的意义，游戏界的里程碑，我相信许多人盯着这项荣誉。唯一阻拦他们的就是市场经济，是资本。而降低商业风险的根本还是有人买账，是消费者，是玩家。 腾讯和一系列网游时代的厂商，培养了国内玩家，免费游戏，付费增值的玩家习惯。不能说不对，赚到钱了就是对的，对商人。对开发者、想做3A的团队，是噩梦。 摆在开发者面前的还有一座大山，国内对于游戏影音等出版物的审查。跟电影行业一样，影响会小于影视创作，国内的游戏创作也是带着枷锁跳舞。能不能写出好故事，结合好玩法，就看制作人，策划的功力了。 一点题外话技术上，目前，仅仅是目前，我认为游戏制作其实已经有固定的工业流程了。国内目前普遍的手游开发过程都是精简（但不一定残缺）的游戏开发流程。作为一线开发人员只需要具备具体某一项能力，熟悉业务操作，掌握基本的技能技巧即可。即没有过多的发挥空间，有规范化模板，重复性较高。但是还是有需要技术突破的地方，可能是底层，可能是架构上，可能是一些先进的功能需求，这部分工作需要创造力和专业知识，是真正应该努力的方向。 Jonathan Blow的游戏设计哲学是合理的疯狂（还是的落在疯狂上）g-core节目","raw":"---\ntitle: 中国什么时候能有3A游戏\ndate: 2018-04-18 22:32:50\ntags:\n    - 3A\n    - 王妙一\ncategories: 随笔\n---\n\n16号，《Will:美好世界》的制作人王妙一发了一篇文章[《为什么中国不会有3A游戏》](https://weibo.com/ttarticle/p/show?id=2309404229552229480395)，一时间游戏圈里不少人讨论。其实对国内3A这事，在我17年大三下找实习的时候就有考虑过，今天梳理记录下。  \n\n文中提到真实渲染瓶颈——次时代游戏画面已经不足以成为游戏宣传的噱头或者说买点；然后是市场选择——手游实在是太方便，太容易做（相对于策划、美术、技术都要做到A的3A游戏），太容易挣钱了。  \n\n*渲染瓶颈*这点对我而言确实是新思路。作为一名玩家我喜欢拥有更真实的画面，更真实的细节的游戏，但仔细想想，近年来游戏画质的进步速度确实已经放缓看COD系列这种年货便可知。如今我们选择游戏，更多的是玩法（PUBG，爆红大逃杀），剧情（巫师3），关卡设计（塞尔达），甚至是观光看高还原度的风景（GTA，看门狗，farcry）。3A在近几年失去了渲染画面这个卖点。  \n\n然后是*市场选择*其实就是*玩家选择*，玩不玩你的游戏，给不给你花钱买账。说到底还是因为玩家的素质，国内愿意买主机的少，愿意为3A配一台1W块上下的电脑的人更少。不过，2017年好在一款PUBG横空出世，推动了国内中高档PC硬件的普及，这是3A游戏的一大利好。PUBG迟早要过劲儿，因为外挂，因为土豆服务器，因为BUG等等。谁能接住这些为了PUBG买了高端PC的玩家呢？R6能回温，Steam上游戏开发者各种感谢中国玩家和游戏主播都说明想玩好游戏的玩家数量在增加，而且这些玩家愿意为玩好游戏花钱了。中国3A，有戏。  \n\n这篇blog的title是中国什么时候能有3A，跟王 的不一样，是因为我相信中国能做3A，只是时间问题。可能因为玩家素质的问题，要等到我们90这一代的孩子出来玩游戏；也可能给贪玩蓝月充钱的油腻中年人受他孩子的影响想尝试真正的好游戏，这可能只用五年。中国第一款3A，划时代的意义，游戏界的里程碑，我相信许多人盯着这项荣誉。唯一阻拦他们的就是市场经济，是资本。而降低商业风险的根本还是有人买账，是消费者，是玩家。  \n\n腾讯和一系列网游时代的厂商，培养了国内玩家，免费游戏，付费增值的*玩家习惯*。不能说不对，赚到钱了就是对的，对商人。对开发者、想做3A的团队，是噩梦。  \n\n摆在开发者面前的还有一座大山，国内对于游戏影音等出版物的*审查*。跟电影行业一样，影响会小于影视创作，国内的游戏创作也是带着枷锁跳舞。能不能写出好故事，结合好玩法，就看制作人，策划的功力了。  \n\n# 一点题外话\n\n技术上，目前，仅仅是目前，我认为游戏制作其实已经有固定的工业流程了。国内目前普遍的手游开发过程都是精简（但不一定残缺）的游戏开发流程。作为一线开发人员只需要具备具体某一项能力，熟悉业务操作，掌握基本的技能技巧即可。即没有过多的发挥空间，有规范化模板，重复性较高。但是还是有需要技术突破的地方，可能是底层，可能是架构上，可能是一些先进的功能需求，这部分工作需要创造力和专业知识，是真正应该努力的方向。  \n\nJonathan Blow的游戏设计哲学是合理的疯狂（还是的落在疯狂上）  \ng-core节目  \n<iframe src=\"https://www.gcores.com/volumes/95312/embed\" width=\"480\" height=\"400\" allowtransparency=\"true\" border=\"0\" frameborder=\"0\" style=\"width:480px;height:400px;\"></iframe>","content":"<p>16号，《Will:美好世界》的制作人王妙一发了一篇文章<a href=\"https://weibo.com/ttarticle/p/show?id=2309404229552229480395\" target=\"_blank\" rel=\"noopener\">《为什么中国不会有3A游戏》</a>，一时间游戏圈里不少人讨论。其实对国内3A这事，在我17年大三下找实习的时候就有考虑过，今天梳理记录下。  </p>\n<p>文中提到真实渲染瓶颈——次时代游戏画面已经不足以成为游戏宣传的噱头或者说买点；然后是市场选择——手游实在是太方便，太容易做（相对于策划、美术、技术都要做到A的3A游戏），太容易挣钱了。  </p>\n<p><em>渲染瓶颈</em>这点对我而言确实是新思路。作为一名玩家我喜欢拥有更真实的画面，更真实的细节的游戏，但仔细想想，近年来游戏画质的进步速度确实已经放缓看COD系列这种年货便可知。如今我们选择游戏，更多的是玩法（PUBG，爆红大逃杀），剧情（巫师3），关卡设计（塞尔达），甚至是观光看高还原度的风景（GTA，看门狗，farcry）。3A在近几年失去了渲染画面这个卖点。  </p>\n<p>然后是<em>市场选择</em>其实就是<em>玩家选择</em>，玩不玩你的游戏，给不给你花钱买账。说到底还是因为玩家的素质，国内愿意买主机的少，愿意为3A配一台1W块上下的电脑的人更少。不过，2017年好在一款PUBG横空出世，推动了国内中高档PC硬件的普及，这是3A游戏的一大利好。PUBG迟早要过劲儿，因为外挂，因为土豆服务器，因为BUG等等。谁能接住这些为了PUBG买了高端PC的玩家呢？R6能回温，Steam上游戏开发者各种感谢中国玩家和游戏主播都说明想玩好游戏的玩家数量在增加，而且这些玩家愿意为玩好游戏花钱了。中国3A，有戏。  </p>\n<p>这篇blog的title是中国什么时候能有3A，跟王 的不一样，是因为我相信中国能做3A，只是时间问题。可能因为玩家素质的问题，要等到我们90这一代的孩子出来玩游戏；也可能给贪玩蓝月充钱的油腻中年人受他孩子的影响想尝试真正的好游戏，这可能只用五年。中国第一款3A，划时代的意义，游戏界的里程碑，我相信许多人盯着这项荣誉。唯一阻拦他们的就是市场经济，是资本。而降低商业风险的根本还是有人买账，是消费者，是玩家。  </p>\n<p>腾讯和一系列网游时代的厂商，培养了国内玩家，免费游戏，付费增值的<em>玩家习惯</em>。不能说不对，赚到钱了就是对的，对商人。对开发者、想做3A的团队，是噩梦。  </p>\n<p>摆在开发者面前的还有一座大山，国内对于游戏影音等出版物的<em>审查</em>。跟电影行业一样，影响会小于影视创作，国内的游戏创作也是带着枷锁跳舞。能不能写出好故事，结合好玩法，就看制作人，策划的功力了。  </p>\n<h1 id=\"一点题外话\"><a href=\"#一点题外话\" class=\"headerlink\" title=\"一点题外话\"></a>一点题外话</h1><p>技术上，目前，仅仅是目前，我认为游戏制作其实已经有固定的工业流程了。国内目前普遍的手游开发过程都是精简（但不一定残缺）的游戏开发流程。作为一线开发人员只需要具备具体某一项能力，熟悉业务操作，掌握基本的技能技巧即可。即没有过多的发挥空间，有规范化模板，重复性较高。但是还是有需要技术突破的地方，可能是底层，可能是架构上，可能是一些先进的功能需求，这部分工作需要创造力和专业知识，是真正应该努力的方向。  </p>\n<p>Jonathan Blow的游戏设计哲学是合理的疯狂（还是的落在疯狂上）<br>g-core节目  </p>\n<iframe src=\"https://www.gcores.com/volumes/95312/embed\" width=\"480\" height=\"400\" allowtransparency=\"true\" border=\"0\" frameborder=\"0\" style=\"width:480px;height:400px;\"></iframe>","slug":"中国什么时候能有3A游戏","updated":"2019-05-04T11:31:57.273Z","comments":true,"link":"","permalink":"/2018/04/18/中国什么时候能有3A游戏/","excerpt":"","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"3A","slug":"3A","permalink":"/tags/3A/"},{"name":"王妙一","slug":"王妙一","permalink":"/tags/王妙一/"}]},{"title":"完整游戏开发流程","date":"2018-04-12T13:43:40.000Z","path":"2018/04/12/完整游戏开发流程/","text":"如何完整的开发一款游戏GAD文章地址 简化： 确立核心玩法（策划团队与程序美术核心成员共同完成） Demo——验证玩法可行性 制定开发计划（原型阶段——核心阶段——迭代阶段——调整阶段） 原型阶段 更新计划 核心阶段（确定开发重点/工作重心） 正式迭代前的版本计划 开发规范需要提前做，做不好会导致返工，效率低 todo 联系软件工程理论，过程模型","raw":"---\ntitle: 完整游戏开发流程\ndate: 2018-04-12 21:43:40\ntags: \n    - GAD\n    - 开发流程\ncategories: 摘录\n---\n\n### 如何完整的开发一款游戏\n\nGAD文章[地址](https://mp.weixin.qq.com/s?__biz=MzA4MDc5OTg5MA==&mid=2650601307&idx=1&sn=1d38c6011cde7a332a148ff849a66ea6&chksm=8796e6a6b0e16fb0dc5e94af9225c0b59689666243e2cc26b9ef0127953d47a1c19c2ac384cc&scene=0#rd)\n\n简化：\n1. 确立核心玩法（策划团队与程序美术核心成员共同完成）\n2. Demo——验证玩法可行性\n3. 制定开发计划（原型阶段——核心阶段——迭代阶段——调整阶段）\n4. 原型阶段\n5. 更新计划\n6. 核心阶段（确定开发重点/工作重心）\n7. 正式迭代前的版本计划\n\n开发规范需要提前做，做不好会导致返工，效率低\n\ntodo 联系软件工程理论，过程模型","content":"<h3 id=\"如何完整的开发一款游戏\"><a href=\"#如何完整的开发一款游戏\" class=\"headerlink\" title=\"如何完整的开发一款游戏\"></a>如何完整的开发一款游戏</h3><p>GAD文章<a href=\"https://mp.weixin.qq.com/s?__biz=MzA4MDc5OTg5MA==&amp;mid=2650601307&amp;idx=1&amp;sn=1d38c6011cde7a332a148ff849a66ea6&amp;chksm=8796e6a6b0e16fb0dc5e94af9225c0b59689666243e2cc26b9ef0127953d47a1c19c2ac384cc&amp;scene=0#rd\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n<p>简化：</p>\n<ol>\n<li>确立核心玩法（策划团队与程序美术核心成员共同完成）</li>\n<li>Demo——验证玩法可行性</li>\n<li>制定开发计划（原型阶段——核心阶段——迭代阶段——调整阶段）</li>\n<li>原型阶段</li>\n<li>更新计划</li>\n<li>核心阶段（确定开发重点/工作重心）</li>\n<li>正式迭代前的版本计划</li>\n</ol>\n<p>开发规范需要提前做，做不好会导致返工，效率低</p>\n<p>todo 联系软件工程理论，过程模型</p>\n","slug":"完整游戏开发流程","updated":"2019-05-04T11:31:57.314Z","comments":true,"link":"","permalink":"/2018/04/12/完整游戏开发流程/","excerpt":"","categories":[{"name":"摘录","slug":"摘录","permalink":"/categories/摘录/"}],"tags":[{"name":"GAD","slug":"GAD","permalink":"/tags/GAD/"},{"name":"开发流程","slug":"开发流程","permalink":"/tags/开发流程/"}]},{"title":"PUBG-Unity","date":"2018-04-11T13:39:17.000Z","path":"2018/04/11/PUBG-Unity/","text":"游戏功能（技术实现） 安全区系统(Electric Field) 游戏计时器 根据预设点位(Pos)和尺寸(Scale)按时间触发缩圈 伤害判定 Player FP Controller Player物品栏 Player生命状态 AI 巡逻系统 攻击系统 AI生命状态 武器系统 物理子弹/射线子弹 子弹扩散 UI 开始菜单 主游戏界面—小地图 主游戏界面—player信息 主游戏界面—弹出类消息 背包界面 地图 方向指示 外部资源Next-Gen FPStodo 结构分析 功能改进 MapMagictodo emmm 截图 先写论文 写完在更","raw":"---\ntitle: PUBG-Unity\ndate: 2018-04-11 21:39:17\ntags: \n    - Unity\n    - FPS\n    - Sandbox\ncategories: 项目\n---\n\n### 游戏功能（技术实现）\n\n1. 安全区系统(Electric Field)\n\n    游戏计时器  \n    根据预设点位(Pos)和尺寸(Scale)按时间触发缩圈  \n    伤害判定\n\n2. Player\n\n    FP Controller  \n    Player物品栏  \n    Player生命状态  \n\n3. AI\n\n    巡逻系统  \n    攻击系统  \n    AI生命状态  \n\n4. 武器系统\n\n    物理子弹/射线子弹  \n    子弹扩散  \n\n5. UI\n\n    开始菜单  \n    主游戏界面--小地图\n    主游戏界面--player信息\n    主游戏界面--弹出类消息\n    背包界面\n    地图\n    方向指示\n\n\n### 外部资源\n\n## Next-Gen FPS\n\ntodo 结构分析 功能改进\n\n## MapMagic\n\ntodo emmm\n\n### 截图\n{% asset_img 1.png 游戏截图 %}\n{% asset_img 2.png 游戏截图 %}\n{% asset_img 3.png 游戏截图 %}\n{% asset_img 4.png 游戏截图 %}\n{% asset_img 5.png 游戏截图 %}\n{% asset_img 6.png 游戏截图 %}\n\n\n先写论文 写完在更","content":"<h3 id=\"游戏功能（技术实现）\"><a href=\"#游戏功能（技术实现）\" class=\"headerlink\" title=\"游戏功能（技术实现）\"></a>游戏功能（技术实现）</h3><ol>\n<li><p>安全区系统(Electric Field)</p>\n<p> 游戏计时器<br> 根据预设点位(Pos)和尺寸(Scale)按时间触发缩圈<br> 伤害判定</p>\n</li>\n<li><p>Player</p>\n<p> FP Controller<br> Player物品栏<br> Player生命状态  </p>\n</li>\n<li><p>AI</p>\n<p> 巡逻系统<br> 攻击系统<br> AI生命状态  </p>\n</li>\n<li><p>武器系统</p>\n<p> 物理子弹/射线子弹<br> 子弹扩散  </p>\n</li>\n<li><p>UI</p>\n<p> 开始菜单<br> 主游戏界面—小地图<br> 主游戏界面—player信息<br> 主游戏界面—弹出类消息<br> 背包界面<br> 地图<br> 方向指示</p>\n</li>\n</ol>\n<h3 id=\"外部资源\"><a href=\"#外部资源\" class=\"headerlink\" title=\"外部资源\"></a>外部资源</h3><h2 id=\"Next-Gen-FPS\"><a href=\"#Next-Gen-FPS\" class=\"headerlink\" title=\"Next-Gen FPS\"></a>Next-Gen FPS</h2><p>todo 结构分析 功能改进</p>\n<h2 id=\"MapMagic\"><a href=\"#MapMagic\" class=\"headerlink\" title=\"MapMagic\"></a>MapMagic</h2><p>todo emmm</p>\n<h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><img src=\"/2018/04/11/PUBG-Unity/1.png\" title=\"游戏截图\">\n<img src=\"/2018/04/11/PUBG-Unity/2.png\" title=\"游戏截图\">\n<img src=\"/2018/04/11/PUBG-Unity/3.png\" title=\"游戏截图\">\n<img src=\"/2018/04/11/PUBG-Unity/4.png\" title=\"游戏截图\">\n<img src=\"/2018/04/11/PUBG-Unity/5.png\" title=\"游戏截图\">\n<img src=\"/2018/04/11/PUBG-Unity/6.png\" title=\"游戏截图\">\n<p>先写论文 写完在更</p>\n","slug":"PUBG-Unity","updated":"2020-02-25T06:10:27.004Z","comments":true,"link":"","permalink":"/2018/04/11/PUBG-Unity/","excerpt":"","categories":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"/tags/Unity/"},{"name":"FPS","slug":"FPS","permalink":"/tags/FPS/"},{"name":"Sandbox","slug":"Sandbox","permalink":"/tags/Sandbox/"}]},{"title":"手机游戏美术资源提取","date":"2017-01-03T16:00:00.000Z","path":"2017/01/04/AdrenoProfiler/","text":"Adreno Profiler提取 网易镇魔曲手游美术资源","raw":"---\ntitle: 手机游戏美术资源提取\ndate: 2017-1-4 00:00:00\n---\n\n# Adreno Profiler提取 网易镇魔曲手游美术资源\n","content":"<h1 id=\"Adreno-Profiler提取-网易镇魔曲手游美术资源\"><a href=\"#Adreno-Profiler提取-网易镇魔曲手游美术资源\" class=\"headerlink\" title=\"Adreno Profiler提取 网易镇魔曲手游美术资源\"></a>Adreno Profiler提取 网易镇魔曲手游美术资源</h1>","slug":"AdrenoProfiler","updated":"2020-03-04T10:19:48.851Z","comments":true,"link":"","permalink":"/2017/01/04/AdrenoProfiler/","excerpt":"","categories":[],"tags":[]},{"title":"RPG Game","date":"2017-01-02T16:00:00.000Z","path":"2017/01/03/EgretGame/","text":"Sorry, NO ARTIST.Have a try 使用Egret引擎基于typescript语言使用了MVC架构类图","raw":"---\ntitle: RPG Game\ndate: 2017-1-3 00:00:00\n---\n\nSorry, NO ARTIST.\n[Have a try](http://htmlpreview.github.com/?https://github.com/Taye310/Game/blob/master/index.html)\n\n使用Egret引擎基于typescript语言\n使用了MVC架构\n[类图](https://www.processon.com/view/link/582c8526e4b05594f4eabbdd)","content":"<p>Sorry, NO ARTIST.<br><a href=\"http://htmlpreview.github.com/?https://github.com/Taye310/Game/blob/master/index.html\" target=\"_blank\" rel=\"noopener\">Have a try</a></p>\n<p>使用Egret引擎基于typescript语言<br>使用了MVC架构<br><a href=\"https://www.processon.com/view/link/582c8526e4b05594f4eabbdd\" target=\"_blank\" rel=\"noopener\">类图</a></p>\n","slug":"EgretGame","updated":"2019-05-04T11:31:57.265Z","comments":true,"link":"","permalink":"/2017/01/03/EgretGame/","excerpt":"","categories":[],"tags":[]},{"title":"A* Pathfinding","date":"2017-01-01T16:00:00.000Z","path":"2017/01/02/AStarPathfinding/","text":"A* Pathfinding tutorial in unity G cost: distance from starting nodeH cost(heuristic): distance from end nodeF cost: G cost + H cost 算最小F cost周围的node的cost，如果已经有值并且新cost小于旧cost，进行覆盖，迭代","raw":"---\ntitle: A* Pathfinding\ndate: 2017-1-2 00:00:00\ntag: \n    - algorithm\n---\n[A* Pathfinding tutorial in unity](https://www.youtube.com/watch?v=-L-WgKMFuhE&list=PLFt_AvWsXl0cq5Umv3pMC9SPnKjfp9eGW)\n\nG cost: distance from starting node  \nH cost(heuristic): distance from end node  \nF cost: G cost + H cost  \n\n算最小F cost周围的node的cost，如果已经有值并且新cost小于旧cost，进行覆盖，迭代  ","content":"<p><a href=\"https://www.youtube.com/watch?v=-L-WgKMFuhE&amp;list=PLFt_AvWsXl0cq5Umv3pMC9SPnKjfp9eGW\" target=\"_blank\" rel=\"noopener\">A* Pathfinding tutorial in unity</a></p>\n<p>G cost: distance from starting node<br>H cost(heuristic): distance from end node<br>F cost: G cost + H cost  </p>\n<p>算最小F cost周围的node的cost，如果已经有值并且新cost小于旧cost，进行覆盖，迭代  </p>\n","slug":"AStarPathfinding","updated":"2020-05-25T11:59:26.656Z","comments":true,"link":"","permalink":"/2017/01/02/AStarPathfinding/","excerpt":"","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"/tags/algorithm/"}]},{"title":"Hello World","date":"2016-12-31T16:00:00.000Z","path":"2017/01/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":"---\ntitle: Hello World\ndate: 2017-1-1 00:00:00\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","slug":"hello-world","updated":"2019-05-04T11:31:57.271Z","comments":true,"link":"","permalink":"/2017/01/01/hello-world/","excerpt":"","categories":[],"tags":[]}]}